/*
Copyright 2022 YANDEX LLC
This is modified version of the software, made by the Crossplane Authors
and available at: https://github.com/crossplane-contrib/provider-jet-template

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type AllocationPolicyInitParameters struct {

	// Array of availability zone IDs with list of instance tags.
	InstanceTagsPool []InstanceTagsPoolInitParameters `json:"instanceTagsPool,omitempty" tf:"instance_tags_pool,omitempty"`

	// A list of availability zones.
	// +listType=set
	Zones []*string `json:"zones,omitempty" tf:"zones,omitempty"`
}

type AllocationPolicyObservation struct {

	// Array of availability zone IDs with list of instance tags.
	InstanceTagsPool []InstanceTagsPoolObservation `json:"instanceTagsPool,omitempty" tf:"instance_tags_pool,omitempty"`

	// A list of availability zones.
	// +listType=set
	Zones []*string `json:"zones,omitempty" tf:"zones,omitempty"`
}

type AllocationPolicyParameters struct {

	// Array of availability zone IDs with list of instance tags.
	// +kubebuilder:validation:Optional
	InstanceTagsPool []InstanceTagsPoolParameters `json:"instanceTagsPool,omitempty" tf:"instance_tags_pool,omitempty"`

	// A list of availability zones.
	// +kubebuilder:validation:Optional
	// +listType=set
	Zones []*string `json:"zones" tf:"zones,omitempty"`
}

type ApplicationLoadBalancerInitParameters struct {

	// Do not wait load balancer health checks.
	IgnoreHealthChecks *bool `json:"ignoreHealthChecks,omitempty" tf:"ignore_health_checks,omitempty"`

	// Timeout for waiting for the VM to be checked by the load balancer. If the timeout is exceeded, the VM will be turned off based on the deployment policy. Specified in seconds.
	MaxOpeningTrafficDuration *float64 `json:"maxOpeningTrafficDuration,omitempty" tf:"max_opening_traffic_duration,omitempty"`

	// A description of the target group.
	TargetGroupDescription *string `json:"targetGroupDescription,omitempty" tf:"target_group_description,omitempty"`

	// A set of key/value label pairs.
	// +mapType=granular
	TargetGroupLabels map[string]*string `json:"targetGroupLabels,omitempty" tf:"target_group_labels,omitempty"`

	// The name of the target group.
	TargetGroupName *string `json:"targetGroupName,omitempty" tf:"target_group_name,omitempty"`
}

type ApplicationLoadBalancerObservation struct {

	// Do not wait load balancer health checks.
	IgnoreHealthChecks *bool `json:"ignoreHealthChecks,omitempty" tf:"ignore_health_checks,omitempty"`

	// Timeout for waiting for the VM to be checked by the load balancer. If the timeout is exceeded, the VM will be turned off based on the deployment policy. Specified in seconds.
	MaxOpeningTrafficDuration *float64 `json:"maxOpeningTrafficDuration,omitempty" tf:"max_opening_traffic_duration,omitempty"`

	// The status message of the target group.
	StatusMessage *string `json:"statusMessage,omitempty" tf:"status_message,omitempty"`

	// A description of the target group.
	TargetGroupDescription *string `json:"targetGroupDescription,omitempty" tf:"target_group_description,omitempty"`

	// The ID of the target group.
	TargetGroupID *string `json:"targetGroupId,omitempty" tf:"target_group_id,omitempty"`

	// A set of key/value label pairs.
	// +mapType=granular
	TargetGroupLabels map[string]*string `json:"targetGroupLabels,omitempty" tf:"target_group_labels,omitempty"`

	// The name of the target group.
	TargetGroupName *string `json:"targetGroupName,omitempty" tf:"target_group_name,omitempty"`
}

type ApplicationLoadBalancerParameters struct {

	// Do not wait load balancer health checks.
	// +kubebuilder:validation:Optional
	IgnoreHealthChecks *bool `json:"ignoreHealthChecks,omitempty" tf:"ignore_health_checks,omitempty"`

	// Timeout for waiting for the VM to be checked by the load balancer. If the timeout is exceeded, the VM will be turned off based on the deployment policy. Specified in seconds.
	// +kubebuilder:validation:Optional
	MaxOpeningTrafficDuration *float64 `json:"maxOpeningTrafficDuration,omitempty" tf:"max_opening_traffic_duration,omitempty"`

	// A description of the target group.
	// +kubebuilder:validation:Optional
	TargetGroupDescription *string `json:"targetGroupDescription,omitempty" tf:"target_group_description,omitempty"`

	// A set of key/value label pairs.
	// +kubebuilder:validation:Optional
	// +mapType=granular
	TargetGroupLabels map[string]*string `json:"targetGroupLabels,omitempty" tf:"target_group_labels,omitempty"`

	// The name of the target group.
	// +kubebuilder:validation:Optional
	TargetGroupName *string `json:"targetGroupName,omitempty" tf:"target_group_name,omitempty"`
}

type AutoScaleInitParameters struct {

	// Target CPU load level.
	CPUUtilizationTarget *float64 `json:"cpuUtilizationTarget,omitempty" tf:"cpu_utilization_target,omitempty"`

	// A list of custom rules. The structure is documented below.
	CustomRule []CustomRuleInitParameters `json:"customRule,omitempty" tf:"custom_rule,omitempty"`

	// The initial number of instances in the instance group.
	InitialSize *float64 `json:"initialSize,omitempty" tf:"initial_size,omitempty"`

	// The maximum number of virtual machines in the group.
	MaxSize *float64 `json:"maxSize,omitempty" tf:"max_size,omitempty"`

	// The amount of time, in seconds, that metrics are averaged for.
	// If the average value at the end of the interval is higher than the cpu_utilization_target,
	// the instance group will increase the number of virtual machines in the group.
	MeasurementDuration *float64 `json:"measurementDuration,omitempty" tf:"measurement_duration,omitempty"`

	// The minimum number of virtual machines in a single availability zone.
	MinZoneSize *float64 `json:"minZoneSize,omitempty" tf:"min_zone_size,omitempty"`

	// The minimum time interval, in seconds, to monitor the load before
	// an instance group can reduce the number of virtual machines in the group. During this time, the group
	// will not decrease even if the average load falls below the value of cpu_utilization_target.
	StabilizationDuration *float64 `json:"stabilizationDuration,omitempty" tf:"stabilization_duration,omitempty"`

	// The warm-up time of the virtual machine, in seconds. During this time,
	// traffic is fed to the virtual machine, but load metrics are not taken into account.
	WarmupDuration *float64 `json:"warmupDuration,omitempty" tf:"warmup_duration,omitempty"`
}

type AutoScaleObservation struct {

	// Target CPU load level.
	CPUUtilizationTarget *float64 `json:"cpuUtilizationTarget,omitempty" tf:"cpu_utilization_target,omitempty"`

	// A list of custom rules. The structure is documented below.
	CustomRule []CustomRuleObservation `json:"customRule,omitempty" tf:"custom_rule,omitempty"`

	// The initial number of instances in the instance group.
	InitialSize *float64 `json:"initialSize,omitempty" tf:"initial_size,omitempty"`

	// The maximum number of virtual machines in the group.
	MaxSize *float64 `json:"maxSize,omitempty" tf:"max_size,omitempty"`

	// The amount of time, in seconds, that metrics are averaged for.
	// If the average value at the end of the interval is higher than the cpu_utilization_target,
	// the instance group will increase the number of virtual machines in the group.
	MeasurementDuration *float64 `json:"measurementDuration,omitempty" tf:"measurement_duration,omitempty"`

	// The minimum number of virtual machines in a single availability zone.
	MinZoneSize *float64 `json:"minZoneSize,omitempty" tf:"min_zone_size,omitempty"`

	// The minimum time interval, in seconds, to monitor the load before
	// an instance group can reduce the number of virtual machines in the group. During this time, the group
	// will not decrease even if the average load falls below the value of cpu_utilization_target.
	StabilizationDuration *float64 `json:"stabilizationDuration,omitempty" tf:"stabilization_duration,omitempty"`

	// The warm-up time of the virtual machine, in seconds. During this time,
	// traffic is fed to the virtual machine, but load metrics are not taken into account.
	WarmupDuration *float64 `json:"warmupDuration,omitempty" tf:"warmup_duration,omitempty"`
}

type AutoScaleParameters struct {

	// Target CPU load level.
	// +kubebuilder:validation:Optional
	CPUUtilizationTarget *float64 `json:"cpuUtilizationTarget,omitempty" tf:"cpu_utilization_target,omitempty"`

	// A list of custom rules. The structure is documented below.
	// +kubebuilder:validation:Optional
	CustomRule []CustomRuleParameters `json:"customRule,omitempty" tf:"custom_rule,omitempty"`

	// The initial number of instances in the instance group.
	// +kubebuilder:validation:Optional
	InitialSize *float64 `json:"initialSize" tf:"initial_size,omitempty"`

	// The maximum number of virtual machines in the group.
	// +kubebuilder:validation:Optional
	MaxSize *float64 `json:"maxSize,omitempty" tf:"max_size,omitempty"`

	// The amount of time, in seconds, that metrics are averaged for.
	// If the average value at the end of the interval is higher than the cpu_utilization_target,
	// the instance group will increase the number of virtual machines in the group.
	// +kubebuilder:validation:Optional
	MeasurementDuration *float64 `json:"measurementDuration" tf:"measurement_duration,omitempty"`

	// The minimum number of virtual machines in a single availability zone.
	// +kubebuilder:validation:Optional
	MinZoneSize *float64 `json:"minZoneSize,omitempty" tf:"min_zone_size,omitempty"`

	// The minimum time interval, in seconds, to monitor the load before
	// an instance group can reduce the number of virtual machines in the group. During this time, the group
	// will not decrease even if the average load falls below the value of cpu_utilization_target.
	// +kubebuilder:validation:Optional
	StabilizationDuration *float64 `json:"stabilizationDuration,omitempty" tf:"stabilization_duration,omitempty"`

	// The warm-up time of the virtual machine, in seconds. During this time,
	// traffic is fed to the virtual machine, but load metrics are not taken into account.
	// +kubebuilder:validation:Optional
	WarmupDuration *float64 `json:"warmupDuration,omitempty" tf:"warmup_duration,omitempty"`
}

type BootDiskInitializeParamsInitParameters struct {

	// A description of the instance.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// The disk image to initialize this disk from.
	ImageID *string `json:"imageId,omitempty" tf:"image_id,omitempty"`

	// The size of the disk in GB.
	Size *float64 `json:"size,omitempty" tf:"size,omitempty"`

	// The snapshot to initialize this disk from.
	SnapshotID *string `json:"snapshotId,omitempty" tf:"snapshot_id,omitempty"`

	// Network acceleration type. By default a network is in STANDARD mode.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type BootDiskInitializeParamsObservation struct {

	// A description of the instance.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// The disk image to initialize this disk from.
	ImageID *string `json:"imageId,omitempty" tf:"image_id,omitempty"`

	// The size of the disk in GB.
	Size *float64 `json:"size,omitempty" tf:"size,omitempty"`

	// The snapshot to initialize this disk from.
	SnapshotID *string `json:"snapshotId,omitempty" tf:"snapshot_id,omitempty"`

	// Network acceleration type. By default a network is in STANDARD mode.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type BootDiskInitializeParamsParameters struct {

	// A description of the instance.
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// The disk image to initialize this disk from.
	// +kubebuilder:validation:Optional
	ImageID *string `json:"imageId,omitempty" tf:"image_id,omitempty"`

	// The size of the disk in GB.
	// +kubebuilder:validation:Optional
	Size *float64 `json:"size,omitempty" tf:"size,omitempty"`

	// The snapshot to initialize this disk from.
	// +kubebuilder:validation:Optional
	SnapshotID *string `json:"snapshotId,omitempty" tf:"snapshot_id,omitempty"`

	// Network acceleration type. By default a network is in STANDARD mode.
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type CustomRuleInitParameters struct {

	// The ID of the folder that the resources belong to.
	FolderID *string `json:"folderId,omitempty" tf:"folder_id,omitempty"`

	// A set of key/value label pairs to assign to the instance group.
	// +mapType=granular
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// The name of metric.
	MetricName *string `json:"metricName,omitempty" tf:"metric_name,omitempty"`

	// Metric type, GAUGE or COUNTER.
	MetricType *string `json:"metricType,omitempty" tf:"metric_type,omitempty"`

	// Rule type: UTILIZATION - This type means that the metric applies to one instance.
	// First, Instance Groups calculates the average metric value for each instance,
	// then averages the values for instances in one availability zone.
	// This type of metric must have the instance_id label. WORKLOAD - This type means that the metric applies to instances in one availability zone.
	// This type of metric must have the zone_id label.
	RuleType *string `json:"ruleType,omitempty" tf:"rule_type,omitempty"`

	// Service of custom metric in Yandex Monitoring that should be used for scaling.
	Service *string `json:"service,omitempty" tf:"service,omitempty"`

	// Target metric value level.
	Target *float64 `json:"target,omitempty" tf:"target,omitempty"`
}

type CustomRuleObservation struct {

	// The ID of the folder that the resources belong to.
	FolderID *string `json:"folderId,omitempty" tf:"folder_id,omitempty"`

	// A set of key/value label pairs to assign to the instance group.
	// +mapType=granular
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// The name of metric.
	MetricName *string `json:"metricName,omitempty" tf:"metric_name,omitempty"`

	// Metric type, GAUGE or COUNTER.
	MetricType *string `json:"metricType,omitempty" tf:"metric_type,omitempty"`

	// Rule type: UTILIZATION - This type means that the metric applies to one instance.
	// First, Instance Groups calculates the average metric value for each instance,
	// then averages the values for instances in one availability zone.
	// This type of metric must have the instance_id label. WORKLOAD - This type means that the metric applies to instances in one availability zone.
	// This type of metric must have the zone_id label.
	RuleType *string `json:"ruleType,omitempty" tf:"rule_type,omitempty"`

	// Service of custom metric in Yandex Monitoring that should be used for scaling.
	Service *string `json:"service,omitempty" tf:"service,omitempty"`

	// Target metric value level.
	Target *float64 `json:"target,omitempty" tf:"target,omitempty"`
}

type CustomRuleParameters struct {

	// The ID of the folder that the resources belong to.
	// +kubebuilder:validation:Optional
	FolderID *string `json:"folderId,omitempty" tf:"folder_id,omitempty"`

	// A set of key/value label pairs to assign to the instance group.
	// +kubebuilder:validation:Optional
	// +mapType=granular
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// The name of metric.
	// +kubebuilder:validation:Optional
	MetricName *string `json:"metricName" tf:"metric_name,omitempty"`

	// Metric type, GAUGE or COUNTER.
	// +kubebuilder:validation:Optional
	MetricType *string `json:"metricType" tf:"metric_type,omitempty"`

	// Rule type: UTILIZATION - This type means that the metric applies to one instance.
	// First, Instance Groups calculates the average metric value for each instance,
	// then averages the values for instances in one availability zone.
	// This type of metric must have the instance_id label. WORKLOAD - This type means that the metric applies to instances in one availability zone.
	// This type of metric must have the zone_id label.
	// +kubebuilder:validation:Optional
	RuleType *string `json:"ruleType" tf:"rule_type,omitempty"`

	// Service of custom metric in Yandex Monitoring that should be used for scaling.
	// +kubebuilder:validation:Optional
	Service *string `json:"service,omitempty" tf:"service,omitempty"`

	// Target metric value level.
	// +kubebuilder:validation:Optional
	Target *float64 `json:"target" tf:"target,omitempty"`
}

type DeployPolicyInitParameters struct {

	// The maximum number of instances that can be created at the same time.
	MaxCreating *float64 `json:"maxCreating,omitempty" tf:"max_creating,omitempty"`

	// The maximum number of instances that can be deleted at the same time.
	MaxDeleting *float64 `json:"maxDeleting,omitempty" tf:"max_deleting,omitempty"`

	// The maximum number of instances that can be temporarily allocated above the group's target size
	// during the update process.
	MaxExpansion *float64 `json:"maxExpansion,omitempty" tf:"max_expansion,omitempty"`

	// The maximum number of running instances that can be taken offline (stopped or deleted) at the same time
	// during the update process.
	MaxUnavailable *float64 `json:"maxUnavailable,omitempty" tf:"max_unavailable,omitempty"`

	// The amount of time in seconds to allow for an instance to start.
	// Instance will be considered up and running (and start receiving traffic) only after the startup_duration
	// has elapsed and all health checks are passed.
	StartupDuration *float64 `json:"startupDuration,omitempty" tf:"startup_duration,omitempty"`

	// Affects the lifecycle of the instance during deployment. If set to proactive (default), Instance Groups
	// can forcefully stop a running instance. If opportunistic, Instance Groups does not stop a running instance. Instead,
	// it will wait until the instance stops itself or becomes unhealthy.
	Strategy *string `json:"strategy,omitempty" tf:"strategy,omitempty"`
}

type DeployPolicyObservation struct {

	// The maximum number of instances that can be created at the same time.
	MaxCreating *float64 `json:"maxCreating,omitempty" tf:"max_creating,omitempty"`

	// The maximum number of instances that can be deleted at the same time.
	MaxDeleting *float64 `json:"maxDeleting,omitempty" tf:"max_deleting,omitempty"`

	// The maximum number of instances that can be temporarily allocated above the group's target size
	// during the update process.
	MaxExpansion *float64 `json:"maxExpansion,omitempty" tf:"max_expansion,omitempty"`

	// The maximum number of running instances that can be taken offline (stopped or deleted) at the same time
	// during the update process.
	MaxUnavailable *float64 `json:"maxUnavailable,omitempty" tf:"max_unavailable,omitempty"`

	// The amount of time in seconds to allow for an instance to start.
	// Instance will be considered up and running (and start receiving traffic) only after the startup_duration
	// has elapsed and all health checks are passed.
	StartupDuration *float64 `json:"startupDuration,omitempty" tf:"startup_duration,omitempty"`

	// Affects the lifecycle of the instance during deployment. If set to proactive (default), Instance Groups
	// can forcefully stop a running instance. If opportunistic, Instance Groups does not stop a running instance. Instead,
	// it will wait until the instance stops itself or becomes unhealthy.
	Strategy *string `json:"strategy,omitempty" tf:"strategy,omitempty"`
}

type DeployPolicyParameters struct {

	// The maximum number of instances that can be created at the same time.
	// +kubebuilder:validation:Optional
	MaxCreating *float64 `json:"maxCreating,omitempty" tf:"max_creating,omitempty"`

	// The maximum number of instances that can be deleted at the same time.
	// +kubebuilder:validation:Optional
	MaxDeleting *float64 `json:"maxDeleting,omitempty" tf:"max_deleting,omitempty"`

	// The maximum number of instances that can be temporarily allocated above the group's target size
	// during the update process.
	// +kubebuilder:validation:Optional
	MaxExpansion *float64 `json:"maxExpansion" tf:"max_expansion,omitempty"`

	// The maximum number of running instances that can be taken offline (stopped or deleted) at the same time
	// during the update process.
	// +kubebuilder:validation:Optional
	MaxUnavailable *float64 `json:"maxUnavailable" tf:"max_unavailable,omitempty"`

	// The amount of time in seconds to allow for an instance to start.
	// Instance will be considered up and running (and start receiving traffic) only after the startup_duration
	// has elapsed and all health checks are passed.
	// +kubebuilder:validation:Optional
	StartupDuration *float64 `json:"startupDuration,omitempty" tf:"startup_duration,omitempty"`

	// Affects the lifecycle of the instance during deployment. If set to proactive (default), Instance Groups
	// can forcefully stop a running instance. If opportunistic, Instance Groups does not stop a running instance. Instead,
	// it will wait until the instance stops itself or becomes unhealthy.
	// +kubebuilder:validation:Optional
	Strategy *string `json:"strategy,omitempty" tf:"strategy,omitempty"`
}

type FixedScaleInitParameters struct {

	// The size of the disk in GB.
	Size *float64 `json:"size,omitempty" tf:"size,omitempty"`
}

type FixedScaleObservation struct {

	// The size of the disk in GB.
	Size *float64 `json:"size,omitempty" tf:"size,omitempty"`
}

type FixedScaleParameters struct {

	// The size of the disk in GB.
	// +kubebuilder:validation:Optional
	Size *float64 `json:"size" tf:"size,omitempty"`
}

type HTTPOptionsInitParameters struct {

	// The URL path used for health check requests.
	Path *string `json:"path,omitempty" tf:"path,omitempty"`

	// The port used for TCP health checks.
	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`
}

type HTTPOptionsObservation struct {

	// The URL path used for health check requests.
	Path *string `json:"path,omitempty" tf:"path,omitempty"`

	// The port used for TCP health checks.
	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`
}

type HTTPOptionsParameters struct {

	// The URL path used for health check requests.
	// +kubebuilder:validation:Optional
	Path *string `json:"path" tf:"path,omitempty"`

	// The port used for TCP health checks.
	// +kubebuilder:validation:Optional
	Port *float64 `json:"port" tf:"port,omitempty"`
}

type HealthCheckInitParameters struct {

	// HTTP check options. The structure is documented below.
	HTTPOptions []HTTPOptionsInitParameters `json:"httpOptions,omitempty" tf:"http_options,omitempty"`

	// The number of successful health checks before the managed instance is declared healthy.
	HealthyThreshold *float64 `json:"healthyThreshold,omitempty" tf:"healthy_threshold,omitempty"`

	// The interval to wait between health checks in seconds.
	Interval *float64 `json:"interval,omitempty" tf:"interval,omitempty"`

	// TCP check options. The structure is documented below.
	TCPOptions []TCPOptionsInitParameters `json:"tcpOptions,omitempty" tf:"tcp_options,omitempty"`

	// The length of time to wait for a response before the health check times out in seconds.
	Timeout *float64 `json:"timeout,omitempty" tf:"timeout,omitempty"`

	// The number of failed health checks before the managed instance is declared unhealthy.
	UnhealthyThreshold *float64 `json:"unhealthyThreshold,omitempty" tf:"unhealthy_threshold,omitempty"`
}

type HealthCheckObservation struct {

	// HTTP check options. The structure is documented below.
	HTTPOptions []HTTPOptionsObservation `json:"httpOptions,omitempty" tf:"http_options,omitempty"`

	// The number of successful health checks before the managed instance is declared healthy.
	HealthyThreshold *float64 `json:"healthyThreshold,omitempty" tf:"healthy_threshold,omitempty"`

	// The interval to wait between health checks in seconds.
	Interval *float64 `json:"interval,omitempty" tf:"interval,omitempty"`

	// TCP check options. The structure is documented below.
	TCPOptions []TCPOptionsObservation `json:"tcpOptions,omitempty" tf:"tcp_options,omitempty"`

	// The length of time to wait for a response before the health check times out in seconds.
	Timeout *float64 `json:"timeout,omitempty" tf:"timeout,omitempty"`

	// The number of failed health checks before the managed instance is declared unhealthy.
	UnhealthyThreshold *float64 `json:"unhealthyThreshold,omitempty" tf:"unhealthy_threshold,omitempty"`
}

type HealthCheckParameters struct {

	// HTTP check options. The structure is documented below.
	// +kubebuilder:validation:Optional
	HTTPOptions []HTTPOptionsParameters `json:"httpOptions,omitempty" tf:"http_options,omitempty"`

	// The number of successful health checks before the managed instance is declared healthy.
	// +kubebuilder:validation:Optional
	HealthyThreshold *float64 `json:"healthyThreshold,omitempty" tf:"healthy_threshold,omitempty"`

	// The interval to wait between health checks in seconds.
	// +kubebuilder:validation:Optional
	Interval *float64 `json:"interval,omitempty" tf:"interval,omitempty"`

	// TCP check options. The structure is documented below.
	// +kubebuilder:validation:Optional
	TCPOptions []TCPOptionsParameters `json:"tcpOptions,omitempty" tf:"tcp_options,omitempty"`

	// The length of time to wait for a response before the health check times out in seconds.
	// +kubebuilder:validation:Optional
	Timeout *float64 `json:"timeout,omitempty" tf:"timeout,omitempty"`

	// The number of failed health checks before the managed instance is declared unhealthy.
	// +kubebuilder:validation:Optional
	UnhealthyThreshold *float64 `json:"unhealthyThreshold,omitempty" tf:"unhealthy_threshold,omitempty"`
}

type InstanceGroupInitParameters struct {

	// The allocation policy of the instance group by zone and region. The structure is documented below.
	AllocationPolicy []AllocationPolicyInitParameters `json:"allocationPolicy,omitempty" tf:"allocation_policy,omitempty"`

	// Application Load balancing (L7) specifications. The structure is documented below.
	ApplicationLoadBalancer []ApplicationLoadBalancerInitParameters `json:"applicationLoadBalancer,omitempty" tf:"application_load_balancer,omitempty"`

	// Flag that protects the instance group from accidental deletion.
	DeletionProtection *bool `json:"deletionProtection,omitempty" tf:"deletion_protection,omitempty"`

	// The deployment policy of the instance group. The structure is documented below.
	DeployPolicy []DeployPolicyInitParameters `json:"deployPolicy,omitempty" tf:"deploy_policy,omitempty"`

	// A description of the instance group.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// The ID of the folder that the resources belong to.
	// +crossplane:generate:reference:type=github.com/yandex-cloud/crossplane-provider-yc/apis/resourcemanager/v1alpha1.Folder
	FolderID *string `json:"folderId,omitempty" tf:"folder_id,omitempty"`

	// Reference to a Folder in resourcemanager to populate folderId.
	// +kubebuilder:validation:Optional
	FolderIDRef *v1.Reference `json:"folderIdRef,omitempty" tf:"-"`

	// Selector for a Folder in resourcemanager to populate folderId.
	// +kubebuilder:validation:Optional
	FolderIDSelector *v1.Selector `json:"folderIdSelector,omitempty" tf:"-"`

	// Health check specifications. The structure is documented below.
	HealthCheck []HealthCheckInitParameters `json:"healthCheck,omitempty" tf:"health_check,omitempty"`

	// The template for creating new instances. The structure is documented below.
	InstanceTemplate []InstanceTemplateInitParameters `json:"instanceTemplate,omitempty" tf:"instance_template,omitempty"`

	// A set of key/value label pairs to assign to the instance group.
	// +mapType=granular
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// Load balancing specifications. The structure is documented below.
	LoadBalancer []LoadBalancerInitParameters `json:"loadBalancer,omitempty" tf:"load_balancer,omitempty"`

	// Timeout for waiting for the VM to become healthy. If the timeout is exceeded, the VM will be turned off based on the deployment policy. Specified in seconds.
	MaxCheckingHealthDuration *float64 `json:"maxCheckingHealthDuration,omitempty" tf:"max_checking_health_duration,omitempty"`

	// The name of the instance group.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The scaling policy of the instance group. The structure is documented below.
	ScalePolicy []ScalePolicyInitParameters `json:"scalePolicy,omitempty" tf:"scale_policy,omitempty"`

	// The ID of the service account authorized for this instance group.
	// +crossplane:generate:reference:type=github.com/yandex-cloud/crossplane-provider-yc/apis/iam/v1alpha1.ServiceAccount
	ServiceAccountID *string `json:"serviceAccountId,omitempty" tf:"service_account_id,omitempty"`

	// Reference to a ServiceAccount in iam to populate serviceAccountId.
	// +kubebuilder:validation:Optional
	ServiceAccountIDRef *v1.Reference `json:"serviceAccountIdRef,omitempty" tf:"-"`

	// Selector for a ServiceAccount in iam to populate serviceAccountId.
	// +kubebuilder:validation:Optional
	ServiceAccountIDSelector *v1.Selector `json:"serviceAccountIdSelector,omitempty" tf:"-"`

	// A set of key/value  variables pairs to assign to the instance group.
	// +mapType=granular
	Variables map[string]*string `json:"variables,omitempty" tf:"variables,omitempty"`
}

type InstanceGroupObservation struct {

	// The allocation policy of the instance group by zone and region. The structure is documented below.
	AllocationPolicy []AllocationPolicyObservation `json:"allocationPolicy,omitempty" tf:"allocation_policy,omitempty"`

	// Application Load balancing (L7) specifications. The structure is documented below.
	ApplicationLoadBalancer []ApplicationLoadBalancerObservation `json:"applicationLoadBalancer,omitempty" tf:"application_load_balancer,omitempty"`

	// The instance group creation timestamp.
	CreatedAt *string `json:"createdAt,omitempty" tf:"created_at,omitempty"`

	// Flag that protects the instance group from accidental deletion.
	DeletionProtection *bool `json:"deletionProtection,omitempty" tf:"deletion_protection,omitempty"`

	// The deployment policy of the instance group. The structure is documented below.
	DeployPolicy []DeployPolicyObservation `json:"deployPolicy,omitempty" tf:"deploy_policy,omitempty"`

	// A description of the instance group.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// The ID of the folder that the resources belong to.
	FolderID *string `json:"folderId,omitempty" tf:"folder_id,omitempty"`

	// Health check specifications. The structure is documented below.
	HealthCheck []HealthCheckObservation `json:"healthCheck,omitempty" tf:"health_check,omitempty"`

	// The ID of the instance group.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// The template for creating new instances. The structure is documented below.
	InstanceTemplate []InstanceTemplateObservation `json:"instanceTemplate,omitempty" tf:"instance_template,omitempty"`

	Instances []InstancesObservation `json:"instances,omitempty" tf:"instances,omitempty"`

	// A set of key/value label pairs to assign to the instance group.
	// +mapType=granular
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// Load balancing specifications. The structure is documented below.
	LoadBalancer []LoadBalancerObservation `json:"loadBalancer,omitempty" tf:"load_balancer,omitempty"`

	// Timeout for waiting for the VM to become healthy. If the timeout is exceeded, the VM will be turned off based on the deployment policy. Specified in seconds.
	MaxCheckingHealthDuration *float64 `json:"maxCheckingHealthDuration,omitempty" tf:"max_checking_health_duration,omitempty"`

	// The name of the instance group.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The scaling policy of the instance group. The structure is documented below.
	ScalePolicy []ScalePolicyObservation `json:"scalePolicy,omitempty" tf:"scale_policy,omitempty"`

	// The ID of the service account authorized for this instance group.
	ServiceAccountID *string `json:"serviceAccountId,omitempty" tf:"service_account_id,omitempty"`

	// The status of the instance.
	Status *string `json:"status,omitempty" tf:"status,omitempty"`

	// A set of key/value  variables pairs to assign to the instance group.
	// +mapType=granular
	Variables map[string]*string `json:"variables,omitempty" tf:"variables,omitempty"`
}

type InstanceGroupParameters struct {

	// The allocation policy of the instance group by zone and region. The structure is documented below.
	// +kubebuilder:validation:Optional
	AllocationPolicy []AllocationPolicyParameters `json:"allocationPolicy,omitempty" tf:"allocation_policy,omitempty"`

	// Application Load balancing (L7) specifications. The structure is documented below.
	// +kubebuilder:validation:Optional
	ApplicationLoadBalancer []ApplicationLoadBalancerParameters `json:"applicationLoadBalancer,omitempty" tf:"application_load_balancer,omitempty"`

	// Flag that protects the instance group from accidental deletion.
	// +kubebuilder:validation:Optional
	DeletionProtection *bool `json:"deletionProtection,omitempty" tf:"deletion_protection,omitempty"`

	// The deployment policy of the instance group. The structure is documented below.
	// +kubebuilder:validation:Optional
	DeployPolicy []DeployPolicyParameters `json:"deployPolicy,omitempty" tf:"deploy_policy,omitempty"`

	// A description of the instance group.
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// The ID of the folder that the resources belong to.
	// +crossplane:generate:reference:type=github.com/yandex-cloud/crossplane-provider-yc/apis/resourcemanager/v1alpha1.Folder
	// +kubebuilder:validation:Optional
	FolderID *string `json:"folderId,omitempty" tf:"folder_id,omitempty"`

	// Reference to a Folder in resourcemanager to populate folderId.
	// +kubebuilder:validation:Optional
	FolderIDRef *v1.Reference `json:"folderIdRef,omitempty" tf:"-"`

	// Selector for a Folder in resourcemanager to populate folderId.
	// +kubebuilder:validation:Optional
	FolderIDSelector *v1.Selector `json:"folderIdSelector,omitempty" tf:"-"`

	// Health check specifications. The structure is documented below.
	// +kubebuilder:validation:Optional
	HealthCheck []HealthCheckParameters `json:"healthCheck,omitempty" tf:"health_check,omitempty"`

	// The template for creating new instances. The structure is documented below.
	// +kubebuilder:validation:Optional
	InstanceTemplate []InstanceTemplateParameters `json:"instanceTemplate,omitempty" tf:"instance_template,omitempty"`

	// A set of key/value label pairs to assign to the instance group.
	// +kubebuilder:validation:Optional
	// +mapType=granular
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// Load balancing specifications. The structure is documented below.
	// +kubebuilder:validation:Optional
	LoadBalancer []LoadBalancerParameters `json:"loadBalancer,omitempty" tf:"load_balancer,omitempty"`

	// Timeout for waiting for the VM to become healthy. If the timeout is exceeded, the VM will be turned off based on the deployment policy. Specified in seconds.
	// +kubebuilder:validation:Optional
	MaxCheckingHealthDuration *float64 `json:"maxCheckingHealthDuration,omitempty" tf:"max_checking_health_duration,omitempty"`

	// The name of the instance group.
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The scaling policy of the instance group. The structure is documented below.
	// +kubebuilder:validation:Optional
	ScalePolicy []ScalePolicyParameters `json:"scalePolicy,omitempty" tf:"scale_policy,omitempty"`

	// The ID of the service account authorized for this instance group.
	// +crossplane:generate:reference:type=github.com/yandex-cloud/crossplane-provider-yc/apis/iam/v1alpha1.ServiceAccount
	// +kubebuilder:validation:Optional
	ServiceAccountID *string `json:"serviceAccountId,omitempty" tf:"service_account_id,omitempty"`

	// Reference to a ServiceAccount in iam to populate serviceAccountId.
	// +kubebuilder:validation:Optional
	ServiceAccountIDRef *v1.Reference `json:"serviceAccountIdRef,omitempty" tf:"-"`

	// Selector for a ServiceAccount in iam to populate serviceAccountId.
	// +kubebuilder:validation:Optional
	ServiceAccountIDSelector *v1.Selector `json:"serviceAccountIdSelector,omitempty" tf:"-"`

	// A set of key/value  variables pairs to assign to the instance group.
	// +kubebuilder:validation:Optional
	// +mapType=granular
	Variables map[string]*string `json:"variables,omitempty" tf:"variables,omitempty"`
}

type InstanceTagsPoolInitParameters struct {

	// List of tags for instances in zone.
	Tags []*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// Availability zone.
	Zone *string `json:"zone,omitempty" tf:"zone,omitempty"`
}

type InstanceTagsPoolObservation struct {

	// List of tags for instances in zone.
	Tags []*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// Availability zone.
	Zone *string `json:"zone,omitempty" tf:"zone,omitempty"`
}

type InstanceTagsPoolParameters struct {

	// List of tags for instances in zone.
	// +kubebuilder:validation:Optional
	Tags []*string `json:"tags" tf:"tags,omitempty"`

	// Availability zone.
	// +kubebuilder:validation:Optional
	Zone *string `json:"zone" tf:"zone,omitempty"`
}

type InstanceTemplateBootDiskInitParameters struct {

	// This value can be used to reference the device under /dev/disk/by-id/.
	DeviceName *string `json:"deviceName,omitempty" tf:"device_name,omitempty"`

	// ID of the existing disk. To set use variables.
	// +crossplane:generate:reference:type=github.com/yandex-cloud/crossplane-provider-yc/apis/compute/v1alpha1.Disk
	DiskID *string `json:"diskId,omitempty" tf:"disk_id,omitempty"`

	// Reference to a Disk in compute to populate diskId.
	// +kubebuilder:validation:Optional
	DiskIDRef *v1.Reference `json:"diskIdRef,omitempty" tf:"-"`

	// Selector for a Disk in compute to populate diskId.
	// +kubebuilder:validation:Optional
	DiskIDSelector *v1.Selector `json:"diskIdSelector,omitempty" tf:"-"`

	// Parameters used for creating a disk alongside the instance. The structure is documented below.
	InitializeParams []BootDiskInitializeParamsInitParameters `json:"initializeParams,omitempty" tf:"initialize_params,omitempty"`

	// The access mode to the disk resource. By default a disk is attached in READ_WRITE mode.
	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`

	// When set can be later used to change DiskSpec of actual disk.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type InstanceTemplateBootDiskObservation struct {

	// This value can be used to reference the device under /dev/disk/by-id/.
	DeviceName *string `json:"deviceName,omitempty" tf:"device_name,omitempty"`

	// ID of the existing disk. To set use variables.
	DiskID *string `json:"diskId,omitempty" tf:"disk_id,omitempty"`

	// Parameters used for creating a disk alongside the instance. The structure is documented below.
	InitializeParams []BootDiskInitializeParamsObservation `json:"initializeParams,omitempty" tf:"initialize_params,omitempty"`

	// The access mode to the disk resource. By default a disk is attached in READ_WRITE mode.
	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`

	// When set can be later used to change DiskSpec of actual disk.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type InstanceTemplateBootDiskParameters struct {

	// This value can be used to reference the device under /dev/disk/by-id/.
	// +kubebuilder:validation:Optional
	DeviceName *string `json:"deviceName,omitempty" tf:"device_name,omitempty"`

	// ID of the existing disk. To set use variables.
	// +crossplane:generate:reference:type=github.com/yandex-cloud/crossplane-provider-yc/apis/compute/v1alpha1.Disk
	// +kubebuilder:validation:Optional
	DiskID *string `json:"diskId,omitempty" tf:"disk_id,omitempty"`

	// Reference to a Disk in compute to populate diskId.
	// +kubebuilder:validation:Optional
	DiskIDRef *v1.Reference `json:"diskIdRef,omitempty" tf:"-"`

	// Selector for a Disk in compute to populate diskId.
	// +kubebuilder:validation:Optional
	DiskIDSelector *v1.Selector `json:"diskIdSelector,omitempty" tf:"-"`

	// Parameters used for creating a disk alongside the instance. The structure is documented below.
	// +kubebuilder:validation:Optional
	InitializeParams []BootDiskInitializeParamsParameters `json:"initializeParams,omitempty" tf:"initialize_params,omitempty"`

	// The access mode to the disk resource. By default a disk is attached in READ_WRITE mode.
	// +kubebuilder:validation:Optional
	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`

	// When set can be later used to change DiskSpec of actual disk.
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type InstanceTemplateFilesystemInitParameters struct {

	// This value can be used to reference the device under /dev/disk/by-id/.
	DeviceName *string `json:"deviceName,omitempty" tf:"device_name,omitempty"`

	// ID of the filesystem that should be attached.
	// +crossplane:generate:reference:type=github.com/yandex-cloud/crossplane-provider-yc/apis/compute/v1alpha1.Filesystem
	FilesystemID *string `json:"filesystemId,omitempty" tf:"filesystem_id,omitempty"`

	// Reference to a Filesystem in compute to populate filesystemId.
	// +kubebuilder:validation:Optional
	FilesystemIDRef *v1.Reference `json:"filesystemIdRef,omitempty" tf:"-"`

	// Selector for a Filesystem in compute to populate filesystemId.
	// +kubebuilder:validation:Optional
	FilesystemIDSelector *v1.Selector `json:"filesystemIdSelector,omitempty" tf:"-"`

	// The access mode to the disk resource. By default a disk is attached in READ_WRITE mode.
	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`
}

type InstanceTemplateFilesystemObservation struct {

	// This value can be used to reference the device under /dev/disk/by-id/.
	DeviceName *string `json:"deviceName,omitempty" tf:"device_name,omitempty"`

	// ID of the filesystem that should be attached.
	FilesystemID *string `json:"filesystemId,omitempty" tf:"filesystem_id,omitempty"`

	// The access mode to the disk resource. By default a disk is attached in READ_WRITE mode.
	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`
}

type InstanceTemplateFilesystemParameters struct {

	// This value can be used to reference the device under /dev/disk/by-id/.
	// +kubebuilder:validation:Optional
	DeviceName *string `json:"deviceName,omitempty" tf:"device_name,omitempty"`

	// ID of the filesystem that should be attached.
	// +crossplane:generate:reference:type=github.com/yandex-cloud/crossplane-provider-yc/apis/compute/v1alpha1.Filesystem
	// +kubebuilder:validation:Optional
	FilesystemID *string `json:"filesystemId,omitempty" tf:"filesystem_id,omitempty"`

	// Reference to a Filesystem in compute to populate filesystemId.
	// +kubebuilder:validation:Optional
	FilesystemIDRef *v1.Reference `json:"filesystemIdRef,omitempty" tf:"-"`

	// Selector for a Filesystem in compute to populate filesystemId.
	// +kubebuilder:validation:Optional
	FilesystemIDSelector *v1.Selector `json:"filesystemIdSelector,omitempty" tf:"-"`

	// The access mode to the disk resource. By default a disk is attached in READ_WRITE mode.
	// +kubebuilder:validation:Optional
	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`
}

type InstanceTemplateInitParameters struct {

	// Boot disk specifications for the instance. The structure is documented below.
	BootDisk []InstanceTemplateBootDiskInitParameters `json:"bootDisk,omitempty" tf:"boot_disk,omitempty"`

	// A description of the instance.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// List of filesystems to attach to the instance. The structure is documented below.
	Filesystem []InstanceTemplateFilesystemInitParameters `json:"filesystem,omitempty" tf:"filesystem,omitempty"`

	// Hostname template for the instance.
	// This field is used to generate the FQDN value of instance.
	// The hostname must be unique within the network and region.
	// If not specified, the hostname will be equal to id of the instance
	// and FQDN will be <id>.auto.internal. Otherwise FQDN will be <hostname>.<region_id>.internal.
	// In order to be unique it must contain at least on of instance unique placeholders:
	// {instance.short_id}
	// {instance.index}
	// combination of {instance.zone_id} and {instance.index_in_zone}
	// Example: my-instance-{instance.index}
	// If not set, name value will be used
	// It may also contain another placeholders, see metadata doc for full list.
	Hostname *string `json:"hostname,omitempty" tf:"hostname,omitempty"`

	// A set of key/value label pairs to assign to the instance.
	// +mapType=granular
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// A set of metadata key/value pairs to make available from within the instance.
	// +mapType=granular
	Metadata map[string]*string `json:"metadata,omitempty" tf:"metadata,omitempty"`

	// Options allow user to configure access to managed instances metadata
	MetadataOptions []InstanceTemplateMetadataOptionsInitParameters `json:"metadataOptions,omitempty" tf:"metadata_options,omitempty"`

	// Name template of the instance.
	// In order to be unique it must contain at least one of instance unique placeholders:
	// {instance.short_id}
	// {instance.index}
	// combination of {instance.zone_id} and {instance.index_in_zone}
	// Example: my-instance-{instance.index}
	// If not set, default is used: {instance_group.id}-{instance.short_id}
	// It may also contain another placeholders, see metadata doc for full list.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Network specifications for the instance. This can be used multiple times for adding multiple interfaces. The structure is documented below.
	NetworkInterface []InstanceTemplateNetworkInterfaceInitParameters `json:"networkInterface,omitempty" tf:"network_interface,omitempty"`

	// Network acceleration type for instance. The structure is documented below.
	NetworkSettings []NetworkSettingsInitParameters `json:"networkSettings,omitempty" tf:"network_settings,omitempty"`

	// The placement policy configuration. The structure is documented below.
	PlacementPolicy []InstanceTemplatePlacementPolicyInitParameters `json:"placementPolicy,omitempty" tf:"placement_policy,omitempty"`

	// The ID of the hardware platform configuration for the instance. The default is 'standard-v1'.
	PlatformID *string `json:"platformId,omitempty" tf:"platform_id,omitempty"`

	// Compute resource specifications for the instance. The structure is documented below.
	Resources []InstanceTemplateResourcesInitParameters `json:"resources,omitempty" tf:"resources,omitempty"`

	// The scheduling policy configuration. The structure is documented below.
	SchedulingPolicy []InstanceTemplateSchedulingPolicyInitParameters `json:"schedulingPolicy,omitempty" tf:"scheduling_policy,omitempty"`

	// A list of disks to attach to the instance. The structure is documented below.
	SecondaryDisk []InstanceTemplateSecondaryDiskInitParameters `json:"secondaryDisk,omitempty" tf:"secondary_disk,omitempty"`

	// The ID of the service account authorized for this instance.
	ServiceAccountID *string `json:"serviceAccountId,omitempty" tf:"service_account_id,omitempty"`
}

type InstanceTemplateMetadataOptionsInitParameters struct {
	AwsV1HTTPEndpoint *float64 `json:"awsV1HttpEndpoint,omitempty" tf:"aws_v1_http_endpoint,omitempty"`

	AwsV1HTTPToken *float64 `json:"awsV1HttpToken,omitempty" tf:"aws_v1_http_token,omitempty"`

	GceHTTPEndpoint *float64 `json:"gceHttpEndpoint,omitempty" tf:"gce_http_endpoint,omitempty"`

	GceHTTPToken *float64 `json:"gceHttpToken,omitempty" tf:"gce_http_token,omitempty"`
}

type InstanceTemplateMetadataOptionsObservation struct {
	AwsV1HTTPEndpoint *float64 `json:"awsV1HttpEndpoint,omitempty" tf:"aws_v1_http_endpoint,omitempty"`

	AwsV1HTTPToken *float64 `json:"awsV1HttpToken,omitempty" tf:"aws_v1_http_token,omitempty"`

	GceHTTPEndpoint *float64 `json:"gceHttpEndpoint,omitempty" tf:"gce_http_endpoint,omitempty"`

	GceHTTPToken *float64 `json:"gceHttpToken,omitempty" tf:"gce_http_token,omitempty"`
}

type InstanceTemplateMetadataOptionsParameters struct {

	// +kubebuilder:validation:Optional
	AwsV1HTTPEndpoint *float64 `json:"awsV1HttpEndpoint,omitempty" tf:"aws_v1_http_endpoint,omitempty"`

	// +kubebuilder:validation:Optional
	AwsV1HTTPToken *float64 `json:"awsV1HttpToken,omitempty" tf:"aws_v1_http_token,omitempty"`

	// +kubebuilder:validation:Optional
	GceHTTPEndpoint *float64 `json:"gceHttpEndpoint,omitempty" tf:"gce_http_endpoint,omitempty"`

	// +kubebuilder:validation:Optional
	GceHTTPToken *float64 `json:"gceHttpToken,omitempty" tf:"gce_http_token,omitempty"`
}

type InstanceTemplateNetworkInterfaceInitParameters struct {

	// List of dns records.  The structure is documented below.
	DNSRecord []NetworkInterfaceDNSRecordInitParameters `json:"dnsRecord,omitempty" tf:"dns_record,omitempty"`

	// Manual set static IP address.
	IPAddress *string `json:"ipAddress,omitempty" tf:"ip_address,omitempty"`

	// True if IPv4 address allocated for the network interface.
	IPv4 *bool `json:"ipv4,omitempty" tf:"ipv4,omitempty"`

	IPv6 *bool `json:"ipv6,omitempty" tf:"ipv6,omitempty"`

	// Manual set static IPv6 address.
	IPv6Address *string `json:"ipv6Address,omitempty" tf:"ipv6_address,omitempty"`

	// List of ipv6 dns records.  The structure is documented below.
	IPv6DNSRecord []NetworkInterfaceIPv6DNSRecordInitParameters `json:"ipv6DnsRecord,omitempty" tf:"ipv6_dns_record,omitempty"`

	// Flag for using NAT.
	NAT *bool `json:"nat,omitempty" tf:"nat,omitempty"`

	// List of nat dns records.  The structure is documented below.
	NATDNSRecord []NetworkInterfaceNATDNSRecordInitParameters `json:"natDnsRecord,omitempty" tf:"nat_dns_record,omitempty"`

	// A public address that can be used to access the internet over NAT. Use variables to set.
	NATIPAddress *string `json:"natIpAddress,omitempty" tf:"nat_ip_address,omitempty"`

	// The ID of the network.
	// +crossplane:generate:reference:type=github.com/yandex-cloud/crossplane-provider-yc/apis/vpc/v1alpha1.Network
	NetworkID *string `json:"networkId,omitempty" tf:"network_id,omitempty"`

	// Reference to a Network in vpc to populate networkId.
	// +kubebuilder:validation:Optional
	NetworkIDRef *v1.Reference `json:"networkIdRef,omitempty" tf:"-"`

	// Selector for a Network in vpc to populate networkId.
	// +kubebuilder:validation:Optional
	NetworkIDSelector *v1.Selector `json:"networkIdSelector,omitempty" tf:"-"`

	// Security group ids for network interface.
	// +crossplane:generate:reference:type=github.com/yandex-cloud/crossplane-provider-yc/apis/vpc/v1alpha1.SecurityGroup
	// +listType=set
	SecurityGroupIds []*string `json:"securityGroupIds,omitempty" tf:"security_group_ids,omitempty"`

	// References to SecurityGroup in vpc to populate securityGroupIds.
	// +kubebuilder:validation:Optional
	SecurityGroupIdsRefs []v1.Reference `json:"securityGroupIdsRefs,omitempty" tf:"-"`

	// Selector for a list of SecurityGroup in vpc to populate securityGroupIds.
	// +kubebuilder:validation:Optional
	SecurityGroupIdsSelector *v1.Selector `json:"securityGroupIdsSelector,omitempty" tf:"-"`

	// The ID of the subnets to attach this interface to.
	// +crossplane:generate:reference:type=github.com/yandex-cloud/crossplane-provider-yc/apis/vpc/v1alpha1.Subnet
	// +listType=set
	SubnetIds []*string `json:"subnetIds,omitempty" tf:"subnet_ids,omitempty"`

	// References to Subnet in vpc to populate subnetIds.
	// +kubebuilder:validation:Optional
	SubnetIdsRefs []v1.Reference `json:"subnetIdsRefs,omitempty" tf:"-"`

	// Selector for a list of Subnet in vpc to populate subnetIds.
	// +kubebuilder:validation:Optional
	SubnetIdsSelector *v1.Selector `json:"subnetIdsSelector,omitempty" tf:"-"`
}

type InstanceTemplateNetworkInterfaceObservation struct {

	// List of dns records.  The structure is documented below.
	DNSRecord []NetworkInterfaceDNSRecordObservation `json:"dnsRecord,omitempty" tf:"dns_record,omitempty"`

	// Manual set static IP address.
	IPAddress *string `json:"ipAddress,omitempty" tf:"ip_address,omitempty"`

	// True if IPv4 address allocated for the network interface.
	IPv4 *bool `json:"ipv4,omitempty" tf:"ipv4,omitempty"`

	IPv6 *bool `json:"ipv6,omitempty" tf:"ipv6,omitempty"`

	// Manual set static IPv6 address.
	IPv6Address *string `json:"ipv6Address,omitempty" tf:"ipv6_address,omitempty"`

	// List of ipv6 dns records.  The structure is documented below.
	IPv6DNSRecord []NetworkInterfaceIPv6DNSRecordObservation `json:"ipv6DnsRecord,omitempty" tf:"ipv6_dns_record,omitempty"`

	// Flag for using NAT.
	NAT *bool `json:"nat,omitempty" tf:"nat,omitempty"`

	// List of nat dns records.  The structure is documented below.
	NATDNSRecord []NetworkInterfaceNATDNSRecordObservation `json:"natDnsRecord,omitempty" tf:"nat_dns_record,omitempty"`

	// A public address that can be used to access the internet over NAT. Use variables to set.
	NATIPAddress *string `json:"natIpAddress,omitempty" tf:"nat_ip_address,omitempty"`

	// The ID of the network.
	NetworkID *string `json:"networkId,omitempty" tf:"network_id,omitempty"`

	// Security group ids for network interface.
	// +listType=set
	SecurityGroupIds []*string `json:"securityGroupIds,omitempty" tf:"security_group_ids,omitempty"`

	// The ID of the subnets to attach this interface to.
	// +listType=set
	SubnetIds []*string `json:"subnetIds,omitempty" tf:"subnet_ids,omitempty"`
}

type InstanceTemplateNetworkInterfaceParameters struct {

	// List of dns records.  The structure is documented below.
	// +kubebuilder:validation:Optional
	DNSRecord []NetworkInterfaceDNSRecordParameters `json:"dnsRecord,omitempty" tf:"dns_record,omitempty"`

	// Manual set static IP address.
	// +kubebuilder:validation:Optional
	IPAddress *string `json:"ipAddress,omitempty" tf:"ip_address,omitempty"`

	// True if IPv4 address allocated for the network interface.
	// +kubebuilder:validation:Optional
	IPv4 *bool `json:"ipv4,omitempty" tf:"ipv4,omitempty"`

	// +kubebuilder:validation:Optional
	IPv6 *bool `json:"ipv6,omitempty" tf:"ipv6,omitempty"`

	// Manual set static IPv6 address.
	// +kubebuilder:validation:Optional
	IPv6Address *string `json:"ipv6Address,omitempty" tf:"ipv6_address,omitempty"`

	// List of ipv6 dns records.  The structure is documented below.
	// +kubebuilder:validation:Optional
	IPv6DNSRecord []NetworkInterfaceIPv6DNSRecordParameters `json:"ipv6DnsRecord,omitempty" tf:"ipv6_dns_record,omitempty"`

	// Flag for using NAT.
	// +kubebuilder:validation:Optional
	NAT *bool `json:"nat,omitempty" tf:"nat,omitempty"`

	// List of nat dns records.  The structure is documented below.
	// +kubebuilder:validation:Optional
	NATDNSRecord []NetworkInterfaceNATDNSRecordParameters `json:"natDnsRecord,omitempty" tf:"nat_dns_record,omitempty"`

	// A public address that can be used to access the internet over NAT. Use variables to set.
	// +kubebuilder:validation:Optional
	NATIPAddress *string `json:"natIpAddress,omitempty" tf:"nat_ip_address,omitempty"`

	// The ID of the network.
	// +crossplane:generate:reference:type=github.com/yandex-cloud/crossplane-provider-yc/apis/vpc/v1alpha1.Network
	// +kubebuilder:validation:Optional
	NetworkID *string `json:"networkId,omitempty" tf:"network_id,omitempty"`

	// Reference to a Network in vpc to populate networkId.
	// +kubebuilder:validation:Optional
	NetworkIDRef *v1.Reference `json:"networkIdRef,omitempty" tf:"-"`

	// Selector for a Network in vpc to populate networkId.
	// +kubebuilder:validation:Optional
	NetworkIDSelector *v1.Selector `json:"networkIdSelector,omitempty" tf:"-"`

	// Security group ids for network interface.
	// +crossplane:generate:reference:type=github.com/yandex-cloud/crossplane-provider-yc/apis/vpc/v1alpha1.SecurityGroup
	// +kubebuilder:validation:Optional
	// +listType=set
	SecurityGroupIds []*string `json:"securityGroupIds,omitempty" tf:"security_group_ids,omitempty"`

	// References to SecurityGroup in vpc to populate securityGroupIds.
	// +kubebuilder:validation:Optional
	SecurityGroupIdsRefs []v1.Reference `json:"securityGroupIdsRefs,omitempty" tf:"-"`

	// Selector for a list of SecurityGroup in vpc to populate securityGroupIds.
	// +kubebuilder:validation:Optional
	SecurityGroupIdsSelector *v1.Selector `json:"securityGroupIdsSelector,omitempty" tf:"-"`

	// The ID of the subnets to attach this interface to.
	// +crossplane:generate:reference:type=github.com/yandex-cloud/crossplane-provider-yc/apis/vpc/v1alpha1.Subnet
	// +kubebuilder:validation:Optional
	// +listType=set
	SubnetIds []*string `json:"subnetIds,omitempty" tf:"subnet_ids,omitempty"`

	// References to Subnet in vpc to populate subnetIds.
	// +kubebuilder:validation:Optional
	SubnetIdsRefs []v1.Reference `json:"subnetIdsRefs,omitempty" tf:"-"`

	// Selector for a list of Subnet in vpc to populate subnetIds.
	// +kubebuilder:validation:Optional
	SubnetIdsSelector *v1.Selector `json:"subnetIdsSelector,omitempty" tf:"-"`
}

type InstanceTemplateObservation struct {

	// Boot disk specifications for the instance. The structure is documented below.
	BootDisk []InstanceTemplateBootDiskObservation `json:"bootDisk,omitempty" tf:"boot_disk,omitempty"`

	// A description of the instance.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// List of filesystems to attach to the instance. The structure is documented below.
	Filesystem []InstanceTemplateFilesystemObservation `json:"filesystem,omitempty" tf:"filesystem,omitempty"`

	// Hostname template for the instance.
	// This field is used to generate the FQDN value of instance.
	// The hostname must be unique within the network and region.
	// If not specified, the hostname will be equal to id of the instance
	// and FQDN will be <id>.auto.internal. Otherwise FQDN will be <hostname>.<region_id>.internal.
	// In order to be unique it must contain at least on of instance unique placeholders:
	// {instance.short_id}
	// {instance.index}
	// combination of {instance.zone_id} and {instance.index_in_zone}
	// Example: my-instance-{instance.index}
	// If not set, name value will be used
	// It may also contain another placeholders, see metadata doc for full list.
	Hostname *string `json:"hostname,omitempty" tf:"hostname,omitempty"`

	// A set of key/value label pairs to assign to the instance.
	// +mapType=granular
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// A set of metadata key/value pairs to make available from within the instance.
	// +mapType=granular
	Metadata map[string]*string `json:"metadata,omitempty" tf:"metadata,omitempty"`

	// Options allow user to configure access to managed instances metadata
	MetadataOptions []InstanceTemplateMetadataOptionsObservation `json:"metadataOptions,omitempty" tf:"metadata_options,omitempty"`

	// Name template of the instance.
	// In order to be unique it must contain at least one of instance unique placeholders:
	// {instance.short_id}
	// {instance.index}
	// combination of {instance.zone_id} and {instance.index_in_zone}
	// Example: my-instance-{instance.index}
	// If not set, default is used: {instance_group.id}-{instance.short_id}
	// It may also contain another placeholders, see metadata doc for full list.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Network specifications for the instance. This can be used multiple times for adding multiple interfaces. The structure is documented below.
	NetworkInterface []InstanceTemplateNetworkInterfaceObservation `json:"networkInterface,omitempty" tf:"network_interface,omitempty"`

	// Network acceleration type for instance. The structure is documented below.
	NetworkSettings []NetworkSettingsObservation `json:"networkSettings,omitempty" tf:"network_settings,omitempty"`

	// The placement policy configuration. The structure is documented below.
	PlacementPolicy []InstanceTemplatePlacementPolicyObservation `json:"placementPolicy,omitempty" tf:"placement_policy,omitempty"`

	// The ID of the hardware platform configuration for the instance. The default is 'standard-v1'.
	PlatformID *string `json:"platformId,omitempty" tf:"platform_id,omitempty"`

	// Compute resource specifications for the instance. The structure is documented below.
	Resources []InstanceTemplateResourcesObservation `json:"resources,omitempty" tf:"resources,omitempty"`

	// The scheduling policy configuration. The structure is documented below.
	SchedulingPolicy []InstanceTemplateSchedulingPolicyObservation `json:"schedulingPolicy,omitempty" tf:"scheduling_policy,omitempty"`

	// A list of disks to attach to the instance. The structure is documented below.
	SecondaryDisk []InstanceTemplateSecondaryDiskObservation `json:"secondaryDisk,omitempty" tf:"secondary_disk,omitempty"`

	// The ID of the service account authorized for this instance.
	ServiceAccountID *string `json:"serviceAccountId,omitempty" tf:"service_account_id,omitempty"`
}

type InstanceTemplateParameters struct {

	// Boot disk specifications for the instance. The structure is documented below.
	// +kubebuilder:validation:Optional
	BootDisk []InstanceTemplateBootDiskParameters `json:"bootDisk" tf:"boot_disk,omitempty"`

	// A description of the instance.
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// List of filesystems to attach to the instance. The structure is documented below.
	// +kubebuilder:validation:Optional
	Filesystem []InstanceTemplateFilesystemParameters `json:"filesystem,omitempty" tf:"filesystem,omitempty"`

	// Hostname template for the instance.
	// This field is used to generate the FQDN value of instance.
	// The hostname must be unique within the network and region.
	// If not specified, the hostname will be equal to id of the instance
	// and FQDN will be <id>.auto.internal. Otherwise FQDN will be <hostname>.<region_id>.internal.
	// In order to be unique it must contain at least on of instance unique placeholders:
	// {instance.short_id}
	// {instance.index}
	// combination of {instance.zone_id} and {instance.index_in_zone}
	// Example: my-instance-{instance.index}
	// If not set, name value will be used
	// It may also contain another placeholders, see metadata doc for full list.
	// +kubebuilder:validation:Optional
	Hostname *string `json:"hostname,omitempty" tf:"hostname,omitempty"`

	// A set of key/value label pairs to assign to the instance.
	// +kubebuilder:validation:Optional
	// +mapType=granular
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// A set of metadata key/value pairs to make available from within the instance.
	// +kubebuilder:validation:Optional
	// +mapType=granular
	Metadata map[string]*string `json:"metadata,omitempty" tf:"metadata,omitempty"`

	// Options allow user to configure access to managed instances metadata
	// +kubebuilder:validation:Optional
	MetadataOptions []InstanceTemplateMetadataOptionsParameters `json:"metadataOptions,omitempty" tf:"metadata_options,omitempty"`

	// Name template of the instance.
	// In order to be unique it must contain at least one of instance unique placeholders:
	// {instance.short_id}
	// {instance.index}
	// combination of {instance.zone_id} and {instance.index_in_zone}
	// Example: my-instance-{instance.index}
	// If not set, default is used: {instance_group.id}-{instance.short_id}
	// It may also contain another placeholders, see metadata doc for full list.
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Network specifications for the instance. This can be used multiple times for adding multiple interfaces. The structure is documented below.
	// +kubebuilder:validation:Optional
	NetworkInterface []InstanceTemplateNetworkInterfaceParameters `json:"networkInterface" tf:"network_interface,omitempty"`

	// Network acceleration type for instance. The structure is documented below.
	// +kubebuilder:validation:Optional
	NetworkSettings []NetworkSettingsParameters `json:"networkSettings,omitempty" tf:"network_settings,omitempty"`

	// The placement policy configuration. The structure is documented below.
	// +kubebuilder:validation:Optional
	PlacementPolicy []InstanceTemplatePlacementPolicyParameters `json:"placementPolicy,omitempty" tf:"placement_policy,omitempty"`

	// The ID of the hardware platform configuration for the instance. The default is 'standard-v1'.
	// +kubebuilder:validation:Optional
	PlatformID *string `json:"platformId,omitempty" tf:"platform_id,omitempty"`

	// Compute resource specifications for the instance. The structure is documented below.
	// +kubebuilder:validation:Optional
	Resources []InstanceTemplateResourcesParameters `json:"resources" tf:"resources,omitempty"`

	// The scheduling policy configuration. The structure is documented below.
	// +kubebuilder:validation:Optional
	SchedulingPolicy []InstanceTemplateSchedulingPolicyParameters `json:"schedulingPolicy,omitempty" tf:"scheduling_policy,omitempty"`

	// A list of disks to attach to the instance. The structure is documented below.
	// +kubebuilder:validation:Optional
	SecondaryDisk []InstanceTemplateSecondaryDiskParameters `json:"secondaryDisk,omitempty" tf:"secondary_disk,omitempty"`

	// The ID of the service account authorized for this instance.
	// +kubebuilder:validation:Optional
	ServiceAccountID *string `json:"serviceAccountId,omitempty" tf:"service_account_id,omitempty"`
}

type InstanceTemplatePlacementPolicyInitParameters struct {

	// Specifies the id of the Placement Group to assign to the instances.
	// +crossplane:generate:reference:type=github.com/yandex-cloud/crossplane-provider-yc/apis/compute/v1alpha1.PlacementGroup
	PlacementGroupID *string `json:"placementGroupId,omitempty" tf:"placement_group_id,omitempty"`

	// Reference to a PlacementGroup in compute to populate placementGroupId.
	// +kubebuilder:validation:Optional
	PlacementGroupIDRef *v1.Reference `json:"placementGroupIdRef,omitempty" tf:"-"`

	// Selector for a PlacementGroup in compute to populate placementGroupId.
	// +kubebuilder:validation:Optional
	PlacementGroupIDSelector *v1.Selector `json:"placementGroupIdSelector,omitempty" tf:"-"`
}

type InstanceTemplatePlacementPolicyObservation struct {

	// Specifies the id of the Placement Group to assign to the instances.
	PlacementGroupID *string `json:"placementGroupId,omitempty" tf:"placement_group_id,omitempty"`
}

type InstanceTemplatePlacementPolicyParameters struct {

	// Specifies the id of the Placement Group to assign to the instances.
	// +crossplane:generate:reference:type=github.com/yandex-cloud/crossplane-provider-yc/apis/compute/v1alpha1.PlacementGroup
	// +kubebuilder:validation:Optional
	PlacementGroupID *string `json:"placementGroupId,omitempty" tf:"placement_group_id,omitempty"`

	// Reference to a PlacementGroup in compute to populate placementGroupId.
	// +kubebuilder:validation:Optional
	PlacementGroupIDRef *v1.Reference `json:"placementGroupIdRef,omitempty" tf:"-"`

	// Selector for a PlacementGroup in compute to populate placementGroupId.
	// +kubebuilder:validation:Optional
	PlacementGroupIDSelector *v1.Selector `json:"placementGroupIdSelector,omitempty" tf:"-"`
}

type InstanceTemplateResourcesInitParameters struct {

	// If provided, specifies baseline core performance as a percent.
	CoreFraction *float64 `json:"coreFraction,omitempty" tf:"core_fraction,omitempty"`

	// The number of CPU cores for the instance.
	Cores *float64 `json:"cores,omitempty" tf:"cores,omitempty"`

	Gpus *float64 `json:"gpus,omitempty" tf:"gpus,omitempty"`

	// The memory size in GB.
	Memory *float64 `json:"memory,omitempty" tf:"memory,omitempty"`
}

type InstanceTemplateResourcesObservation struct {

	// If provided, specifies baseline core performance as a percent.
	CoreFraction *float64 `json:"coreFraction,omitempty" tf:"core_fraction,omitempty"`

	// The number of CPU cores for the instance.
	Cores *float64 `json:"cores,omitempty" tf:"cores,omitempty"`

	Gpus *float64 `json:"gpus,omitempty" tf:"gpus,omitempty"`

	// The memory size in GB.
	Memory *float64 `json:"memory,omitempty" tf:"memory,omitempty"`
}

type InstanceTemplateResourcesParameters struct {

	// If provided, specifies baseline core performance as a percent.
	// +kubebuilder:validation:Optional
	CoreFraction *float64 `json:"coreFraction,omitempty" tf:"core_fraction,omitempty"`

	// The number of CPU cores for the instance.
	// +kubebuilder:validation:Optional
	Cores *float64 `json:"cores" tf:"cores,omitempty"`

	// +kubebuilder:validation:Optional
	Gpus *float64 `json:"gpus,omitempty" tf:"gpus,omitempty"`

	// The memory size in GB.
	// +kubebuilder:validation:Optional
	Memory *float64 `json:"memory" tf:"memory,omitempty"`
}

type InstanceTemplateSchedulingPolicyInitParameters struct {

	// Specifies if the instance is preemptible. Defaults to false.
	Preemptible *bool `json:"preemptible,omitempty" tf:"preemptible,omitempty"`
}

type InstanceTemplateSchedulingPolicyObservation struct {

	// Specifies if the instance is preemptible. Defaults to false.
	Preemptible *bool `json:"preemptible,omitempty" tf:"preemptible,omitempty"`
}

type InstanceTemplateSchedulingPolicyParameters struct {

	// Specifies if the instance is preemptible. Defaults to false.
	// +kubebuilder:validation:Optional
	Preemptible *bool `json:"preemptible,omitempty" tf:"preemptible,omitempty"`
}

type InstanceTemplateSecondaryDiskInitParameters struct {

	// This value can be used to reference the device under /dev/disk/by-id/.
	DeviceName *string `json:"deviceName,omitempty" tf:"device_name,omitempty"`

	// ID of the existing disk. To set use variables.
	// +crossplane:generate:reference:type=github.com/yandex-cloud/crossplane-provider-yc/apis/compute/v1alpha1.Disk
	DiskID *string `json:"diskId,omitempty" tf:"disk_id,omitempty"`

	// Reference to a Disk in compute to populate diskId.
	// +kubebuilder:validation:Optional
	DiskIDRef *v1.Reference `json:"diskIdRef,omitempty" tf:"-"`

	// Selector for a Disk in compute to populate diskId.
	// +kubebuilder:validation:Optional
	DiskIDSelector *v1.Selector `json:"diskIdSelector,omitempty" tf:"-"`

	// Parameters used for creating a disk alongside the instance. The structure is documented below.
	InitializeParams []SecondaryDiskInitializeParamsInitParameters `json:"initializeParams,omitempty" tf:"initialize_params,omitempty"`

	// The access mode to the disk resource. By default a disk is attached in READ_WRITE mode.
	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`

	// When set can be later used to change DiskSpec of actual disk.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type InstanceTemplateSecondaryDiskObservation struct {

	// This value can be used to reference the device under /dev/disk/by-id/.
	DeviceName *string `json:"deviceName,omitempty" tf:"device_name,omitempty"`

	// ID of the existing disk. To set use variables.
	DiskID *string `json:"diskId,omitempty" tf:"disk_id,omitempty"`

	// Parameters used for creating a disk alongside the instance. The structure is documented below.
	InitializeParams []SecondaryDiskInitializeParamsObservation `json:"initializeParams,omitempty" tf:"initialize_params,omitempty"`

	// The access mode to the disk resource. By default a disk is attached in READ_WRITE mode.
	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`

	// When set can be later used to change DiskSpec of actual disk.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type InstanceTemplateSecondaryDiskParameters struct {

	// This value can be used to reference the device under /dev/disk/by-id/.
	// +kubebuilder:validation:Optional
	DeviceName *string `json:"deviceName,omitempty" tf:"device_name,omitempty"`

	// ID of the existing disk. To set use variables.
	// +crossplane:generate:reference:type=github.com/yandex-cloud/crossplane-provider-yc/apis/compute/v1alpha1.Disk
	// +kubebuilder:validation:Optional
	DiskID *string `json:"diskId,omitempty" tf:"disk_id,omitempty"`

	// Reference to a Disk in compute to populate diskId.
	// +kubebuilder:validation:Optional
	DiskIDRef *v1.Reference `json:"diskIdRef,omitempty" tf:"-"`

	// Selector for a Disk in compute to populate diskId.
	// +kubebuilder:validation:Optional
	DiskIDSelector *v1.Selector `json:"diskIdSelector,omitempty" tf:"-"`

	// Parameters used for creating a disk alongside the instance. The structure is documented below.
	// +kubebuilder:validation:Optional
	InitializeParams []SecondaryDiskInitializeParamsParameters `json:"initializeParams,omitempty" tf:"initialize_params,omitempty"`

	// The access mode to the disk resource. By default a disk is attached in READ_WRITE mode.
	// +kubebuilder:validation:Optional
	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`

	// When set can be later used to change DiskSpec of actual disk.
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type InstancesInitParameters struct {
}

type InstancesNetworkInterfaceInitParameters struct {
}

type InstancesNetworkInterfaceObservation struct {

	// The private IP address to assign to the instance. If empty, the address is automatically assigned from the specified subnet.
	IPAddress *string `json:"ipAddress,omitempty" tf:"ip_address,omitempty"`

	// True if IPv4 address allocated for the network interface.
	IPv4 *bool `json:"ipv4,omitempty" tf:"ipv4,omitempty"`

	IPv6 *bool `json:"ipv6,omitempty" tf:"ipv6,omitempty"`

	// Manual set static IPv6 address.
	IPv6Address *string `json:"ipv6Address,omitempty" tf:"ipv6_address,omitempty"`

	// The index of the network interface as generated by the server.
	Index *float64 `json:"index,omitempty" tf:"index,omitempty"`

	// The MAC address assigned to the network interface.
	MacAddress *string `json:"macAddress,omitempty" tf:"mac_address,omitempty"`

	// The instance's public address for accessing the internet over NAT.
	NAT *bool `json:"nat,omitempty" tf:"nat,omitempty"`

	// The public IP address of the instance.
	NATIPAddress *string `json:"natIpAddress,omitempty" tf:"nat_ip_address,omitempty"`

	// The IP version for the public address.
	NATIPVersion *string `json:"natIpVersion,omitempty" tf:"nat_ip_version,omitempty"`

	// The ID of the subnet to attach this interface to. The subnet must reside in the same zone where this instance was created.
	SubnetID *string `json:"subnetId,omitempty" tf:"subnet_id,omitempty"`
}

type InstancesNetworkInterfaceParameters struct {
}

type InstancesObservation struct {

	// The Fully Qualified Domain Name.
	Fqdn *string `json:"fqdn,omitempty" tf:"fqdn,omitempty"`

	// The ID of the instance.
	InstanceID *string `json:"instanceId,omitempty" tf:"instance_id,omitempty"`

	InstanceTag *string `json:"instanceTag,omitempty" tf:"instance_tag,omitempty"`

	// The name of the managed instance.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// An array with the network interfaces attached to the managed instance.
	NetworkInterface []InstancesNetworkInterfaceObservation `json:"networkInterface,omitempty" tf:"network_interface,omitempty"`

	// The status of the instance.
	Status *string `json:"status,omitempty" tf:"status,omitempty"`

	StatusChangedAt *string `json:"statusChangedAt,omitempty" tf:"status_changed_at,omitempty"`

	// The status message of the instance.
	StatusMessage *string `json:"statusMessage,omitempty" tf:"status_message,omitempty"`

	// The ID of the availability zone where the instance resides.
	ZoneID *string `json:"zoneId,omitempty" tf:"zone_id,omitempty"`
}

type InstancesParameters struct {
}

type LoadBalancerInitParameters struct {

	// Do not wait load balancer health checks.
	IgnoreHealthChecks *bool `json:"ignoreHealthChecks,omitempty" tf:"ignore_health_checks,omitempty"`

	// Timeout for waiting for the VM to be checked by the load balancer. If the timeout is exceeded, the VM will be turned off based on the deployment policy. Specified in seconds.
	MaxOpeningTrafficDuration *float64 `json:"maxOpeningTrafficDuration,omitempty" tf:"max_opening_traffic_duration,omitempty"`

	// A description of the target group.
	TargetGroupDescription *string `json:"targetGroupDescription,omitempty" tf:"target_group_description,omitempty"`

	// A set of key/value label pairs.
	// +mapType=granular
	TargetGroupLabels map[string]*string `json:"targetGroupLabels,omitempty" tf:"target_group_labels,omitempty"`

	// The name of the target group.
	TargetGroupName *string `json:"targetGroupName,omitempty" tf:"target_group_name,omitempty"`
}

type LoadBalancerObservation struct {

	// Do not wait load balancer health checks.
	IgnoreHealthChecks *bool `json:"ignoreHealthChecks,omitempty" tf:"ignore_health_checks,omitempty"`

	// Timeout for waiting for the VM to be checked by the load balancer. If the timeout is exceeded, the VM will be turned off based on the deployment policy. Specified in seconds.
	MaxOpeningTrafficDuration *float64 `json:"maxOpeningTrafficDuration,omitempty" tf:"max_opening_traffic_duration,omitempty"`

	// The status message of the target group.
	StatusMessage *string `json:"statusMessage,omitempty" tf:"status_message,omitempty"`

	// A description of the target group.
	TargetGroupDescription *string `json:"targetGroupDescription,omitempty" tf:"target_group_description,omitempty"`

	// The ID of the target group.
	TargetGroupID *string `json:"targetGroupId,omitempty" tf:"target_group_id,omitempty"`

	// A set of key/value label pairs.
	// +mapType=granular
	TargetGroupLabels map[string]*string `json:"targetGroupLabels,omitempty" tf:"target_group_labels,omitempty"`

	// The name of the target group.
	TargetGroupName *string `json:"targetGroupName,omitempty" tf:"target_group_name,omitempty"`
}

type LoadBalancerParameters struct {

	// Do not wait load balancer health checks.
	// +kubebuilder:validation:Optional
	IgnoreHealthChecks *bool `json:"ignoreHealthChecks,omitempty" tf:"ignore_health_checks,omitempty"`

	// Timeout for waiting for the VM to be checked by the load balancer. If the timeout is exceeded, the VM will be turned off based on the deployment policy. Specified in seconds.
	// +kubebuilder:validation:Optional
	MaxOpeningTrafficDuration *float64 `json:"maxOpeningTrafficDuration,omitempty" tf:"max_opening_traffic_duration,omitempty"`

	// A description of the target group.
	// +kubebuilder:validation:Optional
	TargetGroupDescription *string `json:"targetGroupDescription,omitempty" tf:"target_group_description,omitempty"`

	// A set of key/value label pairs.
	// +kubebuilder:validation:Optional
	// +mapType=granular
	TargetGroupLabels map[string]*string `json:"targetGroupLabels,omitempty" tf:"target_group_labels,omitempty"`

	// The name of the target group.
	// +kubebuilder:validation:Optional
	TargetGroupName *string `json:"targetGroupName,omitempty" tf:"target_group_name,omitempty"`
}

type NetworkInterfaceDNSRecordInitParameters struct {

	// DNS zone id (if not set, private zone used).
	DNSZoneID *string `json:"dnsZoneId,omitempty" tf:"dns_zone_id,omitempty"`

	// DNS record fqdn (must have dot at the end).
	Fqdn *string `json:"fqdn,omitempty" tf:"fqdn,omitempty"`

	// When set to true, also create PTR DNS record.
	Ptr *bool `json:"ptr,omitempty" tf:"ptr,omitempty"`

	// DNS record TTL.
	TTL *float64 `json:"ttl,omitempty" tf:"ttl,omitempty"`
}

type NetworkInterfaceDNSRecordObservation struct {

	// DNS zone id (if not set, private zone used).
	DNSZoneID *string `json:"dnsZoneId,omitempty" tf:"dns_zone_id,omitempty"`

	// DNS record fqdn (must have dot at the end).
	Fqdn *string `json:"fqdn,omitempty" tf:"fqdn,omitempty"`

	// When set to true, also create PTR DNS record.
	Ptr *bool `json:"ptr,omitempty" tf:"ptr,omitempty"`

	// DNS record TTL.
	TTL *float64 `json:"ttl,omitempty" tf:"ttl,omitempty"`
}

type NetworkInterfaceDNSRecordParameters struct {

	// DNS zone id (if not set, private zone used).
	// +kubebuilder:validation:Optional
	DNSZoneID *string `json:"dnsZoneId,omitempty" tf:"dns_zone_id,omitempty"`

	// DNS record fqdn (must have dot at the end).
	// +kubebuilder:validation:Optional
	Fqdn *string `json:"fqdn" tf:"fqdn,omitempty"`

	// When set to true, also create PTR DNS record.
	// +kubebuilder:validation:Optional
	Ptr *bool `json:"ptr,omitempty" tf:"ptr,omitempty"`

	// DNS record TTL.
	// +kubebuilder:validation:Optional
	TTL *float64 `json:"ttl,omitempty" tf:"ttl,omitempty"`
}

type NetworkInterfaceIPv6DNSRecordInitParameters struct {

	// DNS zone id (if not set, private zone used).
	DNSZoneID *string `json:"dnsZoneId,omitempty" tf:"dns_zone_id,omitempty"`

	// DNS record fqdn (must have dot at the end).
	Fqdn *string `json:"fqdn,omitempty" tf:"fqdn,omitempty"`

	// When set to true, also create PTR DNS record.
	Ptr *bool `json:"ptr,omitempty" tf:"ptr,omitempty"`

	// DNS record TTL.
	TTL *float64 `json:"ttl,omitempty" tf:"ttl,omitempty"`
}

type NetworkInterfaceIPv6DNSRecordObservation struct {

	// DNS zone id (if not set, private zone used).
	DNSZoneID *string `json:"dnsZoneId,omitempty" tf:"dns_zone_id,omitempty"`

	// DNS record fqdn (must have dot at the end).
	Fqdn *string `json:"fqdn,omitempty" tf:"fqdn,omitempty"`

	// When set to true, also create PTR DNS record.
	Ptr *bool `json:"ptr,omitempty" tf:"ptr,omitempty"`

	// DNS record TTL.
	TTL *float64 `json:"ttl,omitempty" tf:"ttl,omitempty"`
}

type NetworkInterfaceIPv6DNSRecordParameters struct {

	// DNS zone id (if not set, private zone used).
	// +kubebuilder:validation:Optional
	DNSZoneID *string `json:"dnsZoneId,omitempty" tf:"dns_zone_id,omitempty"`

	// DNS record fqdn (must have dot at the end).
	// +kubebuilder:validation:Optional
	Fqdn *string `json:"fqdn" tf:"fqdn,omitempty"`

	// When set to true, also create PTR DNS record.
	// +kubebuilder:validation:Optional
	Ptr *bool `json:"ptr,omitempty" tf:"ptr,omitempty"`

	// DNS record TTL.
	// +kubebuilder:validation:Optional
	TTL *float64 `json:"ttl,omitempty" tf:"ttl,omitempty"`
}

type NetworkInterfaceNATDNSRecordInitParameters struct {

	// DNS zone id (if not set, private zone used).
	DNSZoneID *string `json:"dnsZoneId,omitempty" tf:"dns_zone_id,omitempty"`

	// DNS record fqdn (must have dot at the end).
	Fqdn *string `json:"fqdn,omitempty" tf:"fqdn,omitempty"`

	// When set to true, also create PTR DNS record.
	Ptr *bool `json:"ptr,omitempty" tf:"ptr,omitempty"`

	// DNS record TTL.
	TTL *float64 `json:"ttl,omitempty" tf:"ttl,omitempty"`
}

type NetworkInterfaceNATDNSRecordObservation struct {

	// DNS zone id (if not set, private zone used).
	DNSZoneID *string `json:"dnsZoneId,omitempty" tf:"dns_zone_id,omitempty"`

	// DNS record fqdn (must have dot at the end).
	Fqdn *string `json:"fqdn,omitempty" tf:"fqdn,omitempty"`

	// When set to true, also create PTR DNS record.
	Ptr *bool `json:"ptr,omitempty" tf:"ptr,omitempty"`

	// DNS record TTL.
	TTL *float64 `json:"ttl,omitempty" tf:"ttl,omitempty"`
}

type NetworkInterfaceNATDNSRecordParameters struct {

	// DNS zone id (if not set, private zone used).
	// +kubebuilder:validation:Optional
	DNSZoneID *string `json:"dnsZoneId,omitempty" tf:"dns_zone_id,omitempty"`

	// DNS record fqdn (must have dot at the end).
	// +kubebuilder:validation:Optional
	Fqdn *string `json:"fqdn" tf:"fqdn,omitempty"`

	// When set to true, also create PTR DNS record.
	// +kubebuilder:validation:Optional
	Ptr *bool `json:"ptr,omitempty" tf:"ptr,omitempty"`

	// DNS record TTL.
	// +kubebuilder:validation:Optional
	TTL *float64 `json:"ttl,omitempty" tf:"ttl,omitempty"`
}

type NetworkSettingsInitParameters struct {

	// Network acceleration type. By default a network is in STANDARD mode.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type NetworkSettingsObservation struct {

	// Network acceleration type. By default a network is in STANDARD mode.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type NetworkSettingsParameters struct {

	// Network acceleration type. By default a network is in STANDARD mode.
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type ScalePolicyInitParameters struct {

	// The auto scaling policy of the instance group. The structure is documented below.
	AutoScale []AutoScaleInitParameters `json:"autoScale,omitempty" tf:"auto_scale,omitempty"`

	// The fixed scaling policy of the instance group. The structure is documented below.
	FixedScale []FixedScaleInitParameters `json:"fixedScale,omitempty" tf:"fixed_scale,omitempty"`

	// The test auto scaling policy of the instance group. Use it to test how the auto scale works. The structure is documented below.
	TestAutoScale []TestAutoScaleInitParameters `json:"testAutoScale,omitempty" tf:"test_auto_scale,omitempty"`
}

type ScalePolicyObservation struct {

	// The auto scaling policy of the instance group. The structure is documented below.
	AutoScale []AutoScaleObservation `json:"autoScale,omitempty" tf:"auto_scale,omitempty"`

	// The fixed scaling policy of the instance group. The structure is documented below.
	FixedScale []FixedScaleObservation `json:"fixedScale,omitempty" tf:"fixed_scale,omitempty"`

	// The test auto scaling policy of the instance group. Use it to test how the auto scale works. The structure is documented below.
	TestAutoScale []TestAutoScaleObservation `json:"testAutoScale,omitempty" tf:"test_auto_scale,omitempty"`
}

type ScalePolicyParameters struct {

	// The auto scaling policy of the instance group. The structure is documented below.
	// +kubebuilder:validation:Optional
	AutoScale []AutoScaleParameters `json:"autoScale,omitempty" tf:"auto_scale,omitempty"`

	// The fixed scaling policy of the instance group. The structure is documented below.
	// +kubebuilder:validation:Optional
	FixedScale []FixedScaleParameters `json:"fixedScale,omitempty" tf:"fixed_scale,omitempty"`

	// The test auto scaling policy of the instance group. Use it to test how the auto scale works. The structure is documented below.
	// +kubebuilder:validation:Optional
	TestAutoScale []TestAutoScaleParameters `json:"testAutoScale,omitempty" tf:"test_auto_scale,omitempty"`
}

type SecondaryDiskInitializeParamsInitParameters struct {

	// A description of the instance.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// The disk image to initialize this disk from.
	ImageID *string `json:"imageId,omitempty" tf:"image_id,omitempty"`

	// The size of the disk in GB.
	Size *float64 `json:"size,omitempty" tf:"size,omitempty"`

	// The snapshot to initialize this disk from.
	SnapshotID *string `json:"snapshotId,omitempty" tf:"snapshot_id,omitempty"`

	// Network acceleration type. By default a network is in STANDARD mode.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type SecondaryDiskInitializeParamsObservation struct {

	// A description of the instance.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// The disk image to initialize this disk from.
	ImageID *string `json:"imageId,omitempty" tf:"image_id,omitempty"`

	// The size of the disk in GB.
	Size *float64 `json:"size,omitempty" tf:"size,omitempty"`

	// The snapshot to initialize this disk from.
	SnapshotID *string `json:"snapshotId,omitempty" tf:"snapshot_id,omitempty"`

	// Network acceleration type. By default a network is in STANDARD mode.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type SecondaryDiskInitializeParamsParameters struct {

	// A description of the instance.
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// The disk image to initialize this disk from.
	// +kubebuilder:validation:Optional
	ImageID *string `json:"imageId,omitempty" tf:"image_id,omitempty"`

	// The size of the disk in GB.
	// +kubebuilder:validation:Optional
	Size *float64 `json:"size,omitempty" tf:"size,omitempty"`

	// The snapshot to initialize this disk from.
	// +kubebuilder:validation:Optional
	SnapshotID *string `json:"snapshotId,omitempty" tf:"snapshot_id,omitempty"`

	// Network acceleration type. By default a network is in STANDARD mode.
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type TCPOptionsInitParameters struct {

	// The port used for TCP health checks.
	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`
}

type TCPOptionsObservation struct {

	// The port used for TCP health checks.
	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`
}

type TCPOptionsParameters struct {

	// The port used for TCP health checks.
	// +kubebuilder:validation:Optional
	Port *float64 `json:"port" tf:"port,omitempty"`
}

type TestAutoScaleCustomRuleInitParameters struct {

	// The ID of the folder that the resources belong to.
	FolderID *string `json:"folderId,omitempty" tf:"folder_id,omitempty"`

	// A set of key/value label pairs to assign to the instance group.
	// +mapType=granular
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// The name of metric.
	MetricName *string `json:"metricName,omitempty" tf:"metric_name,omitempty"`

	// Metric type, GAUGE or COUNTER.
	MetricType *string `json:"metricType,omitempty" tf:"metric_type,omitempty"`

	// Rule type: UTILIZATION - This type means that the metric applies to one instance.
	// First, Instance Groups calculates the average metric value for each instance,
	// then averages the values for instances in one availability zone.
	// This type of metric must have the instance_id label. WORKLOAD - This type means that the metric applies to instances in one availability zone.
	// This type of metric must have the zone_id label.
	RuleType *string `json:"ruleType,omitempty" tf:"rule_type,omitempty"`

	// Service of custom metric in Yandex Monitoring that should be used for scaling.
	Service *string `json:"service,omitempty" tf:"service,omitempty"`

	// Target metric value level.
	Target *float64 `json:"target,omitempty" tf:"target,omitempty"`
}

type TestAutoScaleCustomRuleObservation struct {

	// The ID of the folder that the resources belong to.
	FolderID *string `json:"folderId,omitempty" tf:"folder_id,omitempty"`

	// A set of key/value label pairs to assign to the instance group.
	// +mapType=granular
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// The name of metric.
	MetricName *string `json:"metricName,omitempty" tf:"metric_name,omitempty"`

	// Metric type, GAUGE or COUNTER.
	MetricType *string `json:"metricType,omitempty" tf:"metric_type,omitempty"`

	// Rule type: UTILIZATION - This type means that the metric applies to one instance.
	// First, Instance Groups calculates the average metric value for each instance,
	// then averages the values for instances in one availability zone.
	// This type of metric must have the instance_id label. WORKLOAD - This type means that the metric applies to instances in one availability zone.
	// This type of metric must have the zone_id label.
	RuleType *string `json:"ruleType,omitempty" tf:"rule_type,omitempty"`

	// Service of custom metric in Yandex Monitoring that should be used for scaling.
	Service *string `json:"service,omitempty" tf:"service,omitempty"`

	// Target metric value level.
	Target *float64 `json:"target,omitempty" tf:"target,omitempty"`
}

type TestAutoScaleCustomRuleParameters struct {

	// The ID of the folder that the resources belong to.
	// +kubebuilder:validation:Optional
	FolderID *string `json:"folderId,omitempty" tf:"folder_id,omitempty"`

	// A set of key/value label pairs to assign to the instance group.
	// +kubebuilder:validation:Optional
	// +mapType=granular
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// The name of metric.
	// +kubebuilder:validation:Optional
	MetricName *string `json:"metricName" tf:"metric_name,omitempty"`

	// Metric type, GAUGE or COUNTER.
	// +kubebuilder:validation:Optional
	MetricType *string `json:"metricType" tf:"metric_type,omitempty"`

	// Rule type: UTILIZATION - This type means that the metric applies to one instance.
	// First, Instance Groups calculates the average metric value for each instance,
	// then averages the values for instances in one availability zone.
	// This type of metric must have the instance_id label. WORKLOAD - This type means that the metric applies to instances in one availability zone.
	// This type of metric must have the zone_id label.
	// +kubebuilder:validation:Optional
	RuleType *string `json:"ruleType" tf:"rule_type,omitempty"`

	// Service of custom metric in Yandex Monitoring that should be used for scaling.
	// +kubebuilder:validation:Optional
	Service *string `json:"service,omitempty" tf:"service,omitempty"`

	// Target metric value level.
	// +kubebuilder:validation:Optional
	Target *float64 `json:"target" tf:"target,omitempty"`
}

type TestAutoScaleInitParameters struct {

	// Target CPU load level.
	CPUUtilizationTarget *float64 `json:"cpuUtilizationTarget,omitempty" tf:"cpu_utilization_target,omitempty"`

	// A list of custom rules. The structure is documented below.
	CustomRule []TestAutoScaleCustomRuleInitParameters `json:"customRule,omitempty" tf:"custom_rule,omitempty"`

	// The initial number of instances in the instance group.
	InitialSize *float64 `json:"initialSize,omitempty" tf:"initial_size,omitempty"`

	// The maximum number of virtual machines in the group.
	MaxSize *float64 `json:"maxSize,omitempty" tf:"max_size,omitempty"`

	// The amount of time, in seconds, that metrics are averaged for.
	// If the average value at the end of the interval is higher than the cpu_utilization_target,
	// the instance group will increase the number of virtual machines in the group.
	MeasurementDuration *float64 `json:"measurementDuration,omitempty" tf:"measurement_duration,omitempty"`

	// The minimum number of virtual machines in a single availability zone.
	MinZoneSize *float64 `json:"minZoneSize,omitempty" tf:"min_zone_size,omitempty"`

	// The minimum time interval, in seconds, to monitor the load before
	// an instance group can reduce the number of virtual machines in the group. During this time, the group
	// will not decrease even if the average load falls below the value of cpu_utilization_target.
	StabilizationDuration *float64 `json:"stabilizationDuration,omitempty" tf:"stabilization_duration,omitempty"`

	// The warm-up time of the virtual machine, in seconds. During this time,
	// traffic is fed to the virtual machine, but load metrics are not taken into account.
	WarmupDuration *float64 `json:"warmupDuration,omitempty" tf:"warmup_duration,omitempty"`
}

type TestAutoScaleObservation struct {

	// Target CPU load level.
	CPUUtilizationTarget *float64 `json:"cpuUtilizationTarget,omitempty" tf:"cpu_utilization_target,omitempty"`

	// A list of custom rules. The structure is documented below.
	CustomRule []TestAutoScaleCustomRuleObservation `json:"customRule,omitempty" tf:"custom_rule,omitempty"`

	// The initial number of instances in the instance group.
	InitialSize *float64 `json:"initialSize,omitempty" tf:"initial_size,omitempty"`

	// The maximum number of virtual machines in the group.
	MaxSize *float64 `json:"maxSize,omitempty" tf:"max_size,omitempty"`

	// The amount of time, in seconds, that metrics are averaged for.
	// If the average value at the end of the interval is higher than the cpu_utilization_target,
	// the instance group will increase the number of virtual machines in the group.
	MeasurementDuration *float64 `json:"measurementDuration,omitempty" tf:"measurement_duration,omitempty"`

	// The minimum number of virtual machines in a single availability zone.
	MinZoneSize *float64 `json:"minZoneSize,omitempty" tf:"min_zone_size,omitempty"`

	// The minimum time interval, in seconds, to monitor the load before
	// an instance group can reduce the number of virtual machines in the group. During this time, the group
	// will not decrease even if the average load falls below the value of cpu_utilization_target.
	StabilizationDuration *float64 `json:"stabilizationDuration,omitempty" tf:"stabilization_duration,omitempty"`

	// The warm-up time of the virtual machine, in seconds. During this time,
	// traffic is fed to the virtual machine, but load metrics are not taken into account.
	WarmupDuration *float64 `json:"warmupDuration,omitempty" tf:"warmup_duration,omitempty"`
}

type TestAutoScaleParameters struct {

	// Target CPU load level.
	// +kubebuilder:validation:Optional
	CPUUtilizationTarget *float64 `json:"cpuUtilizationTarget,omitempty" tf:"cpu_utilization_target,omitempty"`

	// A list of custom rules. The structure is documented below.
	// +kubebuilder:validation:Optional
	CustomRule []TestAutoScaleCustomRuleParameters `json:"customRule,omitempty" tf:"custom_rule,omitempty"`

	// The initial number of instances in the instance group.
	// +kubebuilder:validation:Optional
	InitialSize *float64 `json:"initialSize" tf:"initial_size,omitempty"`

	// The maximum number of virtual machines in the group.
	// +kubebuilder:validation:Optional
	MaxSize *float64 `json:"maxSize,omitempty" tf:"max_size,omitempty"`

	// The amount of time, in seconds, that metrics are averaged for.
	// If the average value at the end of the interval is higher than the cpu_utilization_target,
	// the instance group will increase the number of virtual machines in the group.
	// +kubebuilder:validation:Optional
	MeasurementDuration *float64 `json:"measurementDuration" tf:"measurement_duration,omitempty"`

	// The minimum number of virtual machines in a single availability zone.
	// +kubebuilder:validation:Optional
	MinZoneSize *float64 `json:"minZoneSize,omitempty" tf:"min_zone_size,omitempty"`

	// The minimum time interval, in seconds, to monitor the load before
	// an instance group can reduce the number of virtual machines in the group. During this time, the group
	// will not decrease even if the average load falls below the value of cpu_utilization_target.
	// +kubebuilder:validation:Optional
	StabilizationDuration *float64 `json:"stabilizationDuration,omitempty" tf:"stabilization_duration,omitempty"`

	// The warm-up time of the virtual machine, in seconds. During this time,
	// traffic is fed to the virtual machine, but load metrics are not taken into account.
	// +kubebuilder:validation:Optional
	WarmupDuration *float64 `json:"warmupDuration,omitempty" tf:"warmup_duration,omitempty"`
}

// InstanceGroupSpec defines the desired state of InstanceGroup
type InstanceGroupSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     InstanceGroupParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider InstanceGroupInitParameters `json:"initProvider,omitempty"`
}

// InstanceGroupStatus defines the observed state of InstanceGroup.
type InstanceGroupStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        InstanceGroupObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// InstanceGroup is the Schema for the InstanceGroups API. Manages an Instance group resource.
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,yandex-cloud}
type InstanceGroup struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.allocationPolicy) || (has(self.initProvider) && has(self.initProvider.allocationPolicy))",message="spec.forProvider.allocationPolicy is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.deployPolicy) || (has(self.initProvider) && has(self.initProvider.deployPolicy))",message="spec.forProvider.deployPolicy is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.instanceTemplate) || (has(self.initProvider) && has(self.initProvider.instanceTemplate))",message="spec.forProvider.instanceTemplate is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.scalePolicy) || (has(self.initProvider) && has(self.initProvider.scalePolicy))",message="spec.forProvider.scalePolicy is a required parameter"
	Spec   InstanceGroupSpec   `json:"spec"`
	Status InstanceGroupStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// InstanceGroupList contains a list of InstanceGroups
type InstanceGroupList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []InstanceGroup `json:"items"`
}

// Repository type metadata.
var (
	InstanceGroup_Kind             = "InstanceGroup"
	InstanceGroup_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: InstanceGroup_Kind}.String()
	InstanceGroup_KindAPIVersion   = InstanceGroup_Kind + "." + CRDGroupVersion.String()
	InstanceGroup_GroupVersionKind = CRDGroupVersion.WithKind(InstanceGroup_Kind)
)

func init() {
	SchemeBuilder.Register(&InstanceGroup{}, &InstanceGroupList{})
}
