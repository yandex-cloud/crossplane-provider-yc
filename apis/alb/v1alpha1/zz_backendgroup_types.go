/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type BackendGroupObservation struct {

	// The backend group creation timestamp.
	CreatedAt *string `json:"createdAt,omitempty" tf:"created_at,omitempty"`

	// Description of the backend group.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// Folder that the resource belongs to. If value is omitted, the default provider folder is used.
	FolderID *string `json:"folderId,omitempty" tf:"folder_id,omitempty"`

	// Grpc backend specification that will be used by the ALB Backend Group. Structure is documented below.
	GRPCBackend []GRPCBackendObservation `json:"grpcBackend,omitempty" tf:"grpc_backend,omitempty"`

	// Http backend specification that will be used by the ALB Backend Group. Structure is documented below.
	HTTPBackend []HTTPBackendObservation `json:"httpBackend,omitempty" tf:"http_backend,omitempty"`

	// The ID of the backend group.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// Labels to assign to this backend group.
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// Name of the Backend Group.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	SessionAffinity []SessionAffinityObservation `json:"sessionAffinity,omitempty" tf:"session_affinity,omitempty"`

	// Stream backend specification that will be used by the ALB Backend Group. Structure is documented below.
	StreamBackend []StreamBackendObservation `json:"streamBackend,omitempty" tf:"stream_backend,omitempty"`
}

type BackendGroupParameters struct {

	// Description of the backend group.
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// Folder that the resource belongs to. If value is omitted, the default provider folder is used.
	// +crossplane:generate:reference:type=github.com/yandex-cloud/provider-jet-yc/apis/resourcemanager/v1alpha1.Folder
	// +kubebuilder:validation:Optional
	FolderID *string `json:"folderId,omitempty" tf:"folder_id,omitempty"`

	// Reference to a Folder in resourcemanager to populate folderId.
	// +kubebuilder:validation:Optional
	FolderIDRef *v1.Reference `json:"folderIdRef,omitempty" tf:"-"`

	// Selector for a Folder in resourcemanager to populate folderId.
	// +kubebuilder:validation:Optional
	FolderIDSelector *v1.Selector `json:"folderIdSelector,omitempty" tf:"-"`

	// Grpc backend specification that will be used by the ALB Backend Group. Structure is documented below.
	// +kubebuilder:validation:Optional
	GRPCBackend []GRPCBackendParameters `json:"grpcBackend,omitempty" tf:"grpc_backend,omitempty"`

	// Http backend specification that will be used by the ALB Backend Group. Structure is documented below.
	// +kubebuilder:validation:Optional
	HTTPBackend []HTTPBackendParameters `json:"httpBackend,omitempty" tf:"http_backend,omitempty"`

	// Labels to assign to this backend group.
	// +kubebuilder:validation:Optional
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// Name of the Backend Group.
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	SessionAffinity []SessionAffinityParameters `json:"sessionAffinity,omitempty" tf:"session_affinity,omitempty"`

	// Stream backend specification that will be used by the ALB Backend Group. Structure is documented below.
	// +kubebuilder:validation:Optional
	StreamBackend []StreamBackendParameters `json:"streamBackend,omitempty" tf:"stream_backend,omitempty"`
}

type ConnectionObservation struct {

	// Use source IP address
	SourceIP *bool `json:"sourceIp,omitempty" tf:"source_ip,omitempty"`
}

type ConnectionParameters struct {

	// Use source IP address
	// +kubebuilder:validation:Optional
	SourceIP *bool `json:"sourceIp,omitempty" tf:"source_ip,omitempty"`
}

type CookieObservation struct {

	// Name of the backend.
	// Name of the HTTP cookie
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// TTL for the cookie (if not set, session cookie will be used)
	TTL *string `json:"ttl,omitempty" tf:"ttl,omitempty"`
}

type CookieParameters struct {

	// Name of the backend.
	// Name of the HTTP cookie
	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// TTL for the cookie (if not set, session cookie will be used)
	// +kubebuilder:validation:Optional
	TTL *string `json:"ttl,omitempty" tf:"ttl,omitempty"`
}

type GRPCBackendObservation struct {

	// Healthcheck specification that will be used by this backend. Structure is documented below.
	Healthcheck []HealthcheckObservation `json:"healthcheck,omitempty" tf:"healthcheck,omitempty"`

	// Load Balancing Config specification that will be used by this backend. Structure is documented below.
	LoadBalancingConfig []LoadBalancingConfigObservation `json:"loadBalancingConfig,omitempty" tf:"load_balancing_config,omitempty"`

	// Name of the backend.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Port for incoming traffic.
	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`

	// Tls specification that will be used by this backend. Structure is documented below.
	TLS []TLSObservation `json:"tls,omitempty" tf:"tls,omitempty"`

	// References target groups for the backend.
	TargetGroupIds []*string `json:"targetGroupIds,omitempty" tf:"target_group_ids,omitempty"`

	// Weight of the backend. Traffic will be split between backends of the same BackendGroup according to their weights.
	Weight *float64 `json:"weight,omitempty" tf:"weight,omitempty"`
}

type GRPCBackendParameters struct {

	// Healthcheck specification that will be used by this backend. Structure is documented below.
	// +kubebuilder:validation:Optional
	Healthcheck []HealthcheckParameters `json:"healthcheck,omitempty" tf:"healthcheck,omitempty"`

	// Load Balancing Config specification that will be used by this backend. Structure is documented below.
	// +kubebuilder:validation:Optional
	LoadBalancingConfig []LoadBalancingConfigParameters `json:"loadBalancingConfig,omitempty" tf:"load_balancing_config,omitempty"`

	// Name of the backend.
	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// Port for incoming traffic.
	// +kubebuilder:validation:Optional
	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`

	// Tls specification that will be used by this backend. Structure is documented below.
	// +kubebuilder:validation:Optional
	TLS []TLSParameters `json:"tls,omitempty" tf:"tls,omitempty"`

	// References target groups for the backend.
	// +crossplane:generate:reference:type=TargetGroup
	// +kubebuilder:validation:Optional
	TargetGroupIds []*string `json:"targetGroupIds,omitempty" tf:"target_group_ids,omitempty"`

	// References to TargetGroup to populate targetGroupIds.
	// +kubebuilder:validation:Optional
	TargetGroupIdsRefs []v1.Reference `json:"targetGroupIdsRefs,omitempty" tf:"-"`

	// Selector for a list of TargetGroup to populate targetGroupIds.
	// +kubebuilder:validation:Optional
	TargetGroupIdsSelector *v1.Selector `json:"targetGroupIdsSelector,omitempty" tf:"-"`

	// Weight of the backend. Traffic will be split between backends of the same BackendGroup according to their weights.
	// +kubebuilder:validation:Optional
	Weight *float64 `json:"weight,omitempty" tf:"weight,omitempty"`
}

type GRPCHealthcheckObservation struct {

	// Service name for grpc.health.v1.HealthCheckRequest message.
	ServiceName *string `json:"serviceName,omitempty" tf:"service_name,omitempty"`
}

type GRPCHealthcheckParameters struct {

	// Service name for grpc.health.v1.HealthCheckRequest message.
	// +kubebuilder:validation:Optional
	ServiceName *string `json:"serviceName,omitempty" tf:"service_name,omitempty"`
}

type HTTPBackendHealthcheckObservation struct {

	// Grpc Healthcheck specification that will be used by this healthcheck. Structure is documented below.
	GRPCHealthcheck []HealthcheckGRPCHealthcheckObservation `json:"grpcHealthcheck,omitempty" tf:"grpc_healthcheck,omitempty"`

	// Http Healthcheck specification that will be used by this healthcheck. Structure is documented below.
	HTTPHealthcheck []HealthcheckHTTPHealthcheckObservation `json:"httpHealthcheck,omitempty" tf:"http_healthcheck,omitempty"`

	// Optional alternative port for health checking.
	HealthcheckPort *float64 `json:"healthcheckPort,omitempty" tf:"healthcheck_port,omitempty"`

	// Number of consecutive successful health checks required to promote endpoint into the healthy state. 0 means 1. Note that during startup, only a single successful health check is required to mark a host healthy.
	HealthyThreshold *float64 `json:"healthyThreshold,omitempty" tf:"healthy_threshold,omitempty"`

	// Interval between health checks.
	Interval *string `json:"interval,omitempty" tf:"interval,omitempty"`

	// An optional jitter amount as a percentage of interval. If specified, during every interval value of (interval_ms * interval_jitter_percent / 100) will be added to the wait time.
	IntervalJitterPercent *float64 `json:"intervalJitterPercent,omitempty" tf:"interval_jitter_percent,omitempty"`

	// Stream Healthcheck specification that will be used by this healthcheck. Structure is documented below.
	StreamHealthcheck []HealthcheckStreamHealthcheckObservation `json:"streamHealthcheck,omitempty" tf:"stream_healthcheck,omitempty"`

	// Time to wait for a health check response.
	Timeout *string `json:"timeout,omitempty" tf:"timeout,omitempty"`

	// Number of consecutive failed health checks required to demote endpoint into the unhealthy state. 0 means 1. Note that for HTTP health checks, a single 503 immediately makes endpoint unhealthy.
	UnhealthyThreshold *float64 `json:"unhealthyThreshold,omitempty" tf:"unhealthy_threshold,omitempty"`
}

type HTTPBackendHealthcheckParameters struct {

	// Grpc Healthcheck specification that will be used by this healthcheck. Structure is documented below.
	// +kubebuilder:validation:Optional
	GRPCHealthcheck []HealthcheckGRPCHealthcheckParameters `json:"grpcHealthcheck,omitempty" tf:"grpc_healthcheck,omitempty"`

	// Http Healthcheck specification that will be used by this healthcheck. Structure is documented below.
	// +kubebuilder:validation:Optional
	HTTPHealthcheck []HealthcheckHTTPHealthcheckParameters `json:"httpHealthcheck,omitempty" tf:"http_healthcheck,omitempty"`

	// Optional alternative port for health checking.
	// +kubebuilder:validation:Optional
	HealthcheckPort *float64 `json:"healthcheckPort,omitempty" tf:"healthcheck_port,omitempty"`

	// Number of consecutive successful health checks required to promote endpoint into the healthy state. 0 means 1. Note that during startup, only a single successful health check is required to mark a host healthy.
	// +kubebuilder:validation:Optional
	HealthyThreshold *float64 `json:"healthyThreshold,omitempty" tf:"healthy_threshold,omitempty"`

	// Interval between health checks.
	// +kubebuilder:validation:Required
	Interval *string `json:"interval" tf:"interval,omitempty"`

	// An optional jitter amount as a percentage of interval. If specified, during every interval value of (interval_ms * interval_jitter_percent / 100) will be added to the wait time.
	// +kubebuilder:validation:Optional
	IntervalJitterPercent *float64 `json:"intervalJitterPercent,omitempty" tf:"interval_jitter_percent,omitempty"`

	// Stream Healthcheck specification that will be used by this healthcheck. Structure is documented below.
	// +kubebuilder:validation:Optional
	StreamHealthcheck []HealthcheckStreamHealthcheckParameters `json:"streamHealthcheck,omitempty" tf:"stream_healthcheck,omitempty"`

	// Time to wait for a health check response.
	// +kubebuilder:validation:Required
	Timeout *string `json:"timeout" tf:"timeout,omitempty"`

	// Number of consecutive failed health checks required to demote endpoint into the unhealthy state. 0 means 1. Note that for HTTP health checks, a single 503 immediately makes endpoint unhealthy.
	// +kubebuilder:validation:Optional
	UnhealthyThreshold *float64 `json:"unhealthyThreshold,omitempty" tf:"unhealthy_threshold,omitempty"`
}

type HTTPBackendLoadBalancingConfigObservation struct {

	// Percent of traffic to be sent to the same availability zone. The rest will be equally divided between other zones.
	LocalityAwareRoutingPercent *float64 `json:"localityAwareRoutingPercent,omitempty" tf:"locality_aware_routing_percent,omitempty"`

	// Load balancing mode for the backend. Possible values: "ROUND_ROBIN", "RANDOM", "LEAST_REQUEST", "MAGLEV_HASH".
	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`

	// If percentage of healthy hosts in the backend is lower than panic_threshold, traffic will be routed to all backends no matter what the health status is. This helps to avoid healthy backends overloading  when everything is bad. Zero means no panic threshold.
	PanicThreshold *float64 `json:"panicThreshold,omitempty" tf:"panic_threshold,omitempty"`

	// If set, will route requests only to the same availability zone. Balancer won't know about endpoints in other zones.
	StrictLocality *bool `json:"strictLocality,omitempty" tf:"strict_locality,omitempty"`
}

type HTTPBackendLoadBalancingConfigParameters struct {

	// Percent of traffic to be sent to the same availability zone. The rest will be equally divided between other zones.
	// +kubebuilder:validation:Optional
	LocalityAwareRoutingPercent *float64 `json:"localityAwareRoutingPercent,omitempty" tf:"locality_aware_routing_percent,omitempty"`

	// Load balancing mode for the backend. Possible values: "ROUND_ROBIN", "RANDOM", "LEAST_REQUEST", "MAGLEV_HASH".
	// +kubebuilder:validation:Optional
	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`

	// If percentage of healthy hosts in the backend is lower than panic_threshold, traffic will be routed to all backends no matter what the health status is. This helps to avoid healthy backends overloading  when everything is bad. Zero means no panic threshold.
	// +kubebuilder:validation:Optional
	PanicThreshold *float64 `json:"panicThreshold,omitempty" tf:"panic_threshold,omitempty"`

	// If set, will route requests only to the same availability zone. Balancer won't know about endpoints in other zones.
	// +kubebuilder:validation:Optional
	StrictLocality *bool `json:"strictLocality,omitempty" tf:"strict_locality,omitempty"`
}

type HTTPBackendObservation struct {

	// Healthcheck specification that will be used by this backend. Structure is documented below.
	Healthcheck []HTTPBackendHealthcheckObservation `json:"healthcheck,omitempty" tf:"healthcheck,omitempty"`

	// Enables HTTP2 for upstream requests. If not set, HTTP 1.1 will be used by default.
	Http2 *bool `json:"http2,omitempty" tf:"http2,omitempty"`

	// Load Balancing Config specification that will be used by this backend. Structure is documented below.
	LoadBalancingConfig []HTTPBackendLoadBalancingConfigObservation `json:"loadBalancingConfig,omitempty" tf:"load_balancing_config,omitempty"`

	// Name of the backend.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Port for incoming traffic.
	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`

	StorageBucket *string `json:"storageBucket,omitempty" tf:"storage_bucket,omitempty"`

	// Tls specification that will be used by this backend. Structure is documented below.
	TLS []HTTPBackendTLSObservation `json:"tls,omitempty" tf:"tls,omitempty"`

	// References target groups for the backend.
	TargetGroupIds []*string `json:"targetGroupIds,omitempty" tf:"target_group_ids,omitempty"`

	// Weight of the backend. Traffic will be split between backends of the same BackendGroup according to their weights.
	Weight *float64 `json:"weight,omitempty" tf:"weight,omitempty"`
}

type HTTPBackendParameters struct {

	// Healthcheck specification that will be used by this backend. Structure is documented below.
	// +kubebuilder:validation:Optional
	Healthcheck []HTTPBackendHealthcheckParameters `json:"healthcheck,omitempty" tf:"healthcheck,omitempty"`

	// Enables HTTP2 for upstream requests. If not set, HTTP 1.1 will be used by default.
	// +kubebuilder:validation:Optional
	Http2 *bool `json:"http2,omitempty" tf:"http2,omitempty"`

	// Load Balancing Config specification that will be used by this backend. Structure is documented below.
	// +kubebuilder:validation:Optional
	LoadBalancingConfig []HTTPBackendLoadBalancingConfigParameters `json:"loadBalancingConfig,omitempty" tf:"load_balancing_config,omitempty"`

	// Name of the backend.
	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// Port for incoming traffic.
	// +kubebuilder:validation:Optional
	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`

	// +kubebuilder:validation:Optional
	StorageBucket *string `json:"storageBucket,omitempty" tf:"storage_bucket,omitempty"`

	// Tls specification that will be used by this backend. Structure is documented below.
	// +kubebuilder:validation:Optional
	TLS []HTTPBackendTLSParameters `json:"tls,omitempty" tf:"tls,omitempty"`

	// References target groups for the backend.
	// +crossplane:generate:reference:type=TargetGroup
	// +kubebuilder:validation:Optional
	TargetGroupIds []*string `json:"targetGroupIds,omitempty" tf:"target_group_ids,omitempty"`

	// References to TargetGroup to populate targetGroupIds.
	// +kubebuilder:validation:Optional
	TargetGroupIdsRefs []v1.Reference `json:"targetGroupIdsRefs,omitempty" tf:"-"`

	// Selector for a list of TargetGroup to populate targetGroupIds.
	// +kubebuilder:validation:Optional
	TargetGroupIdsSelector *v1.Selector `json:"targetGroupIdsSelector,omitempty" tf:"-"`

	// Weight of the backend. Traffic will be split between backends of the same BackendGroup according to their weights.
	// +kubebuilder:validation:Optional
	Weight *float64 `json:"weight,omitempty" tf:"weight,omitempty"`
}

type HTTPBackendTLSObservation struct {

	// SNI string for TLS connections.
	Sni *string `json:"sni,omitempty" tf:"sni,omitempty"`

	ValidationContext []TLSValidationContextObservation `json:"validationContext,omitempty" tf:"validation_context,omitempty"`
}

type HTTPBackendTLSParameters struct {

	// SNI string for TLS connections.
	// +kubebuilder:validation:Optional
	Sni *string `json:"sni,omitempty" tf:"sni,omitempty"`

	// +kubebuilder:validation:Optional
	ValidationContext []TLSValidationContextParameters `json:"validationContext,omitempty" tf:"validation_context,omitempty"`
}

type HTTPHealthcheckObservation struct {

	// "Host" HTTP header value.
	Host *string `json:"host,omitempty" tf:"host,omitempty"`

	// If set, health checks will use HTTP2.
	Http2 *bool `json:"http2,omitempty" tf:"http2,omitempty"`

	// HTTP path.
	Path *string `json:"path,omitempty" tf:"path,omitempty"`
}

type HTTPHealthcheckParameters struct {

	// "Host" HTTP header value.
	// +kubebuilder:validation:Optional
	Host *string `json:"host,omitempty" tf:"host,omitempty"`

	// If set, health checks will use HTTP2.
	// +kubebuilder:validation:Optional
	Http2 *bool `json:"http2,omitempty" tf:"http2,omitempty"`

	// HTTP path.
	// +kubebuilder:validation:Required
	Path *string `json:"path" tf:"path,omitempty"`
}

type HeaderObservation struct {

	// Name of the Backend Group.
	// The name of the request header that will be used
	HeaderName *string `json:"headerName,omitempty" tf:"header_name,omitempty"`
}

type HeaderParameters struct {

	// Name of the Backend Group.
	// The name of the request header that will be used
	// +kubebuilder:validation:Required
	HeaderName *string `json:"headerName" tf:"header_name,omitempty"`
}

type HealthcheckGRPCHealthcheckObservation struct {

	// Service name for grpc.health.v1.HealthCheckRequest message.
	ServiceName *string `json:"serviceName,omitempty" tf:"service_name,omitempty"`
}

type HealthcheckGRPCHealthcheckParameters struct {

	// Service name for grpc.health.v1.HealthCheckRequest message.
	// +kubebuilder:validation:Optional
	ServiceName *string `json:"serviceName,omitempty" tf:"service_name,omitempty"`
}

type HealthcheckHTTPHealthcheckObservation struct {

	// "Host" HTTP header value.
	Host *string `json:"host,omitempty" tf:"host,omitempty"`

	// If set, health checks will use HTTP2.
	Http2 *bool `json:"http2,omitempty" tf:"http2,omitempty"`

	// HTTP path.
	Path *string `json:"path,omitempty" tf:"path,omitempty"`
}

type HealthcheckHTTPHealthcheckParameters struct {

	// "Host" HTTP header value.
	// +kubebuilder:validation:Optional
	Host *string `json:"host,omitempty" tf:"host,omitempty"`

	// If set, health checks will use HTTP2.
	// +kubebuilder:validation:Optional
	Http2 *bool `json:"http2,omitempty" tf:"http2,omitempty"`

	// HTTP path.
	// +kubebuilder:validation:Required
	Path *string `json:"path" tf:"path,omitempty"`
}

type HealthcheckObservation struct {

	// Grpc Healthcheck specification that will be used by this healthcheck. Structure is documented below.
	GRPCHealthcheck []GRPCHealthcheckObservation `json:"grpcHealthcheck,omitempty" tf:"grpc_healthcheck,omitempty"`

	// Http Healthcheck specification that will be used by this healthcheck. Structure is documented below.
	HTTPHealthcheck []HTTPHealthcheckObservation `json:"httpHealthcheck,omitempty" tf:"http_healthcheck,omitempty"`

	// Optional alternative port for health checking.
	HealthcheckPort *float64 `json:"healthcheckPort,omitempty" tf:"healthcheck_port,omitempty"`

	// Number of consecutive successful health checks required to promote endpoint into the healthy state. 0 means 1. Note that during startup, only a single successful health check is required to mark a host healthy.
	HealthyThreshold *float64 `json:"healthyThreshold,omitempty" tf:"healthy_threshold,omitempty"`

	// Interval between health checks.
	Interval *string `json:"interval,omitempty" tf:"interval,omitempty"`

	// An optional jitter amount as a percentage of interval. If specified, during every interval value of (interval_ms * interval_jitter_percent / 100) will be added to the wait time.
	IntervalJitterPercent *float64 `json:"intervalJitterPercent,omitempty" tf:"interval_jitter_percent,omitempty"`

	// Stream Healthcheck specification that will be used by this healthcheck. Structure is documented below.
	StreamHealthcheck []StreamHealthcheckObservation `json:"streamHealthcheck,omitempty" tf:"stream_healthcheck,omitempty"`

	// Time to wait for a health check response.
	Timeout *string `json:"timeout,omitempty" tf:"timeout,omitempty"`

	// Number of consecutive failed health checks required to demote endpoint into the unhealthy state. 0 means 1. Note that for HTTP health checks, a single 503 immediately makes endpoint unhealthy.
	UnhealthyThreshold *float64 `json:"unhealthyThreshold,omitempty" tf:"unhealthy_threshold,omitempty"`
}

type HealthcheckParameters struct {

	// Grpc Healthcheck specification that will be used by this healthcheck. Structure is documented below.
	// +kubebuilder:validation:Optional
	GRPCHealthcheck []GRPCHealthcheckParameters `json:"grpcHealthcheck,omitempty" tf:"grpc_healthcheck,omitempty"`

	// Http Healthcheck specification that will be used by this healthcheck. Structure is documented below.
	// +kubebuilder:validation:Optional
	HTTPHealthcheck []HTTPHealthcheckParameters `json:"httpHealthcheck,omitempty" tf:"http_healthcheck,omitempty"`

	// Optional alternative port for health checking.
	// +kubebuilder:validation:Optional
	HealthcheckPort *float64 `json:"healthcheckPort,omitempty" tf:"healthcheck_port,omitempty"`

	// Number of consecutive successful health checks required to promote endpoint into the healthy state. 0 means 1. Note that during startup, only a single successful health check is required to mark a host healthy.
	// +kubebuilder:validation:Optional
	HealthyThreshold *float64 `json:"healthyThreshold,omitempty" tf:"healthy_threshold,omitempty"`

	// Interval between health checks.
	// +kubebuilder:validation:Required
	Interval *string `json:"interval" tf:"interval,omitempty"`

	// An optional jitter amount as a percentage of interval. If specified, during every interval value of (interval_ms * interval_jitter_percent / 100) will be added to the wait time.
	// +kubebuilder:validation:Optional
	IntervalJitterPercent *float64 `json:"intervalJitterPercent,omitempty" tf:"interval_jitter_percent,omitempty"`

	// Stream Healthcheck specification that will be used by this healthcheck. Structure is documented below.
	// +kubebuilder:validation:Optional
	StreamHealthcheck []StreamHealthcheckParameters `json:"streamHealthcheck,omitempty" tf:"stream_healthcheck,omitempty"`

	// Time to wait for a health check response.
	// +kubebuilder:validation:Required
	Timeout *string `json:"timeout" tf:"timeout,omitempty"`

	// Number of consecutive failed health checks required to demote endpoint into the unhealthy state. 0 means 1. Note that for HTTP health checks, a single 503 immediately makes endpoint unhealthy.
	// +kubebuilder:validation:Optional
	UnhealthyThreshold *float64 `json:"unhealthyThreshold,omitempty" tf:"unhealthy_threshold,omitempty"`
}

type HealthcheckStreamHealthcheckObservation struct {

	// Data that must be contained in the messages received from targets for a successful health check. If not specified, no messages are expected from targets, and those that are received are not checked.
	Receive *string `json:"receive,omitempty" tf:"receive,omitempty"`

	// Message sent to targets during TCP data transfer.  If not specified, no data is sent to the target.
	Send *string `json:"send,omitempty" tf:"send,omitempty"`
}

type HealthcheckStreamHealthcheckParameters struct {

	// Data that must be contained in the messages received from targets for a successful health check. If not specified, no messages are expected from targets, and those that are received are not checked.
	// +kubebuilder:validation:Optional
	Receive *string `json:"receive,omitempty" tf:"receive,omitempty"`

	// Message sent to targets during TCP data transfer.  If not specified, no data is sent to the target.
	// +kubebuilder:validation:Optional
	Send *string `json:"send,omitempty" tf:"send,omitempty"`
}

type LoadBalancingConfigObservation struct {

	// Percent of traffic to be sent to the same availability zone. The rest will be equally divided between other zones.
	LocalityAwareRoutingPercent *float64 `json:"localityAwareRoutingPercent,omitempty" tf:"locality_aware_routing_percent,omitempty"`

	// Load balancing mode for the backend. Possible values: "ROUND_ROBIN", "RANDOM", "LEAST_REQUEST", "MAGLEV_HASH".
	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`

	// If percentage of healthy hosts in the backend is lower than panic_threshold, traffic will be routed to all backends no matter what the health status is. This helps to avoid healthy backends overloading  when everything is bad. Zero means no panic threshold.
	PanicThreshold *float64 `json:"panicThreshold,omitempty" tf:"panic_threshold,omitempty"`

	// If set, will route requests only to the same availability zone. Balancer won't know about endpoints in other zones.
	StrictLocality *bool `json:"strictLocality,omitempty" tf:"strict_locality,omitempty"`
}

type LoadBalancingConfigParameters struct {

	// Percent of traffic to be sent to the same availability zone. The rest will be equally divided between other zones.
	// +kubebuilder:validation:Optional
	LocalityAwareRoutingPercent *float64 `json:"localityAwareRoutingPercent,omitempty" tf:"locality_aware_routing_percent,omitempty"`

	// Load balancing mode for the backend. Possible values: "ROUND_ROBIN", "RANDOM", "LEAST_REQUEST", "MAGLEV_HASH".
	// +kubebuilder:validation:Optional
	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`

	// If percentage of healthy hosts in the backend is lower than panic_threshold, traffic will be routed to all backends no matter what the health status is. This helps to avoid healthy backends overloading  when everything is bad. Zero means no panic threshold.
	// +kubebuilder:validation:Optional
	PanicThreshold *float64 `json:"panicThreshold,omitempty" tf:"panic_threshold,omitempty"`

	// If set, will route requests only to the same availability zone. Balancer won't know about endpoints in other zones.
	// +kubebuilder:validation:Optional
	StrictLocality *bool `json:"strictLocality,omitempty" tf:"strict_locality,omitempty"`
}

type SessionAffinityObservation struct {

	// IP address affinity
	Connection []ConnectionObservation `json:"connection,omitempty" tf:"connection,omitempty"`

	// Cookie affinity
	Cookie []CookieObservation `json:"cookie,omitempty" tf:"cookie,omitempty"`

	// Request header affinity
	Header []HeaderObservation `json:"header,omitempty" tf:"header,omitempty"`
}

type SessionAffinityParameters struct {

	// IP address affinity
	// +kubebuilder:validation:Optional
	Connection []ConnectionParameters `json:"connection,omitempty" tf:"connection,omitempty"`

	// Cookie affinity
	// +kubebuilder:validation:Optional
	Cookie []CookieParameters `json:"cookie,omitempty" tf:"cookie,omitempty"`

	// Request header affinity
	// +kubebuilder:validation:Optional
	Header []HeaderParameters `json:"header,omitempty" tf:"header,omitempty"`
}

type StreamBackendHealthcheckGRPCHealthcheckObservation struct {

	// Service name for grpc.health.v1.HealthCheckRequest message.
	ServiceName *string `json:"serviceName,omitempty" tf:"service_name,omitempty"`
}

type StreamBackendHealthcheckGRPCHealthcheckParameters struct {

	// Service name for grpc.health.v1.HealthCheckRequest message.
	// +kubebuilder:validation:Optional
	ServiceName *string `json:"serviceName,omitempty" tf:"service_name,omitempty"`
}

type StreamBackendHealthcheckHTTPHealthcheckObservation struct {

	// "Host" HTTP header value.
	Host *string `json:"host,omitempty" tf:"host,omitempty"`

	// If set, health checks will use HTTP2.
	Http2 *bool `json:"http2,omitempty" tf:"http2,omitempty"`

	// HTTP path.
	Path *string `json:"path,omitempty" tf:"path,omitempty"`
}

type StreamBackendHealthcheckHTTPHealthcheckParameters struct {

	// "Host" HTTP header value.
	// +kubebuilder:validation:Optional
	Host *string `json:"host,omitempty" tf:"host,omitempty"`

	// If set, health checks will use HTTP2.
	// +kubebuilder:validation:Optional
	Http2 *bool `json:"http2,omitempty" tf:"http2,omitempty"`

	// HTTP path.
	// +kubebuilder:validation:Required
	Path *string `json:"path" tf:"path,omitempty"`
}

type StreamBackendHealthcheckObservation struct {

	// Grpc Healthcheck specification that will be used by this healthcheck. Structure is documented below.
	GRPCHealthcheck []StreamBackendHealthcheckGRPCHealthcheckObservation `json:"grpcHealthcheck,omitempty" tf:"grpc_healthcheck,omitempty"`

	// Http Healthcheck specification that will be used by this healthcheck. Structure is documented below.
	HTTPHealthcheck []StreamBackendHealthcheckHTTPHealthcheckObservation `json:"httpHealthcheck,omitempty" tf:"http_healthcheck,omitempty"`

	// Optional alternative port for health checking.
	HealthcheckPort *float64 `json:"healthcheckPort,omitempty" tf:"healthcheck_port,omitempty"`

	// Number of consecutive successful health checks required to promote endpoint into the healthy state. 0 means 1. Note that during startup, only a single successful health check is required to mark a host healthy.
	HealthyThreshold *float64 `json:"healthyThreshold,omitempty" tf:"healthy_threshold,omitempty"`

	// Interval between health checks.
	Interval *string `json:"interval,omitempty" tf:"interval,omitempty"`

	// An optional jitter amount as a percentage of interval. If specified, during every interval value of (interval_ms * interval_jitter_percent / 100) will be added to the wait time.
	IntervalJitterPercent *float64 `json:"intervalJitterPercent,omitempty" tf:"interval_jitter_percent,omitempty"`

	// Stream Healthcheck specification that will be used by this healthcheck. Structure is documented below.
	StreamHealthcheck []StreamBackendHealthcheckStreamHealthcheckObservation `json:"streamHealthcheck,omitempty" tf:"stream_healthcheck,omitempty"`

	// Time to wait for a health check response.
	Timeout *string `json:"timeout,omitempty" tf:"timeout,omitempty"`

	// Number of consecutive failed health checks required to demote endpoint into the unhealthy state. 0 means 1. Note that for HTTP health checks, a single 503 immediately makes endpoint unhealthy.
	UnhealthyThreshold *float64 `json:"unhealthyThreshold,omitempty" tf:"unhealthy_threshold,omitempty"`
}

type StreamBackendHealthcheckParameters struct {

	// Grpc Healthcheck specification that will be used by this healthcheck. Structure is documented below.
	// +kubebuilder:validation:Optional
	GRPCHealthcheck []StreamBackendHealthcheckGRPCHealthcheckParameters `json:"grpcHealthcheck,omitempty" tf:"grpc_healthcheck,omitempty"`

	// Http Healthcheck specification that will be used by this healthcheck. Structure is documented below.
	// +kubebuilder:validation:Optional
	HTTPHealthcheck []StreamBackendHealthcheckHTTPHealthcheckParameters `json:"httpHealthcheck,omitempty" tf:"http_healthcheck,omitempty"`

	// Optional alternative port for health checking.
	// +kubebuilder:validation:Optional
	HealthcheckPort *float64 `json:"healthcheckPort,omitempty" tf:"healthcheck_port,omitempty"`

	// Number of consecutive successful health checks required to promote endpoint into the healthy state. 0 means 1. Note that during startup, only a single successful health check is required to mark a host healthy.
	// +kubebuilder:validation:Optional
	HealthyThreshold *float64 `json:"healthyThreshold,omitempty" tf:"healthy_threshold,omitempty"`

	// Interval between health checks.
	// +kubebuilder:validation:Required
	Interval *string `json:"interval" tf:"interval,omitempty"`

	// An optional jitter amount as a percentage of interval. If specified, during every interval value of (interval_ms * interval_jitter_percent / 100) will be added to the wait time.
	// +kubebuilder:validation:Optional
	IntervalJitterPercent *float64 `json:"intervalJitterPercent,omitempty" tf:"interval_jitter_percent,omitempty"`

	// Stream Healthcheck specification that will be used by this healthcheck. Structure is documented below.
	// +kubebuilder:validation:Optional
	StreamHealthcheck []StreamBackendHealthcheckStreamHealthcheckParameters `json:"streamHealthcheck,omitempty" tf:"stream_healthcheck,omitempty"`

	// Time to wait for a health check response.
	// +kubebuilder:validation:Required
	Timeout *string `json:"timeout" tf:"timeout,omitempty"`

	// Number of consecutive failed health checks required to demote endpoint into the unhealthy state. 0 means 1. Note that for HTTP health checks, a single 503 immediately makes endpoint unhealthy.
	// +kubebuilder:validation:Optional
	UnhealthyThreshold *float64 `json:"unhealthyThreshold,omitempty" tf:"unhealthy_threshold,omitempty"`
}

type StreamBackendHealthcheckStreamHealthcheckObservation struct {

	// Data that must be contained in the messages received from targets for a successful health check. If not specified, no messages are expected from targets, and those that are received are not checked.
	Receive *string `json:"receive,omitempty" tf:"receive,omitempty"`

	// Message sent to targets during TCP data transfer.  If not specified, no data is sent to the target.
	Send *string `json:"send,omitempty" tf:"send,omitempty"`
}

type StreamBackendHealthcheckStreamHealthcheckParameters struct {

	// Data that must be contained in the messages received from targets for a successful health check. If not specified, no messages are expected from targets, and those that are received are not checked.
	// +kubebuilder:validation:Optional
	Receive *string `json:"receive,omitempty" tf:"receive,omitempty"`

	// Message sent to targets during TCP data transfer.  If not specified, no data is sent to the target.
	// +kubebuilder:validation:Optional
	Send *string `json:"send,omitempty" tf:"send,omitempty"`
}

type StreamBackendLoadBalancingConfigObservation struct {

	// Percent of traffic to be sent to the same availability zone. The rest will be equally divided between other zones.
	LocalityAwareRoutingPercent *float64 `json:"localityAwareRoutingPercent,omitempty" tf:"locality_aware_routing_percent,omitempty"`

	// Load balancing mode for the backend. Possible values: "ROUND_ROBIN", "RANDOM", "LEAST_REQUEST", "MAGLEV_HASH".
	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`

	// If percentage of healthy hosts in the backend is lower than panic_threshold, traffic will be routed to all backends no matter what the health status is. This helps to avoid healthy backends overloading  when everything is bad. Zero means no panic threshold.
	PanicThreshold *float64 `json:"panicThreshold,omitempty" tf:"panic_threshold,omitempty"`

	// If set, will route requests only to the same availability zone. Balancer won't know about endpoints in other zones.
	StrictLocality *bool `json:"strictLocality,omitempty" tf:"strict_locality,omitempty"`
}

type StreamBackendLoadBalancingConfigParameters struct {

	// Percent of traffic to be sent to the same availability zone. The rest will be equally divided between other zones.
	// +kubebuilder:validation:Optional
	LocalityAwareRoutingPercent *float64 `json:"localityAwareRoutingPercent,omitempty" tf:"locality_aware_routing_percent,omitempty"`

	// Load balancing mode for the backend. Possible values: "ROUND_ROBIN", "RANDOM", "LEAST_REQUEST", "MAGLEV_HASH".
	// +kubebuilder:validation:Optional
	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`

	// If percentage of healthy hosts in the backend is lower than panic_threshold, traffic will be routed to all backends no matter what the health status is. This helps to avoid healthy backends overloading  when everything is bad. Zero means no panic threshold.
	// +kubebuilder:validation:Optional
	PanicThreshold *float64 `json:"panicThreshold,omitempty" tf:"panic_threshold,omitempty"`

	// If set, will route requests only to the same availability zone. Balancer won't know about endpoints in other zones.
	// +kubebuilder:validation:Optional
	StrictLocality *bool `json:"strictLocality,omitempty" tf:"strict_locality,omitempty"`
}

type StreamBackendObservation struct {
	EnableProxyProtocol *bool `json:"enableProxyProtocol,omitempty" tf:"enable_proxy_protocol,omitempty"`

	// Healthcheck specification that will be used by this backend. Structure is documented below.
	Healthcheck []StreamBackendHealthcheckObservation `json:"healthcheck,omitempty" tf:"healthcheck,omitempty"`

	// Load Balancing Config specification that will be used by this backend. Structure is documented below.
	LoadBalancingConfig []StreamBackendLoadBalancingConfigObservation `json:"loadBalancingConfig,omitempty" tf:"load_balancing_config,omitempty"`

	// Name of the backend.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Port for incoming traffic.
	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`

	// Tls specification that will be used by this backend. Structure is documented below.
	TLS []StreamBackendTLSObservation `json:"tls,omitempty" tf:"tls,omitempty"`

	// References target groups for the backend.
	TargetGroupIds []*string `json:"targetGroupIds,omitempty" tf:"target_group_ids,omitempty"`

	// Weight of the backend. Traffic will be split between backends of the same BackendGroup according to their weights.
	Weight *float64 `json:"weight,omitempty" tf:"weight,omitempty"`
}

type StreamBackendParameters struct {

	// +kubebuilder:validation:Optional
	EnableProxyProtocol *bool `json:"enableProxyProtocol,omitempty" tf:"enable_proxy_protocol,omitempty"`

	// Healthcheck specification that will be used by this backend. Structure is documented below.
	// +kubebuilder:validation:Optional
	Healthcheck []StreamBackendHealthcheckParameters `json:"healthcheck,omitempty" tf:"healthcheck,omitempty"`

	// Load Balancing Config specification that will be used by this backend. Structure is documented below.
	// +kubebuilder:validation:Optional
	LoadBalancingConfig []StreamBackendLoadBalancingConfigParameters `json:"loadBalancingConfig,omitempty" tf:"load_balancing_config,omitempty"`

	// Name of the backend.
	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// Port for incoming traffic.
	// +kubebuilder:validation:Optional
	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`

	// Tls specification that will be used by this backend. Structure is documented below.
	// +kubebuilder:validation:Optional
	TLS []StreamBackendTLSParameters `json:"tls,omitempty" tf:"tls,omitempty"`

	// References target groups for the backend.
	// +crossplane:generate:reference:type=TargetGroup
	// +kubebuilder:validation:Optional
	TargetGroupIds []*string `json:"targetGroupIds,omitempty" tf:"target_group_ids,omitempty"`

	// References to TargetGroup to populate targetGroupIds.
	// +kubebuilder:validation:Optional
	TargetGroupIdsRefs []v1.Reference `json:"targetGroupIdsRefs,omitempty" tf:"-"`

	// Selector for a list of TargetGroup to populate targetGroupIds.
	// +kubebuilder:validation:Optional
	TargetGroupIdsSelector *v1.Selector `json:"targetGroupIdsSelector,omitempty" tf:"-"`

	// Weight of the backend. Traffic will be split between backends of the same BackendGroup according to their weights.
	// +kubebuilder:validation:Optional
	Weight *float64 `json:"weight,omitempty" tf:"weight,omitempty"`
}

type StreamBackendTLSObservation struct {

	// SNI string for TLS connections.
	Sni *string `json:"sni,omitempty" tf:"sni,omitempty"`

	ValidationContext []StreamBackendTLSValidationContextObservation `json:"validationContext,omitempty" tf:"validation_context,omitempty"`
}

type StreamBackendTLSParameters struct {

	// SNI string for TLS connections.
	// +kubebuilder:validation:Optional
	Sni *string `json:"sni,omitempty" tf:"sni,omitempty"`

	// +kubebuilder:validation:Optional
	ValidationContext []StreamBackendTLSValidationContextParameters `json:"validationContext,omitempty" tf:"validation_context,omitempty"`
}

type StreamBackendTLSValidationContextObservation struct {

	// PEM-encoded trusted CA certificate chain.
	TrustedCABytes *string `json:"trustedCaBytes,omitempty" tf:"trusted_ca_bytes,omitempty"`

	// Trusted CA certificate ID in the Certificate Manager.
	TrustedCAID *string `json:"trustedCaId,omitempty" tf:"trusted_ca_id,omitempty"`
}

type StreamBackendTLSValidationContextParameters struct {

	// PEM-encoded trusted CA certificate chain.
	// +kubebuilder:validation:Optional
	TrustedCABytes *string `json:"trustedCaBytes,omitempty" tf:"trusted_ca_bytes,omitempty"`

	// Trusted CA certificate ID in the Certificate Manager.
	// +kubebuilder:validation:Optional
	TrustedCAID *string `json:"trustedCaId,omitempty" tf:"trusted_ca_id,omitempty"`
}

type StreamHealthcheckObservation struct {

	// Data that must be contained in the messages received from targets for a successful health check. If not specified, no messages are expected from targets, and those that are received are not checked.
	Receive *string `json:"receive,omitempty" tf:"receive,omitempty"`

	// Message sent to targets during TCP data transfer.  If not specified, no data is sent to the target.
	Send *string `json:"send,omitempty" tf:"send,omitempty"`
}

type StreamHealthcheckParameters struct {

	// Data that must be contained in the messages received from targets for a successful health check. If not specified, no messages are expected from targets, and those that are received are not checked.
	// +kubebuilder:validation:Optional
	Receive *string `json:"receive,omitempty" tf:"receive,omitempty"`

	// Message sent to targets during TCP data transfer.  If not specified, no data is sent to the target.
	// +kubebuilder:validation:Optional
	Send *string `json:"send,omitempty" tf:"send,omitempty"`
}

type TLSObservation struct {

	// SNI string for TLS connections.
	Sni *string `json:"sni,omitempty" tf:"sni,omitempty"`

	ValidationContext []ValidationContextObservation `json:"validationContext,omitempty" tf:"validation_context,omitempty"`
}

type TLSParameters struct {

	// SNI string for TLS connections.
	// +kubebuilder:validation:Optional
	Sni *string `json:"sni,omitempty" tf:"sni,omitempty"`

	// +kubebuilder:validation:Optional
	ValidationContext []ValidationContextParameters `json:"validationContext,omitempty" tf:"validation_context,omitempty"`
}

type TLSValidationContextObservation struct {

	// PEM-encoded trusted CA certificate chain.
	TrustedCABytes *string `json:"trustedCaBytes,omitempty" tf:"trusted_ca_bytes,omitempty"`

	// Trusted CA certificate ID in the Certificate Manager.
	TrustedCAID *string `json:"trustedCaId,omitempty" tf:"trusted_ca_id,omitempty"`
}

type TLSValidationContextParameters struct {

	// PEM-encoded trusted CA certificate chain.
	// +kubebuilder:validation:Optional
	TrustedCABytes *string `json:"trustedCaBytes,omitempty" tf:"trusted_ca_bytes,omitempty"`

	// Trusted CA certificate ID in the Certificate Manager.
	// +kubebuilder:validation:Optional
	TrustedCAID *string `json:"trustedCaId,omitempty" tf:"trusted_ca_id,omitempty"`
}

type ValidationContextObservation struct {

	// PEM-encoded trusted CA certificate chain.
	TrustedCABytes *string `json:"trustedCaBytes,omitempty" tf:"trusted_ca_bytes,omitempty"`

	// Trusted CA certificate ID in the Certificate Manager.
	TrustedCAID *string `json:"trustedCaId,omitempty" tf:"trusted_ca_id,omitempty"`
}

type ValidationContextParameters struct {

	// PEM-encoded trusted CA certificate chain.
	// +kubebuilder:validation:Optional
	TrustedCABytes *string `json:"trustedCaBytes,omitempty" tf:"trusted_ca_bytes,omitempty"`

	// Trusted CA certificate ID in the Certificate Manager.
	// +kubebuilder:validation:Optional
	TrustedCAID *string `json:"trustedCaId,omitempty" tf:"trusted_ca_id,omitempty"`
}

// BackendGroupSpec defines the desired state of BackendGroup
type BackendGroupSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     BackendGroupParameters `json:"forProvider"`
}

// BackendGroupStatus defines the observed state of BackendGroup.
type BackendGroupStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        BackendGroupObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// BackendGroup is the Schema for the BackendGroups API. An application load balancer distributes the load across cloud resources that are combined into a backend group.
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,yandex-cloud}
type BackendGroup struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              BackendGroupSpec   `json:"spec"`
	Status            BackendGroupStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// BackendGroupList contains a list of BackendGroups
type BackendGroupList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []BackendGroup `json:"items"`
}

// Repository type metadata.
var (
	BackendGroup_Kind             = "BackendGroup"
	BackendGroup_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: BackendGroup_Kind}.String()
	BackendGroup_KindAPIVersion   = BackendGroup_Kind + "." + CRDGroupVersion.String()
	BackendGroup_GroupVersionKind = CRDGroupVersion.WithKind(BackendGroup_Kind)
)

func init() {
	SchemeBuilder.Register(&BackendGroup{}, &BackendGroupList{})
}
