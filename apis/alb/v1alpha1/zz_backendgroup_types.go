/*
Copyright 2022 YANDEX LLC
This is modified version of the software, made by the Crossplane Authors
and available at: https://github.com/crossplane-contrib/provider-jet-template

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type BackendGroupInitParameters struct {

	// Description of the backend group.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// Folder that the resource belongs to. If value is omitted, the default provider folder is used.
	// +crossplane:generate:reference:type=github.com/yandex-cloud/crossplane-provider-yc/apis/resourcemanager/v1alpha1.Folder
	FolderID *string `json:"folderId,omitempty" tf:"folder_id,omitempty"`

	// Reference to a Folder in resourcemanager to populate folderId.
	// +kubebuilder:validation:Optional
	FolderIDRef *v1.Reference `json:"folderIdRef,omitempty" tf:"-"`

	// Selector for a Folder in resourcemanager to populate folderId.
	// +kubebuilder:validation:Optional
	FolderIDSelector *v1.Selector `json:"folderIdSelector,omitempty" tf:"-"`

	// Grpc backend specification that will be used by the ALB Backend Group. Structure is documented below.
	GRPCBackend []GRPCBackendInitParameters `json:"grpcBackend,omitempty" tf:"grpc_backend,omitempty"`

	// Http backend specification that will be used by the ALB Backend Group. Structure is documented below.
	HTTPBackend []HTTPBackendInitParameters `json:"httpBackend,omitempty" tf:"http_backend,omitempty"`

	// Labels to assign to this backend group.
	// +mapType=granular
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// Name of the Backend Group.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Session affinity mode determines how incoming requests are grouped into one session. Structure is documented below.
	SessionAffinity []SessionAffinityInitParameters `json:"sessionAffinity,omitempty" tf:"session_affinity,omitempty"`

	// Stream backend specification that will be used by the ALB Backend Group. Structure is documented below.
	StreamBackend []StreamBackendInitParameters `json:"streamBackend,omitempty" tf:"stream_backend,omitempty"`
}

type BackendGroupObservation struct {

	// The backend group creation timestamp.
	CreatedAt *string `json:"createdAt,omitempty" tf:"created_at,omitempty"`

	// Description of the backend group.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// Folder that the resource belongs to. If value is omitted, the default provider folder is used.
	FolderID *string `json:"folderId,omitempty" tf:"folder_id,omitempty"`

	// Grpc backend specification that will be used by the ALB Backend Group. Structure is documented below.
	GRPCBackend []GRPCBackendObservation `json:"grpcBackend,omitempty" tf:"grpc_backend,omitempty"`

	// Http backend specification that will be used by the ALB Backend Group. Structure is documented below.
	HTTPBackend []HTTPBackendObservation `json:"httpBackend,omitempty" tf:"http_backend,omitempty"`

	// The ID of the backend group.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// Labels to assign to this backend group.
	// +mapType=granular
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// Name of the Backend Group.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Session affinity mode determines how incoming requests are grouped into one session. Structure is documented below.
	SessionAffinity []SessionAffinityObservation `json:"sessionAffinity,omitempty" tf:"session_affinity,omitempty"`

	// Stream backend specification that will be used by the ALB Backend Group. Structure is documented below.
	StreamBackend []StreamBackendObservation `json:"streamBackend,omitempty" tf:"stream_backend,omitempty"`
}

type BackendGroupParameters struct {

	// Description of the backend group.
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// Folder that the resource belongs to. If value is omitted, the default provider folder is used.
	// +crossplane:generate:reference:type=github.com/yandex-cloud/crossplane-provider-yc/apis/resourcemanager/v1alpha1.Folder
	// +kubebuilder:validation:Optional
	FolderID *string `json:"folderId,omitempty" tf:"folder_id,omitempty"`

	// Reference to a Folder in resourcemanager to populate folderId.
	// +kubebuilder:validation:Optional
	FolderIDRef *v1.Reference `json:"folderIdRef,omitempty" tf:"-"`

	// Selector for a Folder in resourcemanager to populate folderId.
	// +kubebuilder:validation:Optional
	FolderIDSelector *v1.Selector `json:"folderIdSelector,omitempty" tf:"-"`

	// Grpc backend specification that will be used by the ALB Backend Group. Structure is documented below.
	// +kubebuilder:validation:Optional
	GRPCBackend []GRPCBackendParameters `json:"grpcBackend,omitempty" tf:"grpc_backend,omitempty"`

	// Http backend specification that will be used by the ALB Backend Group. Structure is documented below.
	// +kubebuilder:validation:Optional
	HTTPBackend []HTTPBackendParameters `json:"httpBackend,omitempty" tf:"http_backend,omitempty"`

	// Labels to assign to this backend group.
	// +kubebuilder:validation:Optional
	// +mapType=granular
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// Name of the Backend Group.
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Session affinity mode determines how incoming requests are grouped into one session. Structure is documented below.
	// +kubebuilder:validation:Optional
	SessionAffinity []SessionAffinityParameters `json:"sessionAffinity,omitempty" tf:"session_affinity,omitempty"`

	// Stream backend specification that will be used by the ALB Backend Group. Structure is documented below.
	// +kubebuilder:validation:Optional
	StreamBackend []StreamBackendParameters `json:"streamBackend,omitempty" tf:"stream_backend,omitempty"`
}

type ConnectionInitParameters struct {

	// Source IP address to use with affinity.
	// Use source IP address
	SourceIP *bool `json:"sourceIp,omitempty" tf:"source_ip,omitempty"`
}

type ConnectionObservation struct {

	// Source IP address to use with affinity.
	// Use source IP address
	SourceIP *bool `json:"sourceIp,omitempty" tf:"source_ip,omitempty"`
}

type ConnectionParameters struct {

	// Source IP address to use with affinity.
	// Use source IP address
	// +kubebuilder:validation:Optional
	SourceIP *bool `json:"sourceIp,omitempty" tf:"source_ip,omitempty"`
}

type CookieInitParameters struct {

	// Name of the backend.
	// Name of the HTTP cookie
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// TTL for the cookie (if not set, session cookie will be used)
	// TTL for the cookie (if not set, session cookie will be used)
	TTL *string `json:"ttl,omitempty" tf:"ttl,omitempty"`
}

type CookieObservation struct {

	// Name of the backend.
	// Name of the HTTP cookie
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// TTL for the cookie (if not set, session cookie will be used)
	// TTL for the cookie (if not set, session cookie will be used)
	TTL *string `json:"ttl,omitempty" tf:"ttl,omitempty"`
}

type CookieParameters struct {

	// Name of the backend.
	// Name of the HTTP cookie
	// +kubebuilder:validation:Optional
	Name *string `json:"name" tf:"name,omitempty"`

	// TTL for the cookie (if not set, session cookie will be used)
	// TTL for the cookie (if not set, session cookie will be used)
	// +kubebuilder:validation:Optional
	TTL *string `json:"ttl,omitempty" tf:"ttl,omitempty"`
}

type GRPCBackendInitParameters struct {

	// Healthcheck specification that will be used by this backend. Structure is documented below.
	Healthcheck []HealthcheckInitParameters `json:"healthcheck,omitempty" tf:"healthcheck,omitempty"`

	// Load Balancing Config specification that will be used by this backend. Structure is documented below.
	LoadBalancingConfig []LoadBalancingConfigInitParameters `json:"loadBalancingConfig,omitempty" tf:"load_balancing_config,omitempty"`

	// Name of the backend.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Port for incoming traffic.
	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`

	// Tls specification that will be used by this backend. Structure is documented below.
	TLS []TLSInitParameters `json:"tls,omitempty" tf:"tls,omitempty"`

	// References target groups for the backend.
	// +crossplane:generate:reference:type=TargetGroup
	TargetGroupIds []*string `json:"targetGroupIds,omitempty" tf:"target_group_ids,omitempty"`

	// References to TargetGroup to populate targetGroupIds.
	// +kubebuilder:validation:Optional
	TargetGroupIdsRefs []v1.Reference `json:"targetGroupIdsRefs,omitempty" tf:"-"`

	// Selector for a list of TargetGroup to populate targetGroupIds.
	// +kubebuilder:validation:Optional
	TargetGroupIdsSelector *v1.Selector `json:"targetGroupIdsSelector,omitempty" tf:"-"`

	// Weight of the backend. Traffic will be split between backends of the same BackendGroup according to their weights.
	Weight *float64 `json:"weight,omitempty" tf:"weight,omitempty"`
}

type GRPCBackendObservation struct {

	// Healthcheck specification that will be used by this backend. Structure is documented below.
	Healthcheck []HealthcheckObservation `json:"healthcheck,omitempty" tf:"healthcheck,omitempty"`

	// Load Balancing Config specification that will be used by this backend. Structure is documented below.
	LoadBalancingConfig []LoadBalancingConfigObservation `json:"loadBalancingConfig,omitempty" tf:"load_balancing_config,omitempty"`

	// Name of the backend.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Port for incoming traffic.
	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`

	// Tls specification that will be used by this backend. Structure is documented below.
	TLS []TLSObservation `json:"tls,omitempty" tf:"tls,omitempty"`

	// References target groups for the backend.
	TargetGroupIds []*string `json:"targetGroupIds,omitempty" tf:"target_group_ids,omitempty"`

	// Weight of the backend. Traffic will be split between backends of the same BackendGroup according to their weights.
	Weight *float64 `json:"weight,omitempty" tf:"weight,omitempty"`
}

type GRPCBackendParameters struct {

	// Healthcheck specification that will be used by this backend. Structure is documented below.
	// +kubebuilder:validation:Optional
	Healthcheck []HealthcheckParameters `json:"healthcheck,omitempty" tf:"healthcheck,omitempty"`

	// Load Balancing Config specification that will be used by this backend. Structure is documented below.
	// +kubebuilder:validation:Optional
	LoadBalancingConfig []LoadBalancingConfigParameters `json:"loadBalancingConfig,omitempty" tf:"load_balancing_config,omitempty"`

	// Name of the backend.
	// +kubebuilder:validation:Optional
	Name *string `json:"name" tf:"name,omitempty"`

	// Port for incoming traffic.
	// +kubebuilder:validation:Optional
	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`

	// Tls specification that will be used by this backend. Structure is documented below.
	// +kubebuilder:validation:Optional
	TLS []TLSParameters `json:"tls,omitempty" tf:"tls,omitempty"`

	// References target groups for the backend.
	// +crossplane:generate:reference:type=TargetGroup
	// +kubebuilder:validation:Optional
	TargetGroupIds []*string `json:"targetGroupIds,omitempty" tf:"target_group_ids,omitempty"`

	// References to TargetGroup to populate targetGroupIds.
	// +kubebuilder:validation:Optional
	TargetGroupIdsRefs []v1.Reference `json:"targetGroupIdsRefs,omitempty" tf:"-"`

	// Selector for a list of TargetGroup to populate targetGroupIds.
	// +kubebuilder:validation:Optional
	TargetGroupIdsSelector *v1.Selector `json:"targetGroupIdsSelector,omitempty" tf:"-"`

	// Weight of the backend. Traffic will be split between backends of the same BackendGroup according to their weights.
	// +kubebuilder:validation:Optional
	Weight *float64 `json:"weight,omitempty" tf:"weight,omitempty"`
}

type GRPCHealthcheckInitParameters struct {

	// Service name for grpc.health.v1.HealthCheckRequest message.
	ServiceName *string `json:"serviceName,omitempty" tf:"service_name,omitempty"`
}

type GRPCHealthcheckObservation struct {

	// Service name for grpc.health.v1.HealthCheckRequest message.
	ServiceName *string `json:"serviceName,omitempty" tf:"service_name,omitempty"`
}

type GRPCHealthcheckParameters struct {

	// Service name for grpc.health.v1.HealthCheckRequest message.
	// +kubebuilder:validation:Optional
	ServiceName *string `json:"serviceName,omitempty" tf:"service_name,omitempty"`
}

type HTTPBackendHealthcheckInitParameters struct {

	// Grpc Healthcheck specification that will be used by this healthcheck. Structure is documented below.
	GRPCHealthcheck []HealthcheckGRPCHealthcheckInitParameters `json:"grpcHealthcheck,omitempty" tf:"grpc_healthcheck,omitempty"`

	// Http Healthcheck specification that will be used by this healthcheck. Structure is documented below.
	HTTPHealthcheck []HealthcheckHTTPHealthcheckInitParameters `json:"httpHealthcheck,omitempty" tf:"http_healthcheck,omitempty"`

	// Optional alternative port for health checking.
	HealthcheckPort *float64 `json:"healthcheckPort,omitempty" tf:"healthcheck_port,omitempty"`

	// Number of consecutive successful health checks required to promote endpoint into the healthy state. 0 means 1. Note that during startup, only a single successful health check is required to mark a host healthy.
	HealthyThreshold *float64 `json:"healthyThreshold,omitempty" tf:"healthy_threshold,omitempty"`

	// Interval between health checks.
	Interval *string `json:"interval,omitempty" tf:"interval,omitempty"`

	// An optional jitter amount as a percentage of interval. If specified, during every interval value of (interval_ms * interval_jitter_percent / 100) will be added to the wait time.
	IntervalJitterPercent *float64 `json:"intervalJitterPercent,omitempty" tf:"interval_jitter_percent,omitempty"`

	// Stream Healthcheck specification that will be used by this healthcheck. Structure is documented below.
	StreamHealthcheck []HealthcheckStreamHealthcheckInitParameters `json:"streamHealthcheck,omitempty" tf:"stream_healthcheck,omitempty"`

	// Time to wait for a health check response.
	Timeout *string `json:"timeout,omitempty" tf:"timeout,omitempty"`

	// Number of consecutive failed health checks required to demote endpoint into the unhealthy state. 0 means 1. Note that for HTTP health checks, a single 503 immediately makes endpoint unhealthy.
	UnhealthyThreshold *float64 `json:"unhealthyThreshold,omitempty" tf:"unhealthy_threshold,omitempty"`
}

type HTTPBackendHealthcheckObservation struct {

	// Grpc Healthcheck specification that will be used by this healthcheck. Structure is documented below.
	GRPCHealthcheck []HealthcheckGRPCHealthcheckObservation `json:"grpcHealthcheck,omitempty" tf:"grpc_healthcheck,omitempty"`

	// Http Healthcheck specification that will be used by this healthcheck. Structure is documented below.
	HTTPHealthcheck []HealthcheckHTTPHealthcheckObservation `json:"httpHealthcheck,omitempty" tf:"http_healthcheck,omitempty"`

	// Optional alternative port for health checking.
	HealthcheckPort *float64 `json:"healthcheckPort,omitempty" tf:"healthcheck_port,omitempty"`

	// Number of consecutive successful health checks required to promote endpoint into the healthy state. 0 means 1. Note that during startup, only a single successful health check is required to mark a host healthy.
	HealthyThreshold *float64 `json:"healthyThreshold,omitempty" tf:"healthy_threshold,omitempty"`

	// Interval between health checks.
	Interval *string `json:"interval,omitempty" tf:"interval,omitempty"`

	// An optional jitter amount as a percentage of interval. If specified, during every interval value of (interval_ms * interval_jitter_percent / 100) will be added to the wait time.
	IntervalJitterPercent *float64 `json:"intervalJitterPercent,omitempty" tf:"interval_jitter_percent,omitempty"`

	// Stream Healthcheck specification that will be used by this healthcheck. Structure is documented below.
	StreamHealthcheck []HealthcheckStreamHealthcheckObservation `json:"streamHealthcheck,omitempty" tf:"stream_healthcheck,omitempty"`

	// Time to wait for a health check response.
	Timeout *string `json:"timeout,omitempty" tf:"timeout,omitempty"`

	// Number of consecutive failed health checks required to demote endpoint into the unhealthy state. 0 means 1. Note that for HTTP health checks, a single 503 immediately makes endpoint unhealthy.
	UnhealthyThreshold *float64 `json:"unhealthyThreshold,omitempty" tf:"unhealthy_threshold,omitempty"`
}

type HTTPBackendHealthcheckParameters struct {

	// Grpc Healthcheck specification that will be used by this healthcheck. Structure is documented below.
	// +kubebuilder:validation:Optional
	GRPCHealthcheck []HealthcheckGRPCHealthcheckParameters `json:"grpcHealthcheck,omitempty" tf:"grpc_healthcheck,omitempty"`

	// Http Healthcheck specification that will be used by this healthcheck. Structure is documented below.
	// +kubebuilder:validation:Optional
	HTTPHealthcheck []HealthcheckHTTPHealthcheckParameters `json:"httpHealthcheck,omitempty" tf:"http_healthcheck,omitempty"`

	// Optional alternative port for health checking.
	// +kubebuilder:validation:Optional
	HealthcheckPort *float64 `json:"healthcheckPort,omitempty" tf:"healthcheck_port,omitempty"`

	// Number of consecutive successful health checks required to promote endpoint into the healthy state. 0 means 1. Note that during startup, only a single successful health check is required to mark a host healthy.
	// +kubebuilder:validation:Optional
	HealthyThreshold *float64 `json:"healthyThreshold,omitempty" tf:"healthy_threshold,omitempty"`

	// Interval between health checks.
	// +kubebuilder:validation:Optional
	Interval *string `json:"interval" tf:"interval,omitempty"`

	// An optional jitter amount as a percentage of interval. If specified, during every interval value of (interval_ms * interval_jitter_percent / 100) will be added to the wait time.
	// +kubebuilder:validation:Optional
	IntervalJitterPercent *float64 `json:"intervalJitterPercent,omitempty" tf:"interval_jitter_percent,omitempty"`

	// Stream Healthcheck specification that will be used by this healthcheck. Structure is documented below.
	// +kubebuilder:validation:Optional
	StreamHealthcheck []HealthcheckStreamHealthcheckParameters `json:"streamHealthcheck,omitempty" tf:"stream_healthcheck,omitempty"`

	// Time to wait for a health check response.
	// +kubebuilder:validation:Optional
	Timeout *string `json:"timeout" tf:"timeout,omitempty"`

	// Number of consecutive failed health checks required to demote endpoint into the unhealthy state. 0 means 1. Note that for HTTP health checks, a single 503 immediately makes endpoint unhealthy.
	// +kubebuilder:validation:Optional
	UnhealthyThreshold *float64 `json:"unhealthyThreshold,omitempty" tf:"unhealthy_threshold,omitempty"`
}

type HTTPBackendInitParameters struct {

	// Healthcheck specification that will be used by this backend. Structure is documented below.
	Healthcheck []HTTPBackendHealthcheckInitParameters `json:"healthcheck,omitempty" tf:"healthcheck,omitempty"`

	// Enables HTTP2 for upstream requests. If not set, HTTP 1.1 will be used by default.
	Http2 *bool `json:"http2,omitempty" tf:"http2,omitempty"`

	// Load Balancing Config specification that will be used by this backend. Structure is documented below.
	LoadBalancingConfig []HTTPBackendLoadBalancingConfigInitParameters `json:"loadBalancingConfig,omitempty" tf:"load_balancing_config,omitempty"`

	// Name of the backend.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Port for incoming traffic.
	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`

	StorageBucket *string `json:"storageBucket,omitempty" tf:"storage_bucket,omitempty"`

	// Tls specification that will be used by this backend. Structure is documented below.
	TLS []HTTPBackendTLSInitParameters `json:"tls,omitempty" tf:"tls,omitempty"`

	// References target groups for the backend.
	// +crossplane:generate:reference:type=TargetGroup
	TargetGroupIds []*string `json:"targetGroupIds,omitempty" tf:"target_group_ids,omitempty"`

	// References to TargetGroup to populate targetGroupIds.
	// +kubebuilder:validation:Optional
	TargetGroupIdsRefs []v1.Reference `json:"targetGroupIdsRefs,omitempty" tf:"-"`

	// Selector for a list of TargetGroup to populate targetGroupIds.
	// +kubebuilder:validation:Optional
	TargetGroupIdsSelector *v1.Selector `json:"targetGroupIdsSelector,omitempty" tf:"-"`

	// Weight of the backend. Traffic will be split between backends of the same BackendGroup according to their weights.
	Weight *float64 `json:"weight,omitempty" tf:"weight,omitempty"`
}

type HTTPBackendLoadBalancingConfigInitParameters struct {

	// Percent of traffic to be sent to the same availability zone. The rest will be equally divided between other zones.
	LocalityAwareRoutingPercent *float64 `json:"localityAwareRoutingPercent,omitempty" tf:"locality_aware_routing_percent,omitempty"`

	// Load balancing mode for the backend. Possible values: "ROUND_ROBIN", "RANDOM", "LEAST_REQUEST", "MAGLEV_HASH".
	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`

	// If percentage of healthy hosts in the backend is lower than panic_threshold, traffic will be routed to all backends no matter what the health status is. This helps to avoid healthy backends overloading when everything is bad. Zero means no panic threshold.
	PanicThreshold *float64 `json:"panicThreshold,omitempty" tf:"panic_threshold,omitempty"`

	// If set, will route requests only to the same availability zone. Balancer won't know about endpoints in other zones.
	StrictLocality *bool `json:"strictLocality,omitempty" tf:"strict_locality,omitempty"`
}

type HTTPBackendLoadBalancingConfigObservation struct {

	// Percent of traffic to be sent to the same availability zone. The rest will be equally divided between other zones.
	LocalityAwareRoutingPercent *float64 `json:"localityAwareRoutingPercent,omitempty" tf:"locality_aware_routing_percent,omitempty"`

	// Load balancing mode for the backend. Possible values: "ROUND_ROBIN", "RANDOM", "LEAST_REQUEST", "MAGLEV_HASH".
	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`

	// If percentage of healthy hosts in the backend is lower than panic_threshold, traffic will be routed to all backends no matter what the health status is. This helps to avoid healthy backends overloading when everything is bad. Zero means no panic threshold.
	PanicThreshold *float64 `json:"panicThreshold,omitempty" tf:"panic_threshold,omitempty"`

	// If set, will route requests only to the same availability zone. Balancer won't know about endpoints in other zones.
	StrictLocality *bool `json:"strictLocality,omitempty" tf:"strict_locality,omitempty"`
}

type HTTPBackendLoadBalancingConfigParameters struct {

	// Percent of traffic to be sent to the same availability zone. The rest will be equally divided between other zones.
	// +kubebuilder:validation:Optional
	LocalityAwareRoutingPercent *float64 `json:"localityAwareRoutingPercent,omitempty" tf:"locality_aware_routing_percent,omitempty"`

	// Load balancing mode for the backend. Possible values: "ROUND_ROBIN", "RANDOM", "LEAST_REQUEST", "MAGLEV_HASH".
	// +kubebuilder:validation:Optional
	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`

	// If percentage of healthy hosts in the backend is lower than panic_threshold, traffic will be routed to all backends no matter what the health status is. This helps to avoid healthy backends overloading when everything is bad. Zero means no panic threshold.
	// +kubebuilder:validation:Optional
	PanicThreshold *float64 `json:"panicThreshold,omitempty" tf:"panic_threshold,omitempty"`

	// If set, will route requests only to the same availability zone. Balancer won't know about endpoints in other zones.
	// +kubebuilder:validation:Optional
	StrictLocality *bool `json:"strictLocality,omitempty" tf:"strict_locality,omitempty"`
}

type HTTPBackendObservation struct {

	// Healthcheck specification that will be used by this backend. Structure is documented below.
	Healthcheck []HTTPBackendHealthcheckObservation `json:"healthcheck,omitempty" tf:"healthcheck,omitempty"`

	// Enables HTTP2 for upstream requests. If not set, HTTP 1.1 will be used by default.
	Http2 *bool `json:"http2,omitempty" tf:"http2,omitempty"`

	// Load Balancing Config specification that will be used by this backend. Structure is documented below.
	LoadBalancingConfig []HTTPBackendLoadBalancingConfigObservation `json:"loadBalancingConfig,omitempty" tf:"load_balancing_config,omitempty"`

	// Name of the backend.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Port for incoming traffic.
	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`

	StorageBucket *string `json:"storageBucket,omitempty" tf:"storage_bucket,omitempty"`

	// Tls specification that will be used by this backend. Structure is documented below.
	TLS []HTTPBackendTLSObservation `json:"tls,omitempty" tf:"tls,omitempty"`

	// References target groups for the backend.
	TargetGroupIds []*string `json:"targetGroupIds,omitempty" tf:"target_group_ids,omitempty"`

	// Weight of the backend. Traffic will be split between backends of the same BackendGroup according to their weights.
	Weight *float64 `json:"weight,omitempty" tf:"weight,omitempty"`
}

type HTTPBackendParameters struct {

	// Healthcheck specification that will be used by this backend. Structure is documented below.
	// +kubebuilder:validation:Optional
	Healthcheck []HTTPBackendHealthcheckParameters `json:"healthcheck,omitempty" tf:"healthcheck,omitempty"`

	// Enables HTTP2 for upstream requests. If not set, HTTP 1.1 will be used by default.
	// +kubebuilder:validation:Optional
	Http2 *bool `json:"http2,omitempty" tf:"http2,omitempty"`

	// Load Balancing Config specification that will be used by this backend. Structure is documented below.
	// +kubebuilder:validation:Optional
	LoadBalancingConfig []HTTPBackendLoadBalancingConfigParameters `json:"loadBalancingConfig,omitempty" tf:"load_balancing_config,omitempty"`

	// Name of the backend.
	// +kubebuilder:validation:Optional
	Name *string `json:"name" tf:"name,omitempty"`

	// Port for incoming traffic.
	// +kubebuilder:validation:Optional
	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`

	// +kubebuilder:validation:Optional
	StorageBucket *string `json:"storageBucket,omitempty" tf:"storage_bucket,omitempty"`

	// Tls specification that will be used by this backend. Structure is documented below.
	// +kubebuilder:validation:Optional
	TLS []HTTPBackendTLSParameters `json:"tls,omitempty" tf:"tls,omitempty"`

	// References target groups for the backend.
	// +crossplane:generate:reference:type=TargetGroup
	// +kubebuilder:validation:Optional
	TargetGroupIds []*string `json:"targetGroupIds,omitempty" tf:"target_group_ids,omitempty"`

	// References to TargetGroup to populate targetGroupIds.
	// +kubebuilder:validation:Optional
	TargetGroupIdsRefs []v1.Reference `json:"targetGroupIdsRefs,omitempty" tf:"-"`

	// Selector for a list of TargetGroup to populate targetGroupIds.
	// +kubebuilder:validation:Optional
	TargetGroupIdsSelector *v1.Selector `json:"targetGroupIdsSelector,omitempty" tf:"-"`

	// Weight of the backend. Traffic will be split between backends of the same BackendGroup according to their weights.
	// +kubebuilder:validation:Optional
	Weight *float64 `json:"weight,omitempty" tf:"weight,omitempty"`
}

type HTTPBackendTLSInitParameters struct {

	// SNI string for TLS connections.
	Sni *string `json:"sni,omitempty" tf:"sni,omitempty"`

	ValidationContext []TLSValidationContextInitParameters `json:"validationContext,omitempty" tf:"validation_context,omitempty"`
}

type HTTPBackendTLSObservation struct {

	// SNI string for TLS connections.
	Sni *string `json:"sni,omitempty" tf:"sni,omitempty"`

	ValidationContext []TLSValidationContextObservation `json:"validationContext,omitempty" tf:"validation_context,omitempty"`
}

type HTTPBackendTLSParameters struct {

	// SNI string for TLS connections.
	// +kubebuilder:validation:Optional
	Sni *string `json:"sni,omitempty" tf:"sni,omitempty"`

	// +kubebuilder:validation:Optional
	ValidationContext []TLSValidationContextParameters `json:"validationContext,omitempty" tf:"validation_context,omitempty"`
}

type HTTPHealthcheckInitParameters struct {

	// "Host" HTTP header value.
	Host *string `json:"host,omitempty" tf:"host,omitempty"`

	// If set, health checks will use HTTP2.
	Http2 *bool `json:"http2,omitempty" tf:"http2,omitempty"`

	// HTTP path.
	Path *string `json:"path,omitempty" tf:"path,omitempty"`
}

type HTTPHealthcheckObservation struct {

	// "Host" HTTP header value.
	Host *string `json:"host,omitempty" tf:"host,omitempty"`

	// If set, health checks will use HTTP2.
	Http2 *bool `json:"http2,omitempty" tf:"http2,omitempty"`

	// HTTP path.
	Path *string `json:"path,omitempty" tf:"path,omitempty"`
}

type HTTPHealthcheckParameters struct {

	// "Host" HTTP header value.
	// +kubebuilder:validation:Optional
	Host *string `json:"host,omitempty" tf:"host,omitempty"`

	// If set, health checks will use HTTP2.
	// +kubebuilder:validation:Optional
	Http2 *bool `json:"http2,omitempty" tf:"http2,omitempty"`

	// HTTP path.
	// +kubebuilder:validation:Optional
	Path *string `json:"path" tf:"path,omitempty"`
}

type HeaderInitParameters struct {

	// The name of the request header that will be used with affinity.
	// The name of the request header that will be used
	HeaderName *string `json:"headerName,omitempty" tf:"header_name,omitempty"`
}

type HeaderObservation struct {

	// The name of the request header that will be used with affinity.
	// The name of the request header that will be used
	HeaderName *string `json:"headerName,omitempty" tf:"header_name,omitempty"`
}

type HeaderParameters struct {

	// The name of the request header that will be used with affinity.
	// The name of the request header that will be used
	// +kubebuilder:validation:Optional
	HeaderName *string `json:"headerName" tf:"header_name,omitempty"`
}

type HealthcheckGRPCHealthcheckInitParameters struct {

	// Service name for grpc.health.v1.HealthCheckRequest message.
	ServiceName *string `json:"serviceName,omitempty" tf:"service_name,omitempty"`
}

type HealthcheckGRPCHealthcheckObservation struct {

	// Service name for grpc.health.v1.HealthCheckRequest message.
	ServiceName *string `json:"serviceName,omitempty" tf:"service_name,omitempty"`
}

type HealthcheckGRPCHealthcheckParameters struct {

	// Service name for grpc.health.v1.HealthCheckRequest message.
	// +kubebuilder:validation:Optional
	ServiceName *string `json:"serviceName,omitempty" tf:"service_name,omitempty"`
}

type HealthcheckHTTPHealthcheckInitParameters struct {

	// "Host" HTTP header value.
	Host *string `json:"host,omitempty" tf:"host,omitempty"`

	// If set, health checks will use HTTP2.
	Http2 *bool `json:"http2,omitempty" tf:"http2,omitempty"`

	// HTTP path.
	Path *string `json:"path,omitempty" tf:"path,omitempty"`
}

type HealthcheckHTTPHealthcheckObservation struct {

	// "Host" HTTP header value.
	Host *string `json:"host,omitempty" tf:"host,omitempty"`

	// If set, health checks will use HTTP2.
	Http2 *bool `json:"http2,omitempty" tf:"http2,omitempty"`

	// HTTP path.
	Path *string `json:"path,omitempty" tf:"path,omitempty"`
}

type HealthcheckHTTPHealthcheckParameters struct {

	// "Host" HTTP header value.
	// +kubebuilder:validation:Optional
	Host *string `json:"host,omitempty" tf:"host,omitempty"`

	// If set, health checks will use HTTP2.
	// +kubebuilder:validation:Optional
	Http2 *bool `json:"http2,omitempty" tf:"http2,omitempty"`

	// HTTP path.
	// +kubebuilder:validation:Optional
	Path *string `json:"path" tf:"path,omitempty"`
}

type HealthcheckInitParameters struct {

	// Grpc Healthcheck specification that will be used by this healthcheck. Structure is documented below.
	GRPCHealthcheck []GRPCHealthcheckInitParameters `json:"grpcHealthcheck,omitempty" tf:"grpc_healthcheck,omitempty"`

	// Http Healthcheck specification that will be used by this healthcheck. Structure is documented below.
	HTTPHealthcheck []HTTPHealthcheckInitParameters `json:"httpHealthcheck,omitempty" tf:"http_healthcheck,omitempty"`

	// Optional alternative port for health checking.
	HealthcheckPort *float64 `json:"healthcheckPort,omitempty" tf:"healthcheck_port,omitempty"`

	// Number of consecutive successful health checks required to promote endpoint into the healthy state. 0 means 1. Note that during startup, only a single successful health check is required to mark a host healthy.
	HealthyThreshold *float64 `json:"healthyThreshold,omitempty" tf:"healthy_threshold,omitempty"`

	// Interval between health checks.
	Interval *string `json:"interval,omitempty" tf:"interval,omitempty"`

	// An optional jitter amount as a percentage of interval. If specified, during every interval value of (interval_ms * interval_jitter_percent / 100) will be added to the wait time.
	IntervalJitterPercent *float64 `json:"intervalJitterPercent,omitempty" tf:"interval_jitter_percent,omitempty"`

	// Stream Healthcheck specification that will be used by this healthcheck. Structure is documented below.
	StreamHealthcheck []StreamHealthcheckInitParameters `json:"streamHealthcheck,omitempty" tf:"stream_healthcheck,omitempty"`

	// Time to wait for a health check response.
	Timeout *string `json:"timeout,omitempty" tf:"timeout,omitempty"`

	// Number of consecutive failed health checks required to demote endpoint into the unhealthy state. 0 means 1. Note that for HTTP health checks, a single 503 immediately makes endpoint unhealthy.
	UnhealthyThreshold *float64 `json:"unhealthyThreshold,omitempty" tf:"unhealthy_threshold,omitempty"`
}

type HealthcheckObservation struct {

	// Grpc Healthcheck specification that will be used by this healthcheck. Structure is documented below.
	GRPCHealthcheck []GRPCHealthcheckObservation `json:"grpcHealthcheck,omitempty" tf:"grpc_healthcheck,omitempty"`

	// Http Healthcheck specification that will be used by this healthcheck. Structure is documented below.
	HTTPHealthcheck []HTTPHealthcheckObservation `json:"httpHealthcheck,omitempty" tf:"http_healthcheck,omitempty"`

	// Optional alternative port for health checking.
	HealthcheckPort *float64 `json:"healthcheckPort,omitempty" tf:"healthcheck_port,omitempty"`

	// Number of consecutive successful health checks required to promote endpoint into the healthy state. 0 means 1. Note that during startup, only a single successful health check is required to mark a host healthy.
	HealthyThreshold *float64 `json:"healthyThreshold,omitempty" tf:"healthy_threshold,omitempty"`

	// Interval between health checks.
	Interval *string `json:"interval,omitempty" tf:"interval,omitempty"`

	// An optional jitter amount as a percentage of interval. If specified, during every interval value of (interval_ms * interval_jitter_percent / 100) will be added to the wait time.
	IntervalJitterPercent *float64 `json:"intervalJitterPercent,omitempty" tf:"interval_jitter_percent,omitempty"`

	// Stream Healthcheck specification that will be used by this healthcheck. Structure is documented below.
	StreamHealthcheck []StreamHealthcheckObservation `json:"streamHealthcheck,omitempty" tf:"stream_healthcheck,omitempty"`

	// Time to wait for a health check response.
	Timeout *string `json:"timeout,omitempty" tf:"timeout,omitempty"`

	// Number of consecutive failed health checks required to demote endpoint into the unhealthy state. 0 means 1. Note that for HTTP health checks, a single 503 immediately makes endpoint unhealthy.
	UnhealthyThreshold *float64 `json:"unhealthyThreshold,omitempty" tf:"unhealthy_threshold,omitempty"`
}

type HealthcheckParameters struct {

	// Grpc Healthcheck specification that will be used by this healthcheck. Structure is documented below.
	// +kubebuilder:validation:Optional
	GRPCHealthcheck []GRPCHealthcheckParameters `json:"grpcHealthcheck,omitempty" tf:"grpc_healthcheck,omitempty"`

	// Http Healthcheck specification that will be used by this healthcheck. Structure is documented below.
	// +kubebuilder:validation:Optional
	HTTPHealthcheck []HTTPHealthcheckParameters `json:"httpHealthcheck,omitempty" tf:"http_healthcheck,omitempty"`

	// Optional alternative port for health checking.
	// +kubebuilder:validation:Optional
	HealthcheckPort *float64 `json:"healthcheckPort,omitempty" tf:"healthcheck_port,omitempty"`

	// Number of consecutive successful health checks required to promote endpoint into the healthy state. 0 means 1. Note that during startup, only a single successful health check is required to mark a host healthy.
	// +kubebuilder:validation:Optional
	HealthyThreshold *float64 `json:"healthyThreshold,omitempty" tf:"healthy_threshold,omitempty"`

	// Interval between health checks.
	// +kubebuilder:validation:Optional
	Interval *string `json:"interval" tf:"interval,omitempty"`

	// An optional jitter amount as a percentage of interval. If specified, during every interval value of (interval_ms * interval_jitter_percent / 100) will be added to the wait time.
	// +kubebuilder:validation:Optional
	IntervalJitterPercent *float64 `json:"intervalJitterPercent,omitempty" tf:"interval_jitter_percent,omitempty"`

	// Stream Healthcheck specification that will be used by this healthcheck. Structure is documented below.
	// +kubebuilder:validation:Optional
	StreamHealthcheck []StreamHealthcheckParameters `json:"streamHealthcheck,omitempty" tf:"stream_healthcheck,omitempty"`

	// Time to wait for a health check response.
	// +kubebuilder:validation:Optional
	Timeout *string `json:"timeout" tf:"timeout,omitempty"`

	// Number of consecutive failed health checks required to demote endpoint into the unhealthy state. 0 means 1. Note that for HTTP health checks, a single 503 immediately makes endpoint unhealthy.
	// +kubebuilder:validation:Optional
	UnhealthyThreshold *float64 `json:"unhealthyThreshold,omitempty" tf:"unhealthy_threshold,omitempty"`
}

type HealthcheckStreamHealthcheckInitParameters struct {

	// Data that must be contained in the messages received from targets for a successful health check. If not specified, no messages are expected from targets, and those that are received are not checked.
	Receive *string `json:"receive,omitempty" tf:"receive,omitempty"`

	// Message sent to targets during TCP data transfer. If not specified, no data is sent to the target.
	Send *string `json:"send,omitempty" tf:"send,omitempty"`
}

type HealthcheckStreamHealthcheckObservation struct {

	// Data that must be contained in the messages received from targets for a successful health check. If not specified, no messages are expected from targets, and those that are received are not checked.
	Receive *string `json:"receive,omitempty" tf:"receive,omitempty"`

	// Message sent to targets during TCP data transfer. If not specified, no data is sent to the target.
	Send *string `json:"send,omitempty" tf:"send,omitempty"`
}

type HealthcheckStreamHealthcheckParameters struct {

	// Data that must be contained in the messages received from targets for a successful health check. If not specified, no messages are expected from targets, and those that are received are not checked.
	// +kubebuilder:validation:Optional
	Receive *string `json:"receive,omitempty" tf:"receive,omitempty"`

	// Message sent to targets during TCP data transfer. If not specified, no data is sent to the target.
	// +kubebuilder:validation:Optional
	Send *string `json:"send,omitempty" tf:"send,omitempty"`
}

type LoadBalancingConfigInitParameters struct {

	// Percent of traffic to be sent to the same availability zone. The rest will be equally divided between other zones.
	LocalityAwareRoutingPercent *float64 `json:"localityAwareRoutingPercent,omitempty" tf:"locality_aware_routing_percent,omitempty"`

	// Load balancing mode for the backend. Possible values: "ROUND_ROBIN", "RANDOM", "LEAST_REQUEST", "MAGLEV_HASH".
	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`

	// If percentage of healthy hosts in the backend is lower than panic_threshold, traffic will be routed to all backends no matter what the health status is. This helps to avoid healthy backends overloading when everything is bad. Zero means no panic threshold.
	PanicThreshold *float64 `json:"panicThreshold,omitempty" tf:"panic_threshold,omitempty"`

	// If set, will route requests only to the same availability zone. Balancer won't know about endpoints in other zones.
	StrictLocality *bool `json:"strictLocality,omitempty" tf:"strict_locality,omitempty"`
}

type LoadBalancingConfigObservation struct {

	// Percent of traffic to be sent to the same availability zone. The rest will be equally divided between other zones.
	LocalityAwareRoutingPercent *float64 `json:"localityAwareRoutingPercent,omitempty" tf:"locality_aware_routing_percent,omitempty"`

	// Load balancing mode for the backend. Possible values: "ROUND_ROBIN", "RANDOM", "LEAST_REQUEST", "MAGLEV_HASH".
	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`

	// If percentage of healthy hosts in the backend is lower than panic_threshold, traffic will be routed to all backends no matter what the health status is. This helps to avoid healthy backends overloading when everything is bad. Zero means no panic threshold.
	PanicThreshold *float64 `json:"panicThreshold,omitempty" tf:"panic_threshold,omitempty"`

	// If set, will route requests only to the same availability zone. Balancer won't know about endpoints in other zones.
	StrictLocality *bool `json:"strictLocality,omitempty" tf:"strict_locality,omitempty"`
}

type LoadBalancingConfigParameters struct {

	// Percent of traffic to be sent to the same availability zone. The rest will be equally divided between other zones.
	// +kubebuilder:validation:Optional
	LocalityAwareRoutingPercent *float64 `json:"localityAwareRoutingPercent,omitempty" tf:"locality_aware_routing_percent,omitempty"`

	// Load balancing mode for the backend. Possible values: "ROUND_ROBIN", "RANDOM", "LEAST_REQUEST", "MAGLEV_HASH".
	// +kubebuilder:validation:Optional
	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`

	// If percentage of healthy hosts in the backend is lower than panic_threshold, traffic will be routed to all backends no matter what the health status is. This helps to avoid healthy backends overloading when everything is bad. Zero means no panic threshold.
	// +kubebuilder:validation:Optional
	PanicThreshold *float64 `json:"panicThreshold,omitempty" tf:"panic_threshold,omitempty"`

	// If set, will route requests only to the same availability zone. Balancer won't know about endpoints in other zones.
	// +kubebuilder:validation:Optional
	StrictLocality *bool `json:"strictLocality,omitempty" tf:"strict_locality,omitempty"`
}

type SessionAffinityInitParameters struct {

	// Requests received from the same IP are combined into a session. Stream backend groups only support session affinity by client IP address. Structure is documented below.
	// IP address affinity
	Connection []ConnectionInitParameters `json:"connection,omitempty" tf:"connection,omitempty"`

	// Requests with the same cookie value and the specified file name are combined into a session. Allowed only for HTTP and gRPC backend groups. Structure is documented below.
	// Cookie affinity
	Cookie []CookieInitParameters `json:"cookie,omitempty" tf:"cookie,omitempty"`

	// Requests with the same value of the specified HTTP header, such as with user authentication data, are combined into a session. Allowed only for HTTP and gRPC backend groups. Structure is documented below.
	// Request header affinity
	Header []HeaderInitParameters `json:"header,omitempty" tf:"header,omitempty"`
}

type SessionAffinityObservation struct {

	// Requests received from the same IP are combined into a session. Stream backend groups only support session affinity by client IP address. Structure is documented below.
	// IP address affinity
	Connection []ConnectionObservation `json:"connection,omitempty" tf:"connection,omitempty"`

	// Requests with the same cookie value and the specified file name are combined into a session. Allowed only for HTTP and gRPC backend groups. Structure is documented below.
	// Cookie affinity
	Cookie []CookieObservation `json:"cookie,omitempty" tf:"cookie,omitempty"`

	// Requests with the same value of the specified HTTP header, such as with user authentication data, are combined into a session. Allowed only for HTTP and gRPC backend groups. Structure is documented below.
	// Request header affinity
	Header []HeaderObservation `json:"header,omitempty" tf:"header,omitempty"`
}

type SessionAffinityParameters struct {

	// Requests received from the same IP are combined into a session. Stream backend groups only support session affinity by client IP address. Structure is documented below.
	// IP address affinity
	// +kubebuilder:validation:Optional
	Connection []ConnectionParameters `json:"connection,omitempty" tf:"connection,omitempty"`

	// Requests with the same cookie value and the specified file name are combined into a session. Allowed only for HTTP and gRPC backend groups. Structure is documented below.
	// Cookie affinity
	// +kubebuilder:validation:Optional
	Cookie []CookieParameters `json:"cookie,omitempty" tf:"cookie,omitempty"`

	// Requests with the same value of the specified HTTP header, such as with user authentication data, are combined into a session. Allowed only for HTTP and gRPC backend groups. Structure is documented below.
	// Request header affinity
	// +kubebuilder:validation:Optional
	Header []HeaderParameters `json:"header,omitempty" tf:"header,omitempty"`
}

type StreamBackendHealthcheckGRPCHealthcheckInitParameters struct {

	// Service name for grpc.health.v1.HealthCheckRequest message.
	ServiceName *string `json:"serviceName,omitempty" tf:"service_name,omitempty"`
}

type StreamBackendHealthcheckGRPCHealthcheckObservation struct {

	// Service name for grpc.health.v1.HealthCheckRequest message.
	ServiceName *string `json:"serviceName,omitempty" tf:"service_name,omitempty"`
}

type StreamBackendHealthcheckGRPCHealthcheckParameters struct {

	// Service name for grpc.health.v1.HealthCheckRequest message.
	// +kubebuilder:validation:Optional
	ServiceName *string `json:"serviceName,omitempty" tf:"service_name,omitempty"`
}

type StreamBackendHealthcheckHTTPHealthcheckInitParameters struct {

	// "Host" HTTP header value.
	Host *string `json:"host,omitempty" tf:"host,omitempty"`

	// If set, health checks will use HTTP2.
	Http2 *bool `json:"http2,omitempty" tf:"http2,omitempty"`

	// HTTP path.
	Path *string `json:"path,omitempty" tf:"path,omitempty"`
}

type StreamBackendHealthcheckHTTPHealthcheckObservation struct {

	// "Host" HTTP header value.
	Host *string `json:"host,omitempty" tf:"host,omitempty"`

	// If set, health checks will use HTTP2.
	Http2 *bool `json:"http2,omitempty" tf:"http2,omitempty"`

	// HTTP path.
	Path *string `json:"path,omitempty" tf:"path,omitempty"`
}

type StreamBackendHealthcheckHTTPHealthcheckParameters struct {

	// "Host" HTTP header value.
	// +kubebuilder:validation:Optional
	Host *string `json:"host,omitempty" tf:"host,omitempty"`

	// If set, health checks will use HTTP2.
	// +kubebuilder:validation:Optional
	Http2 *bool `json:"http2,omitempty" tf:"http2,omitempty"`

	// HTTP path.
	// +kubebuilder:validation:Optional
	Path *string `json:"path" tf:"path,omitempty"`
}

type StreamBackendHealthcheckInitParameters struct {

	// Grpc Healthcheck specification that will be used by this healthcheck. Structure is documented below.
	GRPCHealthcheck []StreamBackendHealthcheckGRPCHealthcheckInitParameters `json:"grpcHealthcheck,omitempty" tf:"grpc_healthcheck,omitempty"`

	// Http Healthcheck specification that will be used by this healthcheck. Structure is documented below.
	HTTPHealthcheck []StreamBackendHealthcheckHTTPHealthcheckInitParameters `json:"httpHealthcheck,omitempty" tf:"http_healthcheck,omitempty"`

	// Optional alternative port for health checking.
	HealthcheckPort *float64 `json:"healthcheckPort,omitempty" tf:"healthcheck_port,omitempty"`

	// Number of consecutive successful health checks required to promote endpoint into the healthy state. 0 means 1. Note that during startup, only a single successful health check is required to mark a host healthy.
	HealthyThreshold *float64 `json:"healthyThreshold,omitempty" tf:"healthy_threshold,omitempty"`

	// Interval between health checks.
	Interval *string `json:"interval,omitempty" tf:"interval,omitempty"`

	// An optional jitter amount as a percentage of interval. If specified, during every interval value of (interval_ms * interval_jitter_percent / 100) will be added to the wait time.
	IntervalJitterPercent *float64 `json:"intervalJitterPercent,omitempty" tf:"interval_jitter_percent,omitempty"`

	// Stream Healthcheck specification that will be used by this healthcheck. Structure is documented below.
	StreamHealthcheck []StreamBackendHealthcheckStreamHealthcheckInitParameters `json:"streamHealthcheck,omitempty" tf:"stream_healthcheck,omitempty"`

	// Time to wait for a health check response.
	Timeout *string `json:"timeout,omitempty" tf:"timeout,omitempty"`

	// Number of consecutive failed health checks required to demote endpoint into the unhealthy state. 0 means 1. Note that for HTTP health checks, a single 503 immediately makes endpoint unhealthy.
	UnhealthyThreshold *float64 `json:"unhealthyThreshold,omitempty" tf:"unhealthy_threshold,omitempty"`
}

type StreamBackendHealthcheckObservation struct {

	// Grpc Healthcheck specification that will be used by this healthcheck. Structure is documented below.
	GRPCHealthcheck []StreamBackendHealthcheckGRPCHealthcheckObservation `json:"grpcHealthcheck,omitempty" tf:"grpc_healthcheck,omitempty"`

	// Http Healthcheck specification that will be used by this healthcheck. Structure is documented below.
	HTTPHealthcheck []StreamBackendHealthcheckHTTPHealthcheckObservation `json:"httpHealthcheck,omitempty" tf:"http_healthcheck,omitempty"`

	// Optional alternative port for health checking.
	HealthcheckPort *float64 `json:"healthcheckPort,omitempty" tf:"healthcheck_port,omitempty"`

	// Number of consecutive successful health checks required to promote endpoint into the healthy state. 0 means 1. Note that during startup, only a single successful health check is required to mark a host healthy.
	HealthyThreshold *float64 `json:"healthyThreshold,omitempty" tf:"healthy_threshold,omitempty"`

	// Interval between health checks.
	Interval *string `json:"interval,omitempty" tf:"interval,omitempty"`

	// An optional jitter amount as a percentage of interval. If specified, during every interval value of (interval_ms * interval_jitter_percent / 100) will be added to the wait time.
	IntervalJitterPercent *float64 `json:"intervalJitterPercent,omitempty" tf:"interval_jitter_percent,omitempty"`

	// Stream Healthcheck specification that will be used by this healthcheck. Structure is documented below.
	StreamHealthcheck []StreamBackendHealthcheckStreamHealthcheckObservation `json:"streamHealthcheck,omitempty" tf:"stream_healthcheck,omitempty"`

	// Time to wait for a health check response.
	Timeout *string `json:"timeout,omitempty" tf:"timeout,omitempty"`

	// Number of consecutive failed health checks required to demote endpoint into the unhealthy state. 0 means 1. Note that for HTTP health checks, a single 503 immediately makes endpoint unhealthy.
	UnhealthyThreshold *float64 `json:"unhealthyThreshold,omitempty" tf:"unhealthy_threshold,omitempty"`
}

type StreamBackendHealthcheckParameters struct {

	// Grpc Healthcheck specification that will be used by this healthcheck. Structure is documented below.
	// +kubebuilder:validation:Optional
	GRPCHealthcheck []StreamBackendHealthcheckGRPCHealthcheckParameters `json:"grpcHealthcheck,omitempty" tf:"grpc_healthcheck,omitempty"`

	// Http Healthcheck specification that will be used by this healthcheck. Structure is documented below.
	// +kubebuilder:validation:Optional
	HTTPHealthcheck []StreamBackendHealthcheckHTTPHealthcheckParameters `json:"httpHealthcheck,omitempty" tf:"http_healthcheck,omitempty"`

	// Optional alternative port for health checking.
	// +kubebuilder:validation:Optional
	HealthcheckPort *float64 `json:"healthcheckPort,omitempty" tf:"healthcheck_port,omitempty"`

	// Number of consecutive successful health checks required to promote endpoint into the healthy state. 0 means 1. Note that during startup, only a single successful health check is required to mark a host healthy.
	// +kubebuilder:validation:Optional
	HealthyThreshold *float64 `json:"healthyThreshold,omitempty" tf:"healthy_threshold,omitempty"`

	// Interval between health checks.
	// +kubebuilder:validation:Optional
	Interval *string `json:"interval" tf:"interval,omitempty"`

	// An optional jitter amount as a percentage of interval. If specified, during every interval value of (interval_ms * interval_jitter_percent / 100) will be added to the wait time.
	// +kubebuilder:validation:Optional
	IntervalJitterPercent *float64 `json:"intervalJitterPercent,omitempty" tf:"interval_jitter_percent,omitempty"`

	// Stream Healthcheck specification that will be used by this healthcheck. Structure is documented below.
	// +kubebuilder:validation:Optional
	StreamHealthcheck []StreamBackendHealthcheckStreamHealthcheckParameters `json:"streamHealthcheck,omitempty" tf:"stream_healthcheck,omitempty"`

	// Time to wait for a health check response.
	// +kubebuilder:validation:Optional
	Timeout *string `json:"timeout" tf:"timeout,omitempty"`

	// Number of consecutive failed health checks required to demote endpoint into the unhealthy state. 0 means 1. Note that for HTTP health checks, a single 503 immediately makes endpoint unhealthy.
	// +kubebuilder:validation:Optional
	UnhealthyThreshold *float64 `json:"unhealthyThreshold,omitempty" tf:"unhealthy_threshold,omitempty"`
}

type StreamBackendHealthcheckStreamHealthcheckInitParameters struct {

	// Data that must be contained in the messages received from targets for a successful health check. If not specified, no messages are expected from targets, and those that are received are not checked.
	Receive *string `json:"receive,omitempty" tf:"receive,omitempty"`

	// Message sent to targets during TCP data transfer. If not specified, no data is sent to the target.
	Send *string `json:"send,omitempty" tf:"send,omitempty"`
}

type StreamBackendHealthcheckStreamHealthcheckObservation struct {

	// Data that must be contained in the messages received from targets for a successful health check. If not specified, no messages are expected from targets, and those that are received are not checked.
	Receive *string `json:"receive,omitempty" tf:"receive,omitempty"`

	// Message sent to targets during TCP data transfer. If not specified, no data is sent to the target.
	Send *string `json:"send,omitempty" tf:"send,omitempty"`
}

type StreamBackendHealthcheckStreamHealthcheckParameters struct {

	// Data that must be contained in the messages received from targets for a successful health check. If not specified, no messages are expected from targets, and those that are received are not checked.
	// +kubebuilder:validation:Optional
	Receive *string `json:"receive,omitempty" tf:"receive,omitempty"`

	// Message sent to targets during TCP data transfer. If not specified, no data is sent to the target.
	// +kubebuilder:validation:Optional
	Send *string `json:"send,omitempty" tf:"send,omitempty"`
}

type StreamBackendInitParameters struct {
	EnableProxyProtocol *bool `json:"enableProxyProtocol,omitempty" tf:"enable_proxy_protocol,omitempty"`

	// Healthcheck specification that will be used by this backend. Structure is documented below.
	Healthcheck []StreamBackendHealthcheckInitParameters `json:"healthcheck,omitempty" tf:"healthcheck,omitempty"`

	// Load Balancing Config specification that will be used by this backend. Structure is documented below.
	LoadBalancingConfig []StreamBackendLoadBalancingConfigInitParameters `json:"loadBalancingConfig,omitempty" tf:"load_balancing_config,omitempty"`

	// Name of the backend.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Port for incoming traffic.
	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`

	// Tls specification that will be used by this backend. Structure is documented below.
	TLS []StreamBackendTLSInitParameters `json:"tls,omitempty" tf:"tls,omitempty"`

	// References target groups for the backend.
	// +crossplane:generate:reference:type=TargetGroup
	TargetGroupIds []*string `json:"targetGroupIds,omitempty" tf:"target_group_ids,omitempty"`

	// References to TargetGroup to populate targetGroupIds.
	// +kubebuilder:validation:Optional
	TargetGroupIdsRefs []v1.Reference `json:"targetGroupIdsRefs,omitempty" tf:"-"`

	// Selector for a list of TargetGroup to populate targetGroupIds.
	// +kubebuilder:validation:Optional
	TargetGroupIdsSelector *v1.Selector `json:"targetGroupIdsSelector,omitempty" tf:"-"`

	// Weight of the backend. Traffic will be split between backends of the same BackendGroup according to their weights.
	Weight *float64 `json:"weight,omitempty" tf:"weight,omitempty"`
}

type StreamBackendLoadBalancingConfigInitParameters struct {

	// Percent of traffic to be sent to the same availability zone. The rest will be equally divided between other zones.
	LocalityAwareRoutingPercent *float64 `json:"localityAwareRoutingPercent,omitempty" tf:"locality_aware_routing_percent,omitempty"`

	// Load balancing mode for the backend. Possible values: "ROUND_ROBIN", "RANDOM", "LEAST_REQUEST", "MAGLEV_HASH".
	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`

	// If percentage of healthy hosts in the backend is lower than panic_threshold, traffic will be routed to all backends no matter what the health status is. This helps to avoid healthy backends overloading when everything is bad. Zero means no panic threshold.
	PanicThreshold *float64 `json:"panicThreshold,omitempty" tf:"panic_threshold,omitempty"`

	// If set, will route requests only to the same availability zone. Balancer won't know about endpoints in other zones.
	StrictLocality *bool `json:"strictLocality,omitempty" tf:"strict_locality,omitempty"`
}

type StreamBackendLoadBalancingConfigObservation struct {

	// Percent of traffic to be sent to the same availability zone. The rest will be equally divided between other zones.
	LocalityAwareRoutingPercent *float64 `json:"localityAwareRoutingPercent,omitempty" tf:"locality_aware_routing_percent,omitempty"`

	// Load balancing mode for the backend. Possible values: "ROUND_ROBIN", "RANDOM", "LEAST_REQUEST", "MAGLEV_HASH".
	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`

	// If percentage of healthy hosts in the backend is lower than panic_threshold, traffic will be routed to all backends no matter what the health status is. This helps to avoid healthy backends overloading when everything is bad. Zero means no panic threshold.
	PanicThreshold *float64 `json:"panicThreshold,omitempty" tf:"panic_threshold,omitempty"`

	// If set, will route requests only to the same availability zone. Balancer won't know about endpoints in other zones.
	StrictLocality *bool `json:"strictLocality,omitempty" tf:"strict_locality,omitempty"`
}

type StreamBackendLoadBalancingConfigParameters struct {

	// Percent of traffic to be sent to the same availability zone. The rest will be equally divided between other zones.
	// +kubebuilder:validation:Optional
	LocalityAwareRoutingPercent *float64 `json:"localityAwareRoutingPercent,omitempty" tf:"locality_aware_routing_percent,omitempty"`

	// Load balancing mode for the backend. Possible values: "ROUND_ROBIN", "RANDOM", "LEAST_REQUEST", "MAGLEV_HASH".
	// +kubebuilder:validation:Optional
	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`

	// If percentage of healthy hosts in the backend is lower than panic_threshold, traffic will be routed to all backends no matter what the health status is. This helps to avoid healthy backends overloading when everything is bad. Zero means no panic threshold.
	// +kubebuilder:validation:Optional
	PanicThreshold *float64 `json:"panicThreshold,omitempty" tf:"panic_threshold,omitempty"`

	// If set, will route requests only to the same availability zone. Balancer won't know about endpoints in other zones.
	// +kubebuilder:validation:Optional
	StrictLocality *bool `json:"strictLocality,omitempty" tf:"strict_locality,omitempty"`
}

type StreamBackendObservation struct {
	EnableProxyProtocol *bool `json:"enableProxyProtocol,omitempty" tf:"enable_proxy_protocol,omitempty"`

	// Healthcheck specification that will be used by this backend. Structure is documented below.
	Healthcheck []StreamBackendHealthcheckObservation `json:"healthcheck,omitempty" tf:"healthcheck,omitempty"`

	// Load Balancing Config specification that will be used by this backend. Structure is documented below.
	LoadBalancingConfig []StreamBackendLoadBalancingConfigObservation `json:"loadBalancingConfig,omitempty" tf:"load_balancing_config,omitempty"`

	// Name of the backend.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Port for incoming traffic.
	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`

	// Tls specification that will be used by this backend. Structure is documented below.
	TLS []StreamBackendTLSObservation `json:"tls,omitempty" tf:"tls,omitempty"`

	// References target groups for the backend.
	TargetGroupIds []*string `json:"targetGroupIds,omitempty" tf:"target_group_ids,omitempty"`

	// Weight of the backend. Traffic will be split between backends of the same BackendGroup according to their weights.
	Weight *float64 `json:"weight,omitempty" tf:"weight,omitempty"`
}

type StreamBackendParameters struct {

	// +kubebuilder:validation:Optional
	EnableProxyProtocol *bool `json:"enableProxyProtocol,omitempty" tf:"enable_proxy_protocol,omitempty"`

	// Healthcheck specification that will be used by this backend. Structure is documented below.
	// +kubebuilder:validation:Optional
	Healthcheck []StreamBackendHealthcheckParameters `json:"healthcheck,omitempty" tf:"healthcheck,omitempty"`

	// Load Balancing Config specification that will be used by this backend. Structure is documented below.
	// +kubebuilder:validation:Optional
	LoadBalancingConfig []StreamBackendLoadBalancingConfigParameters `json:"loadBalancingConfig,omitempty" tf:"load_balancing_config,omitempty"`

	// Name of the backend.
	// +kubebuilder:validation:Optional
	Name *string `json:"name" tf:"name,omitempty"`

	// Port for incoming traffic.
	// +kubebuilder:validation:Optional
	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`

	// Tls specification that will be used by this backend. Structure is documented below.
	// +kubebuilder:validation:Optional
	TLS []StreamBackendTLSParameters `json:"tls,omitempty" tf:"tls,omitempty"`

	// References target groups for the backend.
	// +crossplane:generate:reference:type=TargetGroup
	// +kubebuilder:validation:Optional
	TargetGroupIds []*string `json:"targetGroupIds,omitempty" tf:"target_group_ids,omitempty"`

	// References to TargetGroup to populate targetGroupIds.
	// +kubebuilder:validation:Optional
	TargetGroupIdsRefs []v1.Reference `json:"targetGroupIdsRefs,omitempty" tf:"-"`

	// Selector for a list of TargetGroup to populate targetGroupIds.
	// +kubebuilder:validation:Optional
	TargetGroupIdsSelector *v1.Selector `json:"targetGroupIdsSelector,omitempty" tf:"-"`

	// Weight of the backend. Traffic will be split between backends of the same BackendGroup according to their weights.
	// +kubebuilder:validation:Optional
	Weight *float64 `json:"weight,omitempty" tf:"weight,omitempty"`
}

type StreamBackendTLSInitParameters struct {

	// SNI string for TLS connections.
	Sni *string `json:"sni,omitempty" tf:"sni,omitempty"`

	ValidationContext []StreamBackendTLSValidationContextInitParameters `json:"validationContext,omitempty" tf:"validation_context,omitempty"`
}

type StreamBackendTLSObservation struct {

	// SNI string for TLS connections.
	Sni *string `json:"sni,omitempty" tf:"sni,omitempty"`

	ValidationContext []StreamBackendTLSValidationContextObservation `json:"validationContext,omitempty" tf:"validation_context,omitempty"`
}

type StreamBackendTLSParameters struct {

	// SNI string for TLS connections.
	// +kubebuilder:validation:Optional
	Sni *string `json:"sni,omitempty" tf:"sni,omitempty"`

	// +kubebuilder:validation:Optional
	ValidationContext []StreamBackendTLSValidationContextParameters `json:"validationContext,omitempty" tf:"validation_context,omitempty"`
}

type StreamBackendTLSValidationContextInitParameters struct {

	// PEM-encoded trusted CA certificate chain.
	TrustedCABytes *string `json:"trustedCaBytes,omitempty" tf:"trusted_ca_bytes,omitempty"`

	// Trusted CA certificate ID in the Certificate Manager.
	TrustedCAID *string `json:"trustedCaId,omitempty" tf:"trusted_ca_id,omitempty"`
}

type StreamBackendTLSValidationContextObservation struct {

	// PEM-encoded trusted CA certificate chain.
	TrustedCABytes *string `json:"trustedCaBytes,omitempty" tf:"trusted_ca_bytes,omitempty"`

	// Trusted CA certificate ID in the Certificate Manager.
	TrustedCAID *string `json:"trustedCaId,omitempty" tf:"trusted_ca_id,omitempty"`
}

type StreamBackendTLSValidationContextParameters struct {

	// PEM-encoded trusted CA certificate chain.
	// +kubebuilder:validation:Optional
	TrustedCABytes *string `json:"trustedCaBytes,omitempty" tf:"trusted_ca_bytes,omitempty"`

	// Trusted CA certificate ID in the Certificate Manager.
	// +kubebuilder:validation:Optional
	TrustedCAID *string `json:"trustedCaId,omitempty" tf:"trusted_ca_id,omitempty"`
}

type StreamHealthcheckInitParameters struct {

	// Data that must be contained in the messages received from targets for a successful health check. If not specified, no messages are expected from targets, and those that are received are not checked.
	Receive *string `json:"receive,omitempty" tf:"receive,omitempty"`

	// Message sent to targets during TCP data transfer. If not specified, no data is sent to the target.
	Send *string `json:"send,omitempty" tf:"send,omitempty"`
}

type StreamHealthcheckObservation struct {

	// Data that must be contained in the messages received from targets for a successful health check. If not specified, no messages are expected from targets, and those that are received are not checked.
	Receive *string `json:"receive,omitempty" tf:"receive,omitempty"`

	// Message sent to targets during TCP data transfer. If not specified, no data is sent to the target.
	Send *string `json:"send,omitempty" tf:"send,omitempty"`
}

type StreamHealthcheckParameters struct {

	// Data that must be contained in the messages received from targets for a successful health check. If not specified, no messages are expected from targets, and those that are received are not checked.
	// +kubebuilder:validation:Optional
	Receive *string `json:"receive,omitempty" tf:"receive,omitempty"`

	// Message sent to targets during TCP data transfer. If not specified, no data is sent to the target.
	// +kubebuilder:validation:Optional
	Send *string `json:"send,omitempty" tf:"send,omitempty"`
}

type TLSInitParameters struct {

	// SNI string for TLS connections.
	Sni *string `json:"sni,omitempty" tf:"sni,omitempty"`

	ValidationContext []ValidationContextInitParameters `json:"validationContext,omitempty" tf:"validation_context,omitempty"`
}

type TLSObservation struct {

	// SNI string for TLS connections.
	Sni *string `json:"sni,omitempty" tf:"sni,omitempty"`

	ValidationContext []ValidationContextObservation `json:"validationContext,omitempty" tf:"validation_context,omitempty"`
}

type TLSParameters struct {

	// SNI string for TLS connections.
	// +kubebuilder:validation:Optional
	Sni *string `json:"sni,omitempty" tf:"sni,omitempty"`

	// +kubebuilder:validation:Optional
	ValidationContext []ValidationContextParameters `json:"validationContext,omitempty" tf:"validation_context,omitempty"`
}

type TLSValidationContextInitParameters struct {

	// PEM-encoded trusted CA certificate chain.
	TrustedCABytes *string `json:"trustedCaBytes,omitempty" tf:"trusted_ca_bytes,omitempty"`

	// Trusted CA certificate ID in the Certificate Manager.
	TrustedCAID *string `json:"trustedCaId,omitempty" tf:"trusted_ca_id,omitempty"`
}

type TLSValidationContextObservation struct {

	// PEM-encoded trusted CA certificate chain.
	TrustedCABytes *string `json:"trustedCaBytes,omitempty" tf:"trusted_ca_bytes,omitempty"`

	// Trusted CA certificate ID in the Certificate Manager.
	TrustedCAID *string `json:"trustedCaId,omitempty" tf:"trusted_ca_id,omitempty"`
}

type TLSValidationContextParameters struct {

	// PEM-encoded trusted CA certificate chain.
	// +kubebuilder:validation:Optional
	TrustedCABytes *string `json:"trustedCaBytes,omitempty" tf:"trusted_ca_bytes,omitempty"`

	// Trusted CA certificate ID in the Certificate Manager.
	// +kubebuilder:validation:Optional
	TrustedCAID *string `json:"trustedCaId,omitempty" tf:"trusted_ca_id,omitempty"`
}

type ValidationContextInitParameters struct {

	// PEM-encoded trusted CA certificate chain.
	TrustedCABytes *string `json:"trustedCaBytes,omitempty" tf:"trusted_ca_bytes,omitempty"`

	// Trusted CA certificate ID in the Certificate Manager.
	TrustedCAID *string `json:"trustedCaId,omitempty" tf:"trusted_ca_id,omitempty"`
}

type ValidationContextObservation struct {

	// PEM-encoded trusted CA certificate chain.
	TrustedCABytes *string `json:"trustedCaBytes,omitempty" tf:"trusted_ca_bytes,omitempty"`

	// Trusted CA certificate ID in the Certificate Manager.
	TrustedCAID *string `json:"trustedCaId,omitempty" tf:"trusted_ca_id,omitempty"`
}

type ValidationContextParameters struct {

	// PEM-encoded trusted CA certificate chain.
	// +kubebuilder:validation:Optional
	TrustedCABytes *string `json:"trustedCaBytes,omitempty" tf:"trusted_ca_bytes,omitempty"`

	// Trusted CA certificate ID in the Certificate Manager.
	// +kubebuilder:validation:Optional
	TrustedCAID *string `json:"trustedCaId,omitempty" tf:"trusted_ca_id,omitempty"`
}

// BackendGroupSpec defines the desired state of BackendGroup
type BackendGroupSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     BackendGroupParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider BackendGroupInitParameters `json:"initProvider,omitempty"`
}

// BackendGroupStatus defines the observed state of BackendGroup.
type BackendGroupStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        BackendGroupObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// BackendGroup is the Schema for the BackendGroups API. An application load balancer distributes the load across cloud resources that are combined into a backend group.
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,yandex-cloud}
type BackendGroup struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              BackendGroupSpec   `json:"spec"`
	Status            BackendGroupStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// BackendGroupList contains a list of BackendGroups
type BackendGroupList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []BackendGroup `json:"items"`
}

// Repository type metadata.
var (
	BackendGroup_Kind             = "BackendGroup"
	BackendGroup_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: BackendGroup_Kind}.String()
	BackendGroup_KindAPIVersion   = BackendGroup_Kind + "." + CRDGroupVersion.String()
	BackendGroup_GroupVersionKind = CRDGroupVersion.WithKind(BackendGroup_Kind)
)

func init() {
	SchemeBuilder.Register(&BackendGroup{}, &BackendGroupList{})
}
