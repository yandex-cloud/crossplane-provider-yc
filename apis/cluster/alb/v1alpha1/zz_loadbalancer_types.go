/*
Copyright 2022 YANDEX LLC
This is modified version of the software, made by the Crossplane Authors
and available at: https://github.com/crossplane-contrib/provider-jet-template

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/v2/apis/common/v1"
)

type AddressInitParameters struct {

	// (Block List, Max: 1) External IPv4 address. (see below for nested schema)
	// External IPv4 address.
	ExternalIPv4Address []ExternalIPv4AddressInitParameters `json:"externalIpv4Address,omitempty" tf:"external_ipv4_address,omitempty"`

	// (Block List, Max: 1) External IPv6 address. (see below for nested schema)
	// External IPv6 address.
	ExternalIPv6Address []ExternalIPv6AddressInitParameters `json:"externalIpv6Address,omitempty" tf:"external_ipv6_address,omitempty"`

	// (Block List, Max: 1) Internal IPv4 address. (see below for nested schema)
	// Internal IPv4 address.
	InternalIPv4Address []InternalIPv4AddressInitParameters `json:"internalIpv4Address,omitempty" tf:"internal_ipv4_address,omitempty"`
}

type AddressObservation struct {

	// (Block List, Max: 1) External IPv4 address. (see below for nested schema)
	// External IPv4 address.
	ExternalIPv4Address []ExternalIPv4AddressObservation `json:"externalIpv4Address,omitempty" tf:"external_ipv4_address,omitempty"`

	// (Block List, Max: 1) External IPv6 address. (see below for nested schema)
	// External IPv6 address.
	ExternalIPv6Address []ExternalIPv6AddressObservation `json:"externalIpv6Address,omitempty" tf:"external_ipv6_address,omitempty"`

	// (Block List, Max: 1) Internal IPv4 address. (see below for nested schema)
	// Internal IPv4 address.
	InternalIPv4Address []InternalIPv4AddressObservation `json:"internalIpv4Address,omitempty" tf:"internal_ipv4_address,omitempty"`
}

type AddressParameters struct {

	// (Block List, Max: 1) External IPv4 address. (see below for nested schema)
	// External IPv4 address.
	// +kubebuilder:validation:Optional
	ExternalIPv4Address []ExternalIPv4AddressParameters `json:"externalIpv4Address,omitempty" tf:"external_ipv4_address,omitempty"`

	// (Block List, Max: 1) External IPv6 address. (see below for nested schema)
	// External IPv6 address.
	// +kubebuilder:validation:Optional
	ExternalIPv6Address []ExternalIPv6AddressParameters `json:"externalIpv6Address,omitempty" tf:"external_ipv6_address,omitempty"`

	// (Block List, Max: 1) Internal IPv4 address. (see below for nested schema)
	// Internal IPv4 address.
	// +kubebuilder:validation:Optional
	InternalIPv4Address []InternalIPv4AddressParameters `json:"internalIpv4Address,omitempty" tf:"internal_ipv4_address,omitempty"`
}

type AllocationPolicyInitParameters struct {

	// (Block Set, Min: 1) Unique set of locations. (see below for nested schema)
	// Unique set of locations.
	Location []LocationInitParameters `json:"location,omitempty" tf:"location,omitempty"`
}

type AllocationPolicyObservation struct {

	// (Block Set, Min: 1) Unique set of locations. (see below for nested schema)
	// Unique set of locations.
	Location []LocationObservation `json:"location,omitempty" tf:"location,omitempty"`
}

type AllocationPolicyParameters struct {

	// (Block Set, Min: 1) Unique set of locations. (see below for nested schema)
	// Unique set of locations.
	// +kubebuilder:validation:Optional
	Location []LocationParameters `json:"location" tf:"location,omitempty"`
}

type AutoScalePolicyInitParameters struct {

	// (Number) Upper limit for total instance count (across all zones)
	// Upper limit for total instance count (across all zones)
	MaxSize *float64 `json:"maxSize,omitempty" tf:"max_size,omitempty"`

	// (Number) Lower limit for instance count in each zone.
	// Lower limit for instance count in each zone.
	MinZoneSize *float64 `json:"minZoneSize,omitempty" tf:"min_zone_size,omitempty"`
}

type AutoScalePolicyObservation struct {

	// (Number) Upper limit for total instance count (across all zones)
	// Upper limit for total instance count (across all zones)
	MaxSize *float64 `json:"maxSize,omitempty" tf:"max_size,omitempty"`

	// (Number) Lower limit for instance count in each zone.
	// Lower limit for instance count in each zone.
	MinZoneSize *float64 `json:"minZoneSize,omitempty" tf:"min_zone_size,omitempty"`
}

type AutoScalePolicyParameters struct {

	// (Number) Upper limit for total instance count (across all zones)
	// Upper limit for total instance count (across all zones)
	// +kubebuilder:validation:Optional
	MaxSize *float64 `json:"maxSize,omitempty" tf:"max_size,omitempty"`

	// (Number) Lower limit for instance count in each zone.
	// Lower limit for instance count in each zone.
	// +kubebuilder:validation:Optional
	MinZoneSize *float64 `json:"minZoneSize,omitempty" tf:"min_zone_size,omitempty"`
}

type DefaultHandlerInitParameters struct {

	// (Set of String) Certificate IDs in the Certificate Manager. Multiple TLS certificates can be associated with the same context to allow both RSA and ECDSA certificates. Only the first certificate of each type will be used.
	// Certificate IDs in the Certificate Manager. Multiple TLS certificates can be associated with the same context to allow both RSA and ECDSA certificates. Only the first certificate of each type will be used.
	// +listType=set
	CertificateIds []*string `json:"certificateIds,omitempty" tf:"certificate_ids,omitempty"`

	// (Block List, Max: 1) HTTP handler. (see below for nested schema)
	// HTTP handler.
	HTTPHandler []HTTPHandlerInitParameters `json:"httpHandler,omitempty" tf:"http_handler,omitempty"`

	// (Block List, Max: 1) Stream handler resource. (see below for nested schema)
	// Stream handler resource.
	StreamHandler []DefaultHandlerStreamHandlerInitParameters `json:"streamHandler,omitempty" tf:"stream_handler,omitempty"`
}

type DefaultHandlerObservation struct {

	// (Set of String) Certificate IDs in the Certificate Manager. Multiple TLS certificates can be associated with the same context to allow both RSA and ECDSA certificates. Only the first certificate of each type will be used.
	// Certificate IDs in the Certificate Manager. Multiple TLS certificates can be associated with the same context to allow both RSA and ECDSA certificates. Only the first certificate of each type will be used.
	// +listType=set
	CertificateIds []*string `json:"certificateIds,omitempty" tf:"certificate_ids,omitempty"`

	// (Block List, Max: 1) HTTP handler. (see below for nested schema)
	// HTTP handler.
	HTTPHandler []HTTPHandlerObservation `json:"httpHandler,omitempty" tf:"http_handler,omitempty"`

	// (Block List, Max: 1) Stream handler resource. (see below for nested schema)
	// Stream handler resource.
	StreamHandler []DefaultHandlerStreamHandlerObservation `json:"streamHandler,omitempty" tf:"stream_handler,omitempty"`
}

type DefaultHandlerParameters struct {

	// (Set of String) Certificate IDs in the Certificate Manager. Multiple TLS certificates can be associated with the same context to allow both RSA and ECDSA certificates. Only the first certificate of each type will be used.
	// Certificate IDs in the Certificate Manager. Multiple TLS certificates can be associated with the same context to allow both RSA and ECDSA certificates. Only the first certificate of each type will be used.
	// +kubebuilder:validation:Optional
	// +listType=set
	CertificateIds []*string `json:"certificateIds" tf:"certificate_ids,omitempty"`

	// (Block List, Max: 1) HTTP handler. (see below for nested schema)
	// HTTP handler.
	// +kubebuilder:validation:Optional
	HTTPHandler []HTTPHandlerParameters `json:"httpHandler,omitempty" tf:"http_handler,omitempty"`

	// (Block List, Max: 1) Stream handler resource. (see below for nested schema)
	// Stream handler resource.
	// +kubebuilder:validation:Optional
	StreamHandler []DefaultHandlerStreamHandlerParameters `json:"streamHandler,omitempty" tf:"stream_handler,omitempty"`
}

type DefaultHandlerStreamHandlerInitParameters struct {

	// (String) Backend Group ID.
	// Backend Group ID.
	BackendGroupID *string `json:"backendGroupId,omitempty" tf:"backend_group_id,omitempty"`

	// (String) The idle timeout is the interval after which the connection will be forcibly closed if no data has been transmitted or received on either the upstream or downstream connection. If not configured, the default idle timeout is 1 hour. Setting it to 0 disables the timeout.
	// The idle timeout is the interval after which the connection will be forcibly closed if no data has been transmitted or received on either the upstream or downstream connection. If not configured, the default idle timeout is 1 hour. Setting it to 0 disables the timeout.
	IdleTimeout *string `json:"idleTimeout,omitempty" tf:"idle_timeout,omitempty"`
}

type DefaultHandlerStreamHandlerObservation struct {

	// (String) Backend Group ID.
	// Backend Group ID.
	BackendGroupID *string `json:"backendGroupId,omitempty" tf:"backend_group_id,omitempty"`

	// (String) The idle timeout is the interval after which the connection will be forcibly closed if no data has been transmitted or received on either the upstream or downstream connection. If not configured, the default idle timeout is 1 hour. Setting it to 0 disables the timeout.
	// The idle timeout is the interval after which the connection will be forcibly closed if no data has been transmitted or received on either the upstream or downstream connection. If not configured, the default idle timeout is 1 hour. Setting it to 0 disables the timeout.
	IdleTimeout *string `json:"idleTimeout,omitempty" tf:"idle_timeout,omitempty"`
}

type DefaultHandlerStreamHandlerParameters struct {

	// (String) Backend Group ID.
	// Backend Group ID.
	// +kubebuilder:validation:Optional
	BackendGroupID *string `json:"backendGroupId,omitempty" tf:"backend_group_id,omitempty"`

	// (String) The idle timeout is the interval after which the connection will be forcibly closed if no data has been transmitted or received on either the upstream or downstream connection. If not configured, the default idle timeout is 1 hour. Setting it to 0 disables the timeout.
	// The idle timeout is the interval after which the connection will be forcibly closed if no data has been transmitted or received on either the upstream or downstream connection. If not configured, the default idle timeout is 1 hour. Setting it to 0 disables the timeout.
	// +kubebuilder:validation:Optional
	IdleTimeout *string `json:"idleTimeout,omitempty" tf:"idle_timeout,omitempty"`
}

type DiscardRuleInitParameters struct {

	// (Number) The percent of logs which will be discarded.
	// The percent of logs which will be discarded.
	DiscardPercent *float64 `json:"discardPercent,omitempty" tf:"discard_percent,omitempty"`

	// (List of String) list of grpc codes by name, e.g, [NOT_FOUND, RESOURCE_EXHAUSTED].
	// list of grpc codes by name, e.g, [**NOT_FOUND**, **RESOURCE_EXHAUSTED**].
	GRPCCodes []*string `json:"grpcCodes,omitempty" tf:"grpc_codes,omitempty"`

	// 5XX or ALL
	// List of http code intervals *1XX*-*5XX* or *ALL*
	HTTPCodeIntervals []*string `json:"httpCodeIntervals,omitempty" tf:"http_code_intervals,omitempty"`

	// 599.
	// List of http codes *100*-*599*.
	HTTPCodes []*float64 `json:"httpCodes,omitempty" tf:"http_codes,omitempty"`
}

type DiscardRuleObservation struct {

	// (Number) The percent of logs which will be discarded.
	// The percent of logs which will be discarded.
	DiscardPercent *float64 `json:"discardPercent,omitempty" tf:"discard_percent,omitempty"`

	// (List of String) list of grpc codes by name, e.g, [NOT_FOUND, RESOURCE_EXHAUSTED].
	// list of grpc codes by name, e.g, [**NOT_FOUND**, **RESOURCE_EXHAUSTED**].
	GRPCCodes []*string `json:"grpcCodes,omitempty" tf:"grpc_codes,omitempty"`

	// 5XX or ALL
	// List of http code intervals *1XX*-*5XX* or *ALL*
	HTTPCodeIntervals []*string `json:"httpCodeIntervals,omitempty" tf:"http_code_intervals,omitempty"`

	// 599.
	// List of http codes *100*-*599*.
	HTTPCodes []*float64 `json:"httpCodes,omitempty" tf:"http_codes,omitempty"`
}

type DiscardRuleParameters struct {

	// (Number) The percent of logs which will be discarded.
	// The percent of logs which will be discarded.
	// +kubebuilder:validation:Optional
	DiscardPercent *float64 `json:"discardPercent,omitempty" tf:"discard_percent,omitempty"`

	// (List of String) list of grpc codes by name, e.g, [NOT_FOUND, RESOURCE_EXHAUSTED].
	// list of grpc codes by name, e.g, [**NOT_FOUND**, **RESOURCE_EXHAUSTED**].
	// +kubebuilder:validation:Optional
	GRPCCodes []*string `json:"grpcCodes,omitempty" tf:"grpc_codes,omitempty"`

	// 5XX or ALL
	// List of http code intervals *1XX*-*5XX* or *ALL*
	// +kubebuilder:validation:Optional
	HTTPCodeIntervals []*string `json:"httpCodeIntervals,omitempty" tf:"http_code_intervals,omitempty"`

	// 599.
	// List of http codes *100*-*599*.
	// +kubebuilder:validation:Optional
	HTTPCodes []*float64 `json:"httpCodes,omitempty" tf:"http_codes,omitempty"`
}

type EndpointInitParameters struct {

	// (Block List, Min: 1) One or more addresses to listen on. (see below for nested schema)
	// One or more addresses to listen on.
	Address []AddressInitParameters `json:"address,omitempty" tf:"address,omitempty"`

	// (List of Number) One or more ports to listen on.
	// One or more ports to listen on.
	Ports []*float64 `json:"ports,omitempty" tf:"ports,omitempty"`
}

type EndpointObservation struct {

	// (Block List, Min: 1) One or more addresses to listen on. (see below for nested schema)
	// One or more addresses to listen on.
	Address []AddressObservation `json:"address,omitempty" tf:"address,omitempty"`

	// (List of Number) One or more ports to listen on.
	// One or more ports to listen on.
	Ports []*float64 `json:"ports,omitempty" tf:"ports,omitempty"`
}

type EndpointParameters struct {

	// (Block List, Min: 1) One or more addresses to listen on. (see below for nested schema)
	// One or more addresses to listen on.
	// +kubebuilder:validation:Optional
	Address []AddressParameters `json:"address" tf:"address,omitempty"`

	// (List of Number) One or more ports to listen on.
	// One or more ports to listen on.
	// +kubebuilder:validation:Optional
	Ports []*float64 `json:"ports" tf:"ports,omitempty"`
}

type ExternalIPv4AddressInitParameters struct {

	// (Block List, Min: 1) One or more addresses to listen on. (see below for nested schema)
	// Provided by the client or computed automatically.
	Address *string `json:"address,omitempty" tf:"address,omitempty"`
}

type ExternalIPv4AddressObservation struct {

	// (Block List, Min: 1) One or more addresses to listen on. (see below for nested schema)
	// Provided by the client or computed automatically.
	Address *string `json:"address,omitempty" tf:"address,omitempty"`
}

type ExternalIPv4AddressParameters struct {

	// (Block List, Min: 1) One or more addresses to listen on. (see below for nested schema)
	// Provided by the client or computed automatically.
	// +kubebuilder:validation:Optional
	Address *string `json:"address,omitempty" tf:"address,omitempty"`
}

type ExternalIPv6AddressInitParameters struct {

	// (Block List, Min: 1) One or more addresses to listen on. (see below for nested schema)
	// Provided by the client or computed automatically.
	Address *string `json:"address,omitempty" tf:"address,omitempty"`
}

type ExternalIPv6AddressObservation struct {

	// (Block List, Min: 1) One or more addresses to listen on. (see below for nested schema)
	// Provided by the client or computed automatically.
	Address *string `json:"address,omitempty" tf:"address,omitempty"`
}

type ExternalIPv6AddressParameters struct {

	// (Block List, Min: 1) One or more addresses to listen on. (see below for nested schema)
	// Provided by the client or computed automatically.
	// +kubebuilder:validation:Optional
	Address *string `json:"address,omitempty" tf:"address,omitempty"`
}

type HTTPHandlerHttp2OptionsInitParameters struct {

	// (Number) Maximum number of concurrent streams.
	// Maximum number of concurrent streams.
	MaxConcurrentStreams *float64 `json:"maxConcurrentStreams,omitempty" tf:"max_concurrent_streams,omitempty"`
}

type HTTPHandlerHttp2OptionsObservation struct {

	// (Number) Maximum number of concurrent streams.
	// Maximum number of concurrent streams.
	MaxConcurrentStreams *float64 `json:"maxConcurrentStreams,omitempty" tf:"max_concurrent_streams,omitempty"`
}

type HTTPHandlerHttp2OptionsParameters struct {

	// (Number) Maximum number of concurrent streams.
	// Maximum number of concurrent streams.
	// +kubebuilder:validation:Optional
	MaxConcurrentStreams *float64 `json:"maxConcurrentStreams,omitempty" tf:"max_concurrent_streams,omitempty"`
}

type HTTPHandlerInitParameters struct {

	// (Boolean) If set, will enable only HTTP1 protocol with HTTP1.0 support.
	// If set, will enable only HTTP1 protocol with HTTP1.0 support.
	AllowHttp10 *bool `json:"allowHttp10,omitempty" tf:"allow_http10,omitempty"`

	// (String) HTTP router id.
	// HTTP router id.
	HTTPRouterID *string `json:"httpRouterId,omitempty" tf:"http_router_id,omitempty"`

	// (Block List, Max: 1) If set, will enable HTTP2 protocol for the handler. (see below for nested schema)
	// If set, will enable HTTP2 protocol for the handler.
	Http2Options []HTTPHandlerHttp2OptionsInitParameters `json:"http2Options,omitempty" tf:"http2_options,omitempty"`

	// request-id header, otherwise would rewrite it with a new value.
	// When unset, will preserve the incoming `x-request-id` header, otherwise would rewrite it with a new value.
	RewriteRequestID *bool `json:"rewriteRequestId,omitempty" tf:"rewrite_request_id,omitempty"`
}

type HTTPHandlerObservation struct {

	// (Boolean) If set, will enable only HTTP1 protocol with HTTP1.0 support.
	// If set, will enable only HTTP1 protocol with HTTP1.0 support.
	AllowHttp10 *bool `json:"allowHttp10,omitempty" tf:"allow_http10,omitempty"`

	// (String) HTTP router id.
	// HTTP router id.
	HTTPRouterID *string `json:"httpRouterId,omitempty" tf:"http_router_id,omitempty"`

	// (Block List, Max: 1) If set, will enable HTTP2 protocol for the handler. (see below for nested schema)
	// If set, will enable HTTP2 protocol for the handler.
	Http2Options []HTTPHandlerHttp2OptionsObservation `json:"http2Options,omitempty" tf:"http2_options,omitempty"`

	// request-id header, otherwise would rewrite it with a new value.
	// When unset, will preserve the incoming `x-request-id` header, otherwise would rewrite it with a new value.
	RewriteRequestID *bool `json:"rewriteRequestId,omitempty" tf:"rewrite_request_id,omitempty"`
}

type HTTPHandlerParameters struct {

	// (Boolean) If set, will enable only HTTP1 protocol with HTTP1.0 support.
	// If set, will enable only HTTP1 protocol with HTTP1.0 support.
	// +kubebuilder:validation:Optional
	AllowHttp10 *bool `json:"allowHttp10,omitempty" tf:"allow_http10,omitempty"`

	// (String) HTTP router id.
	// HTTP router id.
	// +kubebuilder:validation:Optional
	HTTPRouterID *string `json:"httpRouterId,omitempty" tf:"http_router_id,omitempty"`

	// (Block List, Max: 1) If set, will enable HTTP2 protocol for the handler. (see below for nested schema)
	// If set, will enable HTTP2 protocol for the handler.
	// +kubebuilder:validation:Optional
	Http2Options []HTTPHandlerHttp2OptionsParameters `json:"http2Options,omitempty" tf:"http2_options,omitempty"`

	// request-id header, otherwise would rewrite it with a new value.
	// When unset, will preserve the incoming `x-request-id` header, otherwise would rewrite it with a new value.
	// +kubebuilder:validation:Optional
	RewriteRequestID *bool `json:"rewriteRequestId,omitempty" tf:"rewrite_request_id,omitempty"`
}

type HTTPInitParameters struct {

	// (Block List, Max: 1) HTTP handler. (see below for nested schema)
	// HTTP handler.
	Handler []HandlerInitParameters `json:"handler,omitempty" tf:"handler,omitempty"`

	// > https redirects. (see below for nested schema)
	// Shortcut for adding http -> https redirects.
	Redirects []RedirectsInitParameters `json:"redirects,omitempty" tf:"redirects,omitempty"`
}

type HTTPObservation struct {

	// (Block List, Max: 1) HTTP handler. (see below for nested schema)
	// HTTP handler.
	Handler []HandlerObservation `json:"handler,omitempty" tf:"handler,omitempty"`

	// > https redirects. (see below for nested schema)
	// Shortcut for adding http -> https redirects.
	Redirects []RedirectsObservation `json:"redirects,omitempty" tf:"redirects,omitempty"`
}

type HTTPParameters struct {

	// (Block List, Max: 1) HTTP handler. (see below for nested schema)
	// HTTP handler.
	// +kubebuilder:validation:Optional
	Handler []HandlerParameters `json:"handler,omitempty" tf:"handler,omitempty"`

	// > https redirects. (see below for nested schema)
	// Shortcut for adding http -> https redirects.
	// +kubebuilder:validation:Optional
	Redirects []RedirectsParameters `json:"redirects,omitempty" tf:"redirects,omitempty"`
}

type HandlerHTTPHandlerHttp2OptionsInitParameters struct {

	// (Number) Maximum number of concurrent streams.
	// Maximum number of concurrent streams.
	MaxConcurrentStreams *float64 `json:"maxConcurrentStreams,omitempty" tf:"max_concurrent_streams,omitempty"`
}

type HandlerHTTPHandlerHttp2OptionsObservation struct {

	// (Number) Maximum number of concurrent streams.
	// Maximum number of concurrent streams.
	MaxConcurrentStreams *float64 `json:"maxConcurrentStreams,omitempty" tf:"max_concurrent_streams,omitempty"`
}

type HandlerHTTPHandlerHttp2OptionsParameters struct {

	// (Number) Maximum number of concurrent streams.
	// Maximum number of concurrent streams.
	// +kubebuilder:validation:Optional
	MaxConcurrentStreams *float64 `json:"maxConcurrentStreams,omitempty" tf:"max_concurrent_streams,omitempty"`
}

type HandlerHTTPHandlerInitParameters struct {

	// (Boolean) If set, will enable only HTTP1 protocol with HTTP1.0 support.
	// If set, will enable only HTTP1 protocol with HTTP1.0 support.
	AllowHttp10 *bool `json:"allowHttp10,omitempty" tf:"allow_http10,omitempty"`

	// (String) HTTP router id.
	// HTTP router id.
	HTTPRouterID *string `json:"httpRouterId,omitempty" tf:"http_router_id,omitempty"`

	// (Block List, Max: 1) If set, will enable HTTP2 protocol for the handler. (see below for nested schema)
	// If set, will enable HTTP2 protocol for the handler.
	Http2Options []HandlerHTTPHandlerHttp2OptionsInitParameters `json:"http2Options,omitempty" tf:"http2_options,omitempty"`

	// request-id header, otherwise would rewrite it with a new value.
	// When unset, will preserve the incoming `x-request-id` header, otherwise would rewrite it with a new value.
	RewriteRequestID *bool `json:"rewriteRequestId,omitempty" tf:"rewrite_request_id,omitempty"`
}

type HandlerHTTPHandlerObservation struct {

	// (Boolean) If set, will enable only HTTP1 protocol with HTTP1.0 support.
	// If set, will enable only HTTP1 protocol with HTTP1.0 support.
	AllowHttp10 *bool `json:"allowHttp10,omitempty" tf:"allow_http10,omitempty"`

	// (String) HTTP router id.
	// HTTP router id.
	HTTPRouterID *string `json:"httpRouterId,omitempty" tf:"http_router_id,omitempty"`

	// (Block List, Max: 1) If set, will enable HTTP2 protocol for the handler. (see below for nested schema)
	// If set, will enable HTTP2 protocol for the handler.
	Http2Options []HandlerHTTPHandlerHttp2OptionsObservation `json:"http2Options,omitempty" tf:"http2_options,omitempty"`

	// request-id header, otherwise would rewrite it with a new value.
	// When unset, will preserve the incoming `x-request-id` header, otherwise would rewrite it with a new value.
	RewriteRequestID *bool `json:"rewriteRequestId,omitempty" tf:"rewrite_request_id,omitempty"`
}

type HandlerHTTPHandlerParameters struct {

	// (Boolean) If set, will enable only HTTP1 protocol with HTTP1.0 support.
	// If set, will enable only HTTP1 protocol with HTTP1.0 support.
	// +kubebuilder:validation:Optional
	AllowHttp10 *bool `json:"allowHttp10,omitempty" tf:"allow_http10,omitempty"`

	// (String) HTTP router id.
	// HTTP router id.
	// +kubebuilder:validation:Optional
	HTTPRouterID *string `json:"httpRouterId,omitempty" tf:"http_router_id,omitempty"`

	// (Block List, Max: 1) If set, will enable HTTP2 protocol for the handler. (see below for nested schema)
	// If set, will enable HTTP2 protocol for the handler.
	// +kubebuilder:validation:Optional
	Http2Options []HandlerHTTPHandlerHttp2OptionsParameters `json:"http2Options,omitempty" tf:"http2_options,omitempty"`

	// request-id header, otherwise would rewrite it with a new value.
	// When unset, will preserve the incoming `x-request-id` header, otherwise would rewrite it with a new value.
	// +kubebuilder:validation:Optional
	RewriteRequestID *bool `json:"rewriteRequestId,omitempty" tf:"rewrite_request_id,omitempty"`
}

type HandlerInitParameters struct {

	// (Boolean) If set, will enable only HTTP1 protocol with HTTP1.0 support.
	// If set, will enable only HTTP1 protocol with HTTP1.0 support.
	AllowHttp10 *bool `json:"allowHttp10,omitempty" tf:"allow_http10,omitempty"`

	// (String) HTTP router id.
	// HTTP router id.
	// +crossplane:generate:reference:type=HTTPRouter
	HTTPRouterID *string `json:"httpRouterId,omitempty" tf:"http_router_id,omitempty"`

	// Reference to a HTTPRouter to populate httpRouterId.
	// +kubebuilder:validation:Optional
	HTTPRouterIDRef *v1.Reference `json:"httpRouterIdRef,omitempty" tf:"-"`

	// Selector for a HTTPRouter to populate httpRouterId.
	// +kubebuilder:validation:Optional
	HTTPRouterIDSelector *v1.Selector `json:"httpRouterIdSelector,omitempty" tf:"-"`

	// (Block List, Max: 1) If set, will enable HTTP2 protocol for the handler. (see below for nested schema)
	// If set, will enable HTTP2 protocol for the handler.
	Http2Options []Http2OptionsInitParameters `json:"http2Options,omitempty" tf:"http2_options,omitempty"`

	// request-id header, otherwise would rewrite it with a new value.
	// When unset, will preserve the incoming `x-request-id` header, otherwise would rewrite it with a new value.
	RewriteRequestID *bool `json:"rewriteRequestId,omitempty" tf:"rewrite_request_id,omitempty"`
}

type HandlerObservation struct {

	// (Boolean) If set, will enable only HTTP1 protocol with HTTP1.0 support.
	// If set, will enable only HTTP1 protocol with HTTP1.0 support.
	AllowHttp10 *bool `json:"allowHttp10,omitempty" tf:"allow_http10,omitempty"`

	// (String) HTTP router id.
	// HTTP router id.
	HTTPRouterID *string `json:"httpRouterId,omitempty" tf:"http_router_id,omitempty"`

	// (Block List, Max: 1) If set, will enable HTTP2 protocol for the handler. (see below for nested schema)
	// If set, will enable HTTP2 protocol for the handler.
	Http2Options []Http2OptionsObservation `json:"http2Options,omitempty" tf:"http2_options,omitempty"`

	// request-id header, otherwise would rewrite it with a new value.
	// When unset, will preserve the incoming `x-request-id` header, otherwise would rewrite it with a new value.
	RewriteRequestID *bool `json:"rewriteRequestId,omitempty" tf:"rewrite_request_id,omitempty"`
}

type HandlerParameters struct {

	// (Boolean) If set, will enable only HTTP1 protocol with HTTP1.0 support.
	// If set, will enable only HTTP1 protocol with HTTP1.0 support.
	// +kubebuilder:validation:Optional
	AllowHttp10 *bool `json:"allowHttp10,omitempty" tf:"allow_http10,omitempty"`

	// (String) HTTP router id.
	// HTTP router id.
	// +crossplane:generate:reference:type=HTTPRouter
	// +kubebuilder:validation:Optional
	HTTPRouterID *string `json:"httpRouterId,omitempty" tf:"http_router_id,omitempty"`

	// Reference to a HTTPRouter to populate httpRouterId.
	// +kubebuilder:validation:Optional
	HTTPRouterIDRef *v1.Reference `json:"httpRouterIdRef,omitempty" tf:"-"`

	// Selector for a HTTPRouter to populate httpRouterId.
	// +kubebuilder:validation:Optional
	HTTPRouterIDSelector *v1.Selector `json:"httpRouterIdSelector,omitempty" tf:"-"`

	// (Block List, Max: 1) If set, will enable HTTP2 protocol for the handler. (see below for nested schema)
	// If set, will enable HTTP2 protocol for the handler.
	// +kubebuilder:validation:Optional
	Http2Options []Http2OptionsParameters `json:"http2Options,omitempty" tf:"http2_options,omitempty"`

	// request-id header, otherwise would rewrite it with a new value.
	// When unset, will preserve the incoming `x-request-id` header, otherwise would rewrite it with a new value.
	// +kubebuilder:validation:Optional
	RewriteRequestID *bool `json:"rewriteRequestId,omitempty" tf:"rewrite_request_id,omitempty"`
}

type HandlerStreamHandlerInitParameters struct {

	// (String) Backend Group ID.
	// Backend Group ID.
	BackendGroupID *string `json:"backendGroupId,omitempty" tf:"backend_group_id,omitempty"`

	// (String) The idle timeout is the interval after which the connection will be forcibly closed if no data has been transmitted or received on either the upstream or downstream connection. If not configured, the default idle timeout is 1 hour. Setting it to 0 disables the timeout.
	// The idle timeout is the interval after which the connection will be forcibly closed if no data has been transmitted or received on either the upstream or downstream connection. If not configured, the default idle timeout is 1 hour. Setting it to 0 disables the timeout.
	IdleTimeout *string `json:"idleTimeout,omitempty" tf:"idle_timeout,omitempty"`
}

type HandlerStreamHandlerObservation struct {

	// (String) Backend Group ID.
	// Backend Group ID.
	BackendGroupID *string `json:"backendGroupId,omitempty" tf:"backend_group_id,omitempty"`

	// (String) The idle timeout is the interval after which the connection will be forcibly closed if no data has been transmitted or received on either the upstream or downstream connection. If not configured, the default idle timeout is 1 hour. Setting it to 0 disables the timeout.
	// The idle timeout is the interval after which the connection will be forcibly closed if no data has been transmitted or received on either the upstream or downstream connection. If not configured, the default idle timeout is 1 hour. Setting it to 0 disables the timeout.
	IdleTimeout *string `json:"idleTimeout,omitempty" tf:"idle_timeout,omitempty"`
}

type HandlerStreamHandlerParameters struct {

	// (String) Backend Group ID.
	// Backend Group ID.
	// +kubebuilder:validation:Optional
	BackendGroupID *string `json:"backendGroupId,omitempty" tf:"backend_group_id,omitempty"`

	// (String) The idle timeout is the interval after which the connection will be forcibly closed if no data has been transmitted or received on either the upstream or downstream connection. If not configured, the default idle timeout is 1 hour. Setting it to 0 disables the timeout.
	// The idle timeout is the interval after which the connection will be forcibly closed if no data has been transmitted or received on either the upstream or downstream connection. If not configured, the default idle timeout is 1 hour. Setting it to 0 disables the timeout.
	// +kubebuilder:validation:Optional
	IdleTimeout *string `json:"idleTimeout,omitempty" tf:"idle_timeout,omitempty"`
}

type Http2OptionsInitParameters struct {

	// (Number) Maximum number of concurrent streams.
	// Maximum number of concurrent streams.
	MaxConcurrentStreams *float64 `json:"maxConcurrentStreams,omitempty" tf:"max_concurrent_streams,omitempty"`
}

type Http2OptionsObservation struct {

	// (Number) Maximum number of concurrent streams.
	// Maximum number of concurrent streams.
	MaxConcurrentStreams *float64 `json:"maxConcurrentStreams,omitempty" tf:"max_concurrent_streams,omitempty"`
}

type Http2OptionsParameters struct {

	// (Number) Maximum number of concurrent streams.
	// Maximum number of concurrent streams.
	// +kubebuilder:validation:Optional
	MaxConcurrentStreams *float64 `json:"maxConcurrentStreams,omitempty" tf:"max_concurrent_streams,omitempty"`
}

type InternalIPv4AddressInitParameters struct {

	// (Block List, Min: 1) One or more addresses to listen on. (see below for nested schema)
	// Provided by the client or computed automatically.
	Address *string `json:"address,omitempty" tf:"address,omitempty"`

	// (String) ID of the subnet that location is located at.
	// ID of the subnet that the address belongs to.
	// +crossplane:generate:reference:type=github.com/yandex-cloud/crossplane-provider-yc/apis/cluster/vpc/v1alpha1.Subnet
	SubnetID *string `json:"subnetId,omitempty" tf:"subnet_id,omitempty"`

	// Reference to a Subnet in vpc to populate subnetId.
	// +kubebuilder:validation:Optional
	SubnetIDRef *v1.Reference `json:"subnetIdRef,omitempty" tf:"-"`

	// Selector for a Subnet in vpc to populate subnetId.
	// +kubebuilder:validation:Optional
	SubnetIDSelector *v1.Selector `json:"subnetIdSelector,omitempty" tf:"-"`
}

type InternalIPv4AddressObservation struct {

	// (Block List, Min: 1) One or more addresses to listen on. (see below for nested schema)
	// Provided by the client or computed automatically.
	Address *string `json:"address,omitempty" tf:"address,omitempty"`

	// (String) ID of the subnet that location is located at.
	// ID of the subnet that the address belongs to.
	SubnetID *string `json:"subnetId,omitempty" tf:"subnet_id,omitempty"`
}

type InternalIPv4AddressParameters struct {

	// (Block List, Min: 1) One or more addresses to listen on. (see below for nested schema)
	// Provided by the client or computed automatically.
	// +kubebuilder:validation:Optional
	Address *string `json:"address,omitempty" tf:"address,omitempty"`

	// (String) ID of the subnet that location is located at.
	// ID of the subnet that the address belongs to.
	// +crossplane:generate:reference:type=github.com/yandex-cloud/crossplane-provider-yc/apis/cluster/vpc/v1alpha1.Subnet
	// +kubebuilder:validation:Optional
	SubnetID *string `json:"subnetId,omitempty" tf:"subnet_id,omitempty"`

	// Reference to a Subnet in vpc to populate subnetId.
	// +kubebuilder:validation:Optional
	SubnetIDRef *v1.Reference `json:"subnetIdRef,omitempty" tf:"-"`

	// Selector for a Subnet in vpc to populate subnetId.
	// +kubebuilder:validation:Optional
	SubnetIDSelector *v1.Selector `json:"subnetIdSelector,omitempty" tf:"-"`
}

type ListenerInitParameters struct {

	// (Block List) Network endpoint (addresses and ports) of the listener. (see below for nested schema)
	// Network endpoint (addresses and ports) of the listener.
	Endpoint []EndpointInitParameters `json:"endpoint,omitempty" tf:"endpoint,omitempty"`

	// (Block List, Max: 1) HTTP handler that sets plain text HTTP router. (see below for nested schema)
	// HTTP handler that sets plain text HTTP router.
	HTTP []HTTPInitParameters `json:"http,omitempty" tf:"http,omitempty"`

	// (String) The resource name.
	// Name of the listener.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (Block List, Max: 1) Stream configuration (see below for nested schema)
	// Stream configuration
	Stream []StreamInitParameters `json:"stream,omitempty" tf:"stream,omitempty"`

	// (Block List, Max: 1) TLS configuration (see below for nested schema)
	// TLS configuration
	TLS []ListenerTLSInitParameters `json:"tls,omitempty" tf:"tls,omitempty"`
}

type ListenerObservation struct {

	// (Block List) Network endpoint (addresses and ports) of the listener. (see below for nested schema)
	// Network endpoint (addresses and ports) of the listener.
	Endpoint []EndpointObservation `json:"endpoint,omitempty" tf:"endpoint,omitempty"`

	// (Block List, Max: 1) HTTP handler that sets plain text HTTP router. (see below for nested schema)
	// HTTP handler that sets plain text HTTP router.
	HTTP []HTTPObservation `json:"http,omitempty" tf:"http,omitempty"`

	// (String) The resource name.
	// Name of the listener.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (Block List, Max: 1) Stream configuration (see below for nested schema)
	// Stream configuration
	Stream []StreamObservation `json:"stream,omitempty" tf:"stream,omitempty"`

	// (Block List, Max: 1) TLS configuration (see below for nested schema)
	// TLS configuration
	TLS []ListenerTLSObservation `json:"tls,omitempty" tf:"tls,omitempty"`
}

type ListenerParameters struct {

	// (Block List) Network endpoint (addresses and ports) of the listener. (see below for nested schema)
	// Network endpoint (addresses and ports) of the listener.
	// +kubebuilder:validation:Optional
	Endpoint []EndpointParameters `json:"endpoint,omitempty" tf:"endpoint,omitempty"`

	// (Block List, Max: 1) HTTP handler that sets plain text HTTP router. (see below for nested schema)
	// HTTP handler that sets plain text HTTP router.
	// +kubebuilder:validation:Optional
	HTTP []HTTPParameters `json:"http,omitempty" tf:"http,omitempty"`

	// (String) The resource name.
	// Name of the listener.
	// +kubebuilder:validation:Optional
	Name *string `json:"name" tf:"name,omitempty"`

	// (Block List, Max: 1) Stream configuration (see below for nested schema)
	// Stream configuration
	// +kubebuilder:validation:Optional
	Stream []StreamParameters `json:"stream,omitempty" tf:"stream,omitempty"`

	// (Block List, Max: 1) TLS configuration (see below for nested schema)
	// TLS configuration
	// +kubebuilder:validation:Optional
	TLS []ListenerTLSParameters `json:"tls,omitempty" tf:"tls,omitempty"`
}

type ListenerTLSInitParameters struct {

	// (Block List, Min: 1, Max: 1) TLS handler resource. (see below for nested schema)
	// TLS handler resource.
	DefaultHandler []DefaultHandlerInitParameters `json:"defaultHandler,omitempty" tf:"default_handler,omitempty"`

	// (Block List) Settings for handling requests with Server Name Indication (SNI) (see below for nested schema)
	// Settings for handling requests with Server Name Indication (SNI)
	SniHandler []SniHandlerInitParameters `json:"sniHandler,omitempty" tf:"sni_handler,omitempty"`
}

type ListenerTLSObservation struct {

	// (Block List, Min: 1, Max: 1) TLS handler resource. (see below for nested schema)
	// TLS handler resource.
	DefaultHandler []DefaultHandlerObservation `json:"defaultHandler,omitempty" tf:"default_handler,omitempty"`

	// (Block List) Settings for handling requests with Server Name Indication (SNI) (see below for nested schema)
	// Settings for handling requests with Server Name Indication (SNI)
	SniHandler []SniHandlerObservation `json:"sniHandler,omitempty" tf:"sni_handler,omitempty"`
}

type ListenerTLSParameters struct {

	// (Block List, Min: 1, Max: 1) TLS handler resource. (see below for nested schema)
	// TLS handler resource.
	// +kubebuilder:validation:Optional
	DefaultHandler []DefaultHandlerParameters `json:"defaultHandler" tf:"default_handler,omitempty"`

	// (Block List) Settings for handling requests with Server Name Indication (SNI) (see below for nested schema)
	// Settings for handling requests with Server Name Indication (SNI)
	// +kubebuilder:validation:Optional
	SniHandler []SniHandlerParameters `json:"sniHandler,omitempty" tf:"sni_handler,omitempty"`
}

type LoadBalancerInitParameters struct {

	// (Block List, Min: 1, Max: 1) Allocation zones for the Load Balancer instance. (see below for nested schema)
	// Allocation zones for the Load Balancer instance.
	AllocationPolicy []AllocationPolicyInitParameters `json:"allocationPolicy,omitempty" tf:"allocation_policy,omitempty"`

	// (Boolean) Specifies whether application load balancer is available to zonal shift
	// Specifies whether application load balancer is available to zonal shift
	AllowZonalShift *bool `json:"allowZonalShift,omitempty" tf:"allow_zonal_shift,omitempty"`

	// (Block List, Max: 1) Scaling settings of the application load balancer. (see below for nested schema)
	// Scaling settings of the application load balancer.
	AutoScalePolicy []AutoScalePolicyInitParameters `json:"autoScalePolicy,omitempty" tf:"auto_scale_policy,omitempty"`

	// (String) The resource description.
	// The resource description.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// id is used.
	// The folder identifier that resource belongs to. If it is not provided, the default provider `folder-id` is used.
	// +crossplane:generate:reference:type=github.com/yandex-cloud/crossplane-provider-yc/apis/cluster/resourcemanager/v1alpha1.Folder
	FolderID *string `json:"folderId,omitempty" tf:"folder_id,omitempty"`

	// Reference to a Folder in resourcemanager to populate folderId.
	// +kubebuilder:validation:Optional
	FolderIDRef *v1.Reference `json:"folderIdRef,omitempty" tf:"-"`

	// Selector for a Folder in resourcemanager to populate folderId.
	// +kubebuilder:validation:Optional
	FolderIDSelector *v1.Selector `json:"folderIdSelector,omitempty" tf:"-"`

	// (Map of String) A set of key/value label pairs which assigned to resource.
	// A set of key/value label pairs which assigned to resource.
	// +mapType=granular
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// (Block List) List of listeners for the Load Balancer. (see below for nested schema)
	// List of listeners for the Load Balancer.
	Listener []ListenerInitParameters `json:"listener,omitempty" tf:"listener,omitempty"`

	// (Block List, Max: 1) Cloud Logging settings. (see below for nested schema)
	// Cloud Logging settings.
	LogOptions []LogOptionsInitParameters `json:"logOptions,omitempty" tf:"log_options,omitempty"`

	// (String) The resource name.
	// The resource name.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (String) The VPC Network ID of subnets which resource attached to.
	// The `VPC Network ID` of subnets which resource attached to.
	// +crossplane:generate:reference:type=github.com/yandex-cloud/crossplane-provider-yc/apis/cluster/vpc/v1alpha1.Network
	NetworkID *string `json:"networkId,omitempty" tf:"network_id,omitempty"`

	// Reference to a Network in vpc to populate networkId.
	// +kubebuilder:validation:Optional
	NetworkIDRef *v1.Reference `json:"networkIdRef,omitempty" tf:"-"`

	// Selector for a Network in vpc to populate networkId.
	// +kubebuilder:validation:Optional
	NetworkIDSelector *v1.Selector `json:"networkIdSelector,omitempty" tf:"-"`

	// (String) The region ID where Load Balancer is located at.
	// The region ID where Load Balancer is located at.
	RegionID *string `json:"regionId,omitempty" tf:"region_id,omitempty"`

	// (Set of String) The list of security groups applied to resource or their components.
	// The list of security groups applied to resource or their components.
	// +crossplane:generate:reference:type=github.com/yandex-cloud/crossplane-provider-yc/apis/cluster/vpc/v1alpha1.SecurityGroup
	// +listType=set
	SecurityGroupIds []*string `json:"securityGroupIds,omitempty" tf:"security_group_ids,omitempty"`

	// References to SecurityGroup in vpc to populate securityGroupIds.
	// +kubebuilder:validation:Optional
	SecurityGroupIdsRefs []v1.Reference `json:"securityGroupIdsRefs,omitempty" tf:"-"`

	// Selector for a list of SecurityGroup in vpc to populate securityGroupIds.
	// +kubebuilder:validation:Optional
	SecurityGroupIdsSelector *v1.Selector `json:"securityGroupIdsSelector,omitempty" tf:"-"`
}

type LoadBalancerObservation struct {

	// (Block List, Min: 1, Max: 1) Allocation zones for the Load Balancer instance. (see below for nested schema)
	// Allocation zones for the Load Balancer instance.
	AllocationPolicy []AllocationPolicyObservation `json:"allocationPolicy,omitempty" tf:"allocation_policy,omitempty"`

	// (Boolean) Specifies whether application load balancer is available to zonal shift
	// Specifies whether application load balancer is available to zonal shift
	AllowZonalShift *bool `json:"allowZonalShift,omitempty" tf:"allow_zonal_shift,omitempty"`

	// (Block List, Max: 1) Scaling settings of the application load balancer. (see below for nested schema)
	// Scaling settings of the application load balancer.
	AutoScalePolicy []AutoScalePolicyObservation `json:"autoScalePolicy,omitempty" tf:"auto_scale_policy,omitempty"`

	// (String) The creation timestamp of the resource.
	// The creation timestamp of the resource.
	CreatedAt *string `json:"createdAt,omitempty" tf:"created_at,omitempty"`

	// (String) The resource description.
	// The resource description.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// id is used.
	// The folder identifier that resource belongs to. If it is not provided, the default provider `folder-id` is used.
	FolderID *string `json:"folderId,omitempty" tf:"folder_id,omitempty"`

	// (String) The ID of this resource.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// (Map of String) A set of key/value label pairs which assigned to resource.
	// A set of key/value label pairs which assigned to resource.
	// +mapType=granular
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// (Block List) List of listeners for the Load Balancer. (see below for nested schema)
	// List of listeners for the Load Balancer.
	Listener []ListenerObservation `json:"listener,omitempty" tf:"listener,omitempty"`

	// (String) Cloud Logging group ID to send logs to. Leave empty to use the balancer folder default log group.
	// Cloud Logging group ID to send logs to. Leave empty to use the balancer folder default log group.
	LogGroupID *string `json:"logGroupId,omitempty" tf:"log_group_id,omitempty"`

	// (Block List, Max: 1) Cloud Logging settings. (see below for nested schema)
	// Cloud Logging settings.
	LogOptions []LogOptionsObservation `json:"logOptions,omitempty" tf:"log_options,omitempty"`

	// (String) The resource name.
	// The resource name.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (String) The VPC Network ID of subnets which resource attached to.
	// The `VPC Network ID` of subnets which resource attached to.
	NetworkID *string `json:"networkId,omitempty" tf:"network_id,omitempty"`

	// (String) The region ID where Load Balancer is located at.
	// The region ID where Load Balancer is located at.
	RegionID *string `json:"regionId,omitempty" tf:"region_id,omitempty"`

	// (Set of String) The list of security groups applied to resource or their components.
	// The list of security groups applied to resource or their components.
	// +listType=set
	SecurityGroupIds []*string `json:"securityGroupIds,omitempty" tf:"security_group_ids,omitempty"`

	// (String) Status of the Load Balancer.
	// Status of the Load Balancer.
	Status *string `json:"status,omitempty" tf:"status,omitempty"`
}

type LoadBalancerParameters struct {

	// (Block List, Min: 1, Max: 1) Allocation zones for the Load Balancer instance. (see below for nested schema)
	// Allocation zones for the Load Balancer instance.
	// +kubebuilder:validation:Optional
	AllocationPolicy []AllocationPolicyParameters `json:"allocationPolicy,omitempty" tf:"allocation_policy,omitempty"`

	// (Boolean) Specifies whether application load balancer is available to zonal shift
	// Specifies whether application load balancer is available to zonal shift
	// +kubebuilder:validation:Optional
	AllowZonalShift *bool `json:"allowZonalShift,omitempty" tf:"allow_zonal_shift,omitempty"`

	// (Block List, Max: 1) Scaling settings of the application load balancer. (see below for nested schema)
	// Scaling settings of the application load balancer.
	// +kubebuilder:validation:Optional
	AutoScalePolicy []AutoScalePolicyParameters `json:"autoScalePolicy,omitempty" tf:"auto_scale_policy,omitempty"`

	// (String) The resource description.
	// The resource description.
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// id is used.
	// The folder identifier that resource belongs to. If it is not provided, the default provider `folder-id` is used.
	// +crossplane:generate:reference:type=github.com/yandex-cloud/crossplane-provider-yc/apis/cluster/resourcemanager/v1alpha1.Folder
	// +kubebuilder:validation:Optional
	FolderID *string `json:"folderId,omitempty" tf:"folder_id,omitempty"`

	// Reference to a Folder in resourcemanager to populate folderId.
	// +kubebuilder:validation:Optional
	FolderIDRef *v1.Reference `json:"folderIdRef,omitempty" tf:"-"`

	// Selector for a Folder in resourcemanager to populate folderId.
	// +kubebuilder:validation:Optional
	FolderIDSelector *v1.Selector `json:"folderIdSelector,omitempty" tf:"-"`

	// (Map of String) A set of key/value label pairs which assigned to resource.
	// A set of key/value label pairs which assigned to resource.
	// +kubebuilder:validation:Optional
	// +mapType=granular
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// (Block List) List of listeners for the Load Balancer. (see below for nested schema)
	// List of listeners for the Load Balancer.
	// +kubebuilder:validation:Optional
	Listener []ListenerParameters `json:"listener,omitempty" tf:"listener,omitempty"`

	// (Block List, Max: 1) Cloud Logging settings. (see below for nested schema)
	// Cloud Logging settings.
	// +kubebuilder:validation:Optional
	LogOptions []LogOptionsParameters `json:"logOptions,omitempty" tf:"log_options,omitempty"`

	// (String) The resource name.
	// The resource name.
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (String) The VPC Network ID of subnets which resource attached to.
	// The `VPC Network ID` of subnets which resource attached to.
	// +crossplane:generate:reference:type=github.com/yandex-cloud/crossplane-provider-yc/apis/cluster/vpc/v1alpha1.Network
	// +kubebuilder:validation:Optional
	NetworkID *string `json:"networkId,omitempty" tf:"network_id,omitempty"`

	// Reference to a Network in vpc to populate networkId.
	// +kubebuilder:validation:Optional
	NetworkIDRef *v1.Reference `json:"networkIdRef,omitempty" tf:"-"`

	// Selector for a Network in vpc to populate networkId.
	// +kubebuilder:validation:Optional
	NetworkIDSelector *v1.Selector `json:"networkIdSelector,omitempty" tf:"-"`

	// (String) The region ID where Load Balancer is located at.
	// The region ID where Load Balancer is located at.
	// +kubebuilder:validation:Optional
	RegionID *string `json:"regionId,omitempty" tf:"region_id,omitempty"`

	// (Set of String) The list of security groups applied to resource or their components.
	// The list of security groups applied to resource or their components.
	// +crossplane:generate:reference:type=github.com/yandex-cloud/crossplane-provider-yc/apis/cluster/vpc/v1alpha1.SecurityGroup
	// +kubebuilder:validation:Optional
	// +listType=set
	SecurityGroupIds []*string `json:"securityGroupIds,omitempty" tf:"security_group_ids,omitempty"`

	// References to SecurityGroup in vpc to populate securityGroupIds.
	// +kubebuilder:validation:Optional
	SecurityGroupIdsRefs []v1.Reference `json:"securityGroupIdsRefs,omitempty" tf:"-"`

	// Selector for a list of SecurityGroup in vpc to populate securityGroupIds.
	// +kubebuilder:validation:Optional
	SecurityGroupIdsSelector *v1.Selector `json:"securityGroupIdsSelector,omitempty" tf:"-"`
}

type LocationInitParameters struct {

	// (Boolean) If set, will disable all L7 instances in the zone for request handling.
	// If set, will disable all L7 instances in the zone for request handling.
	DisableTraffic *bool `json:"disableTraffic,omitempty" tf:"disable_traffic,omitempty"`

	// (String) ID of the subnet that location is located at.
	// ID of the subnet that location is located at.
	// +crossplane:generate:reference:type=github.com/yandex-cloud/crossplane-provider-yc/apis/cluster/vpc/v1alpha1.Subnet
	SubnetID *string `json:"subnetId,omitempty" tf:"subnet_id,omitempty"`

	// Reference to a Subnet in vpc to populate subnetId.
	// +kubebuilder:validation:Optional
	SubnetIDRef *v1.Reference `json:"subnetIdRef,omitempty" tf:"-"`

	// Selector for a Subnet in vpc to populate subnetId.
	// +kubebuilder:validation:Optional
	SubnetIDSelector *v1.Selector `json:"subnetIdSelector,omitempty" tf:"-"`

	// (String) The availability zone where resource is located. If it is not provided, the default provider zone will be used.
	// The [availability zone](https://yandex.cloud/docs/overview/concepts/geo-scope) where resource is located. If it is not provided, the default provider zone will be used.
	ZoneID *string `json:"zoneId,omitempty" tf:"zone_id,omitempty"`
}

type LocationObservation struct {

	// (Boolean) If set, will disable all L7 instances in the zone for request handling.
	// If set, will disable all L7 instances in the zone for request handling.
	DisableTraffic *bool `json:"disableTraffic,omitempty" tf:"disable_traffic,omitempty"`

	// (String) ID of the subnet that location is located at.
	// ID of the subnet that location is located at.
	SubnetID *string `json:"subnetId,omitempty" tf:"subnet_id,omitempty"`

	// (String) The availability zone where resource is located. If it is not provided, the default provider zone will be used.
	// The [availability zone](https://yandex.cloud/docs/overview/concepts/geo-scope) where resource is located. If it is not provided, the default provider zone will be used.
	ZoneID *string `json:"zoneId,omitempty" tf:"zone_id,omitempty"`
}

type LocationParameters struct {

	// (Boolean) If set, will disable all L7 instances in the zone for request handling.
	// If set, will disable all L7 instances in the zone for request handling.
	// +kubebuilder:validation:Optional
	DisableTraffic *bool `json:"disableTraffic,omitempty" tf:"disable_traffic,omitempty"`

	// (String) ID of the subnet that location is located at.
	// ID of the subnet that location is located at.
	// +crossplane:generate:reference:type=github.com/yandex-cloud/crossplane-provider-yc/apis/cluster/vpc/v1alpha1.Subnet
	// +kubebuilder:validation:Optional
	SubnetID *string `json:"subnetId,omitempty" tf:"subnet_id,omitempty"`

	// Reference to a Subnet in vpc to populate subnetId.
	// +kubebuilder:validation:Optional
	SubnetIDRef *v1.Reference `json:"subnetIdRef,omitempty" tf:"-"`

	// Selector for a Subnet in vpc to populate subnetId.
	// +kubebuilder:validation:Optional
	SubnetIDSelector *v1.Selector `json:"subnetIdSelector,omitempty" tf:"-"`

	// (String) The availability zone where resource is located. If it is not provided, the default provider zone will be used.
	// The [availability zone](https://yandex.cloud/docs/overview/concepts/geo-scope) where resource is located. If it is not provided, the default provider zone will be used.
	// +kubebuilder:validation:Optional
	ZoneID *string `json:"zoneId" tf:"zone_id,omitempty"`
}

type LogOptionsInitParameters struct {

	// (Boolean) Set to true to disable Cloud Logging for the balancer.
	// Set to `true` to disable Cloud Logging for the balancer.
	Disable *bool `json:"disable,omitempty" tf:"disable,omitempty"`

	// (Block List) List of rules to discard a fraction of logs. (see below for nested schema)
	// List of rules to discard a fraction of logs.
	DiscardRule []DiscardRuleInitParameters `json:"discardRule,omitempty" tf:"discard_rule,omitempty"`

	// (String) Cloud Logging group ID to send logs to. Leave empty to use the balancer folder default log group.
	// Cloud Logging group ID to send logs to. Leave empty to use the balancer folder default log group.
	LogGroupID *string `json:"logGroupId,omitempty" tf:"log_group_id,omitempty"`
}

type LogOptionsObservation struct {

	// (Boolean) Set to true to disable Cloud Logging for the balancer.
	// Set to `true` to disable Cloud Logging for the balancer.
	Disable *bool `json:"disable,omitempty" tf:"disable,omitempty"`

	// (Block List) List of rules to discard a fraction of logs. (see below for nested schema)
	// List of rules to discard a fraction of logs.
	DiscardRule []DiscardRuleObservation `json:"discardRule,omitempty" tf:"discard_rule,omitempty"`

	// (String) Cloud Logging group ID to send logs to. Leave empty to use the balancer folder default log group.
	// Cloud Logging group ID to send logs to. Leave empty to use the balancer folder default log group.
	LogGroupID *string `json:"logGroupId,omitempty" tf:"log_group_id,omitempty"`
}

type LogOptionsParameters struct {

	// (Boolean) Set to true to disable Cloud Logging for the balancer.
	// Set to `true` to disable Cloud Logging for the balancer.
	// +kubebuilder:validation:Optional
	Disable *bool `json:"disable,omitempty" tf:"disable,omitempty"`

	// (Block List) List of rules to discard a fraction of logs. (see below for nested schema)
	// List of rules to discard a fraction of logs.
	// +kubebuilder:validation:Optional
	DiscardRule []DiscardRuleParameters `json:"discardRule,omitempty" tf:"discard_rule,omitempty"`

	// (String) Cloud Logging group ID to send logs to. Leave empty to use the balancer folder default log group.
	// Cloud Logging group ID to send logs to. Leave empty to use the balancer folder default log group.
	// +kubebuilder:validation:Optional
	LogGroupID *string `json:"logGroupId,omitempty" tf:"log_group_id,omitempty"`
}

type RedirectsInitParameters struct {

	// (Boolean) If set redirects all unencrypted HTTP requests to the same URI with scheme changed to https.
	// If set redirects all unencrypted HTTP requests to the same URI with scheme changed to `https`.
	HTTPToHTTPS *bool `json:"httpToHttps,omitempty" tf:"http_to_https,omitempty"`
}

type RedirectsObservation struct {

	// (Boolean) If set redirects all unencrypted HTTP requests to the same URI with scheme changed to https.
	// If set redirects all unencrypted HTTP requests to the same URI with scheme changed to `https`.
	HTTPToHTTPS *bool `json:"httpToHttps,omitempty" tf:"http_to_https,omitempty"`
}

type RedirectsParameters struct {

	// (Boolean) If set redirects all unencrypted HTTP requests to the same URI with scheme changed to https.
	// If set redirects all unencrypted HTTP requests to the same URI with scheme changed to `https`.
	// +kubebuilder:validation:Optional
	HTTPToHTTPS *bool `json:"httpToHttps,omitempty" tf:"http_to_https,omitempty"`
}

type SniHandlerHandlerInitParameters struct {

	// (Set of String) Certificate IDs in the Certificate Manager. Multiple TLS certificates can be associated with the same context to allow both RSA and ECDSA certificates. Only the first certificate of each type will be used.
	// Certificate IDs in the Certificate Manager. Multiple TLS certificates can be associated with the same context to allow both RSA and ECDSA certificates. Only the first certificate of each type will be used.
	// +listType=set
	CertificateIds []*string `json:"certificateIds,omitempty" tf:"certificate_ids,omitempty"`

	// (Block List, Max: 1) HTTP handler. (see below for nested schema)
	// HTTP handler.
	HTTPHandler []HandlerHTTPHandlerInitParameters `json:"httpHandler,omitempty" tf:"http_handler,omitempty"`

	// (Block List, Max: 1) Stream handler resource. (see below for nested schema)
	// Stream handler resource.
	StreamHandler []HandlerStreamHandlerInitParameters `json:"streamHandler,omitempty" tf:"stream_handler,omitempty"`
}

type SniHandlerHandlerObservation struct {

	// (Set of String) Certificate IDs in the Certificate Manager. Multiple TLS certificates can be associated with the same context to allow both RSA and ECDSA certificates. Only the first certificate of each type will be used.
	// Certificate IDs in the Certificate Manager. Multiple TLS certificates can be associated with the same context to allow both RSA and ECDSA certificates. Only the first certificate of each type will be used.
	// +listType=set
	CertificateIds []*string `json:"certificateIds,omitempty" tf:"certificate_ids,omitempty"`

	// (Block List, Max: 1) HTTP handler. (see below for nested schema)
	// HTTP handler.
	HTTPHandler []HandlerHTTPHandlerObservation `json:"httpHandler,omitempty" tf:"http_handler,omitempty"`

	// (Block List, Max: 1) Stream handler resource. (see below for nested schema)
	// Stream handler resource.
	StreamHandler []HandlerStreamHandlerObservation `json:"streamHandler,omitempty" tf:"stream_handler,omitempty"`
}

type SniHandlerHandlerParameters struct {

	// (Set of String) Certificate IDs in the Certificate Manager. Multiple TLS certificates can be associated with the same context to allow both RSA and ECDSA certificates. Only the first certificate of each type will be used.
	// Certificate IDs in the Certificate Manager. Multiple TLS certificates can be associated with the same context to allow both RSA and ECDSA certificates. Only the first certificate of each type will be used.
	// +kubebuilder:validation:Optional
	// +listType=set
	CertificateIds []*string `json:"certificateIds" tf:"certificate_ids,omitempty"`

	// (Block List, Max: 1) HTTP handler. (see below for nested schema)
	// HTTP handler.
	// +kubebuilder:validation:Optional
	HTTPHandler []HandlerHTTPHandlerParameters `json:"httpHandler,omitempty" tf:"http_handler,omitempty"`

	// (Block List, Max: 1) Stream handler resource. (see below for nested schema)
	// Stream handler resource.
	// +kubebuilder:validation:Optional
	StreamHandler []HandlerStreamHandlerParameters `json:"streamHandler,omitempty" tf:"stream_handler,omitempty"`
}

type SniHandlerInitParameters struct {

	// (Block List, Max: 1) HTTP handler. (see below for nested schema)
	// TLS handler resource.
	Handler []SniHandlerHandlerInitParameters `json:"handler,omitempty" tf:"handler,omitempty"`

	// (String) The resource name.
	// Name of the SNI handler
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (Set of String) Server names that are matched by the SNI handler
	// Server names that are matched by the SNI handler
	// +listType=set
	ServerNames []*string `json:"serverNames,omitempty" tf:"server_names,omitempty"`
}

type SniHandlerObservation struct {

	// (Block List, Max: 1) HTTP handler. (see below for nested schema)
	// TLS handler resource.
	Handler []SniHandlerHandlerObservation `json:"handler,omitempty" tf:"handler,omitempty"`

	// (String) The resource name.
	// Name of the SNI handler
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (Set of String) Server names that are matched by the SNI handler
	// Server names that are matched by the SNI handler
	// +listType=set
	ServerNames []*string `json:"serverNames,omitempty" tf:"server_names,omitempty"`
}

type SniHandlerParameters struct {

	// (Block List, Max: 1) HTTP handler. (see below for nested schema)
	// TLS handler resource.
	// +kubebuilder:validation:Optional
	Handler []SniHandlerHandlerParameters `json:"handler" tf:"handler,omitempty"`

	// (String) The resource name.
	// Name of the SNI handler
	// +kubebuilder:validation:Optional
	Name *string `json:"name" tf:"name,omitempty"`

	// (Set of String) Server names that are matched by the SNI handler
	// Server names that are matched by the SNI handler
	// +kubebuilder:validation:Optional
	// +listType=set
	ServerNames []*string `json:"serverNames" tf:"server_names,omitempty"`
}

type StreamHandlerInitParameters struct {

	// (String) Backend Group ID.
	// Backend Group ID.
	BackendGroupID *string `json:"backendGroupId,omitempty" tf:"backend_group_id,omitempty"`

	// (String) The idle timeout is the interval after which the connection will be forcibly closed if no data has been transmitted or received on either the upstream or downstream connection. If not configured, the default idle timeout is 1 hour. Setting it to 0 disables the timeout.
	// The idle timeout is the interval after which the connection will be forcibly closed if no data has been transmitted or received on either the upstream or downstream connection. If not configured, the default idle timeout is 1 hour. Setting it to 0 disables the timeout.
	IdleTimeout *string `json:"idleTimeout,omitempty" tf:"idle_timeout,omitempty"`
}

type StreamHandlerObservation struct {

	// (String) Backend Group ID.
	// Backend Group ID.
	BackendGroupID *string `json:"backendGroupId,omitempty" tf:"backend_group_id,omitempty"`

	// (String) The idle timeout is the interval after which the connection will be forcibly closed if no data has been transmitted or received on either the upstream or downstream connection. If not configured, the default idle timeout is 1 hour. Setting it to 0 disables the timeout.
	// The idle timeout is the interval after which the connection will be forcibly closed if no data has been transmitted or received on either the upstream or downstream connection. If not configured, the default idle timeout is 1 hour. Setting it to 0 disables the timeout.
	IdleTimeout *string `json:"idleTimeout,omitempty" tf:"idle_timeout,omitempty"`
}

type StreamHandlerParameters struct {

	// (String) Backend Group ID.
	// Backend Group ID.
	// +kubebuilder:validation:Optional
	BackendGroupID *string `json:"backendGroupId,omitempty" tf:"backend_group_id,omitempty"`

	// (String) The idle timeout is the interval after which the connection will be forcibly closed if no data has been transmitted or received on either the upstream or downstream connection. If not configured, the default idle timeout is 1 hour. Setting it to 0 disables the timeout.
	// The idle timeout is the interval after which the connection will be forcibly closed if no data has been transmitted or received on either the upstream or downstream connection. If not configured, the default idle timeout is 1 hour. Setting it to 0 disables the timeout.
	// +kubebuilder:validation:Optional
	IdleTimeout *string `json:"idleTimeout,omitempty" tf:"idle_timeout,omitempty"`
}

type StreamInitParameters struct {

	// (Block List, Max: 1) HTTP handler. (see below for nested schema)
	// Stream handler resource.
	Handler []StreamHandlerInitParameters `json:"handler,omitempty" tf:"handler,omitempty"`
}

type StreamObservation struct {

	// (Block List, Max: 1) HTTP handler. (see below for nested schema)
	// Stream handler resource.
	Handler []StreamHandlerObservation `json:"handler,omitempty" tf:"handler,omitempty"`
}

type StreamParameters struct {

	// (Block List, Max: 1) HTTP handler. (see below for nested schema)
	// Stream handler resource.
	// +kubebuilder:validation:Optional
	Handler []StreamHandlerParameters `json:"handler,omitempty" tf:"handler,omitempty"`
}

// LoadBalancerSpec defines the desired state of LoadBalancer
type LoadBalancerSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     LoadBalancerParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider LoadBalancerInitParameters `json:"initProvider,omitempty"`
}

// LoadBalancerStatus defines the observed state of LoadBalancer.
type LoadBalancerStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        LoadBalancerObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// LoadBalancer is the Schema for the LoadBalancers API. A Load Balancer is used for receiving incoming traffic and transmitting it to the backend endpoints specified in the ALB Target Groups.
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,yandex-cloud}
type LoadBalancer struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.allocationPolicy) || (has(self.initProvider) && has(self.initProvider.allocationPolicy))",message="spec.forProvider.allocationPolicy is a required parameter"
	Spec   LoadBalancerSpec   `json:"spec"`
	Status LoadBalancerStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// LoadBalancerList contains a list of LoadBalancers
type LoadBalancerList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []LoadBalancer `json:"items"`
}

// Repository type metadata.
var (
	LoadBalancer_Kind             = "LoadBalancer"
	LoadBalancer_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: LoadBalancer_Kind}.String()
	LoadBalancer_KindAPIVersion   = LoadBalancer_Kind + "." + CRDGroupVersion.String()
	LoadBalancer_GroupVersionKind = CRDGroupVersion.WithKind(LoadBalancer_Kind)
)

func init() {
	SchemeBuilder.Register(&LoadBalancer{}, &LoadBalancerList{})
}
