/*
Copyright 2022 YANDEX LLC
This is modified version of the software, made by the Crossplane Authors
and available at: https://github.com/crossplane-contrib/provider-jet-template

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type AllocationPolicyInitParameters struct {

	// Repeated field, that specify subnets (zones), that will be used by node group compute instances. The structure is documented below.
	Location []AllocationPolicyLocationInitParameters `json:"location,omitempty" tf:"location,omitempty"`
}

type AllocationPolicyLocationInitParameters struct {

	// ID of the subnet, that will be used by one compute instance in node group.
	// +crossplane:generate:reference:type=github.com/yandex-cloud/crossplane-provider-yc/apis/vpc/v1alpha1.Subnet
	SubnetID *string `json:"subnetId,omitempty" tf:"subnet_id,omitempty"`

	// Reference to a Subnet in vpc to populate subnetId.
	// +kubebuilder:validation:Optional
	SubnetIDRef *v1.Reference `json:"subnetIdRef,omitempty" tf:"-"`

	// Selector for a Subnet in vpc to populate subnetId.
	// +kubebuilder:validation:Optional
	SubnetIDSelector *v1.Selector `json:"subnetIdSelector,omitempty" tf:"-"`

	// ID of the availability zone where for one compute instance in node group.
	Zone *string `json:"zone,omitempty" tf:"zone,omitempty"`
}

type AllocationPolicyLocationObservation struct {

	// ID of the subnet, that will be used by one compute instance in node group.
	SubnetID *string `json:"subnetId,omitempty" tf:"subnet_id,omitempty"`

	// ID of the availability zone where for one compute instance in node group.
	Zone *string `json:"zone,omitempty" tf:"zone,omitempty"`
}

type AllocationPolicyLocationParameters struct {

	// ID of the subnet, that will be used by one compute instance in node group.
	// +crossplane:generate:reference:type=github.com/yandex-cloud/crossplane-provider-yc/apis/vpc/v1alpha1.Subnet
	// +kubebuilder:validation:Optional
	SubnetID *string `json:"subnetId,omitempty" tf:"subnet_id,omitempty"`

	// Reference to a Subnet in vpc to populate subnetId.
	// +kubebuilder:validation:Optional
	SubnetIDRef *v1.Reference `json:"subnetIdRef,omitempty" tf:"-"`

	// Selector for a Subnet in vpc to populate subnetId.
	// +kubebuilder:validation:Optional
	SubnetIDSelector *v1.Selector `json:"subnetIdSelector,omitempty" tf:"-"`

	// ID of the availability zone where for one compute instance in node group.
	// +kubebuilder:validation:Optional
	Zone *string `json:"zone,omitempty" tf:"zone,omitempty"`
}

type AllocationPolicyObservation struct {

	// Repeated field, that specify subnets (zones), that will be used by node group compute instances. The structure is documented below.
	Location []AllocationPolicyLocationObservation `json:"location,omitempty" tf:"location,omitempty"`
}

type AllocationPolicyParameters struct {

	// Repeated field, that specify subnets (zones), that will be used by node group compute instances. The structure is documented below.
	// +kubebuilder:validation:Optional
	Location []AllocationPolicyLocationParameters `json:"location,omitempty" tf:"location,omitempty"`
}

type AutoScaleInitParameters struct {

	// Initial number of instances in the node group.
	Initial *float64 `json:"initial,omitempty" tf:"initial,omitempty"`

	// Maximum number of instances in the node group.
	Max *float64 `json:"max,omitempty" tf:"max,omitempty"`

	// Minimum number of instances in the node group.
	Min *float64 `json:"min,omitempty" tf:"min,omitempty"`
}

type AutoScaleObservation struct {

	// Initial number of instances in the node group.
	Initial *float64 `json:"initial,omitempty" tf:"initial,omitempty"`

	// Maximum number of instances in the node group.
	Max *float64 `json:"max,omitempty" tf:"max,omitempty"`

	// Minimum number of instances in the node group.
	Min *float64 `json:"min,omitempty" tf:"min,omitempty"`
}

type AutoScaleParameters struct {

	// Initial number of instances in the node group.
	// +kubebuilder:validation:Optional
	Initial *float64 `json:"initial" tf:"initial,omitempty"`

	// Maximum number of instances in the node group.
	// +kubebuilder:validation:Optional
	Max *float64 `json:"max" tf:"max,omitempty"`

	// Minimum number of instances in the node group.
	// +kubebuilder:validation:Optional
	Min *float64 `json:"min" tf:"min,omitempty"`
}

type BootDiskInitParameters struct {

	// The number of instances in the node group.
	Size *float64 `json:"size,omitempty" tf:"size,omitempty"`

	// Type of container runtime. Values: docker, containerd.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type BootDiskObservation struct {

	// The number of instances in the node group.
	Size *float64 `json:"size,omitempty" tf:"size,omitempty"`

	// Type of container runtime. Values: docker, containerd.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type BootDiskParameters struct {

	// The number of instances in the node group.
	// +kubebuilder:validation:Optional
	Size *float64 `json:"size,omitempty" tf:"size,omitempty"`

	// Type of container runtime. Values: docker, containerd.
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type ContainerNetworkInitParameters struct {

	// MTU for pods.
	PodMtu *float64 `json:"podMtu,omitempty" tf:"pod_mtu,omitempty"`
}

type ContainerNetworkObservation struct {

	// MTU for pods.
	PodMtu *float64 `json:"podMtu,omitempty" tf:"pod_mtu,omitempty"`
}

type ContainerNetworkParameters struct {

	// MTU for pods.
	// +kubebuilder:validation:Optional
	PodMtu *float64 `json:"podMtu,omitempty" tf:"pod_mtu,omitempty"`
}

type ContainerRuntimeInitParameters struct {

	// Type of container runtime. Values: docker, containerd.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type ContainerRuntimeObservation struct {

	// Type of container runtime. Values: docker, containerd.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type ContainerRuntimeParameters struct {

	// Type of container runtime. Values: docker, containerd.
	// +kubebuilder:validation:Optional
	Type *string `json:"type" tf:"type,omitempty"`
}

type DeployPolicyInitParameters struct {

	// The maximum number of instances that can be temporarily allocated above the group's target size during the update.
	MaxExpansion *float64 `json:"maxExpansion,omitempty" tf:"max_expansion,omitempty"`

	// The maximum number of running instances that can be taken offline during update.
	MaxUnavailable *float64 `json:"maxUnavailable,omitempty" tf:"max_unavailable,omitempty"`
}

type DeployPolicyObservation struct {

	// The maximum number of instances that can be temporarily allocated above the group's target size during the update.
	MaxExpansion *float64 `json:"maxExpansion,omitempty" tf:"max_expansion,omitempty"`

	// The maximum number of running instances that can be taken offline during update.
	MaxUnavailable *float64 `json:"maxUnavailable,omitempty" tf:"max_unavailable,omitempty"`
}

type DeployPolicyParameters struct {

	// The maximum number of instances that can be temporarily allocated above the group's target size during the update.
	// +kubebuilder:validation:Optional
	MaxExpansion *float64 `json:"maxExpansion" tf:"max_expansion,omitempty"`

	// The maximum number of running instances that can be taken offline during update.
	// +kubebuilder:validation:Optional
	MaxUnavailable *float64 `json:"maxUnavailable" tf:"max_unavailable,omitempty"`
}

type FixedScaleInitParameters struct {

	// The number of instances in the node group.
	Size *float64 `json:"size,omitempty" tf:"size,omitempty"`
}

type FixedScaleObservation struct {

	// The number of instances in the node group.
	Size *float64 `json:"size,omitempty" tf:"size,omitempty"`
}

type FixedScaleParameters struct {

	// The number of instances in the node group.
	// +kubebuilder:validation:Optional
	Size *float64 `json:"size,omitempty" tf:"size,omitempty"`
}

type GpuSettingsInitParameters struct {

	// GPU cluster id.
	GpuClusterID *string `json:"gpuClusterId,omitempty" tf:"gpu_cluster_id,omitempty"`

	// GPU environment. Values: runc, runc_drivers_cuda.
	GpuEnvironment *string `json:"gpuEnvironment,omitempty" tf:"gpu_environment,omitempty"`
}

type GpuSettingsObservation struct {

	// GPU cluster id.
	GpuClusterID *string `json:"gpuClusterId,omitempty" tf:"gpu_cluster_id,omitempty"`

	// GPU environment. Values: runc, runc_drivers_cuda.
	GpuEnvironment *string `json:"gpuEnvironment,omitempty" tf:"gpu_environment,omitempty"`
}

type GpuSettingsParameters struct {

	// GPU cluster id.
	// +kubebuilder:validation:Optional
	GpuClusterID *string `json:"gpuClusterId,omitempty" tf:"gpu_cluster_id,omitempty"`

	// GPU environment. Values: runc, runc_drivers_cuda.
	// +kubebuilder:validation:Optional
	GpuEnvironment *string `json:"gpuEnvironment,omitempty" tf:"gpu_environment,omitempty"`
}

type IPv4DNSRecordsInitParameters struct {

	// DNS zone ID (if not set, private zone is used).
	DNSZoneID *string `json:"dnsZoneId,omitempty" tf:"dns_zone_id,omitempty"`

	// DNS record FQDN.
	Fqdn *string `json:"fqdn,omitempty" tf:"fqdn,omitempty"`

	// When set to true, also create a PTR DNS record.
	Ptr *bool `json:"ptr,omitempty" tf:"ptr,omitempty"`

	// DNS record TTL (in seconds).
	TTL *float64 `json:"ttl,omitempty" tf:"ttl,omitempty"`
}

type IPv4DNSRecordsObservation struct {

	// DNS zone ID (if not set, private zone is used).
	DNSZoneID *string `json:"dnsZoneId,omitempty" tf:"dns_zone_id,omitempty"`

	// DNS record FQDN.
	Fqdn *string `json:"fqdn,omitempty" tf:"fqdn,omitempty"`

	// When set to true, also create a PTR DNS record.
	Ptr *bool `json:"ptr,omitempty" tf:"ptr,omitempty"`

	// DNS record TTL (in seconds).
	TTL *float64 `json:"ttl,omitempty" tf:"ttl,omitempty"`
}

type IPv4DNSRecordsParameters struct {

	// DNS zone ID (if not set, private zone is used).
	// +kubebuilder:validation:Optional
	DNSZoneID *string `json:"dnsZoneId,omitempty" tf:"dns_zone_id,omitempty"`

	// DNS record FQDN.
	// +kubebuilder:validation:Optional
	Fqdn *string `json:"fqdn" tf:"fqdn,omitempty"`

	// When set to true, also create a PTR DNS record.
	// +kubebuilder:validation:Optional
	Ptr *bool `json:"ptr,omitempty" tf:"ptr,omitempty"`

	// DNS record TTL (in seconds).
	// +kubebuilder:validation:Optional
	TTL *float64 `json:"ttl,omitempty" tf:"ttl,omitempty"`
}

type IPv6DNSRecordsInitParameters struct {

	// DNS zone ID (if not set, private zone is used).
	DNSZoneID *string `json:"dnsZoneId,omitempty" tf:"dns_zone_id,omitempty"`

	// DNS record FQDN.
	Fqdn *string `json:"fqdn,omitempty" tf:"fqdn,omitempty"`

	// When set to true, also create a PTR DNS record.
	Ptr *bool `json:"ptr,omitempty" tf:"ptr,omitempty"`

	// DNS record TTL (in seconds).
	TTL *float64 `json:"ttl,omitempty" tf:"ttl,omitempty"`
}

type IPv6DNSRecordsObservation struct {

	// DNS zone ID (if not set, private zone is used).
	DNSZoneID *string `json:"dnsZoneId,omitempty" tf:"dns_zone_id,omitempty"`

	// DNS record FQDN.
	Fqdn *string `json:"fqdn,omitempty" tf:"fqdn,omitempty"`

	// When set to true, also create a PTR DNS record.
	Ptr *bool `json:"ptr,omitempty" tf:"ptr,omitempty"`

	// DNS record TTL (in seconds).
	TTL *float64 `json:"ttl,omitempty" tf:"ttl,omitempty"`
}

type IPv6DNSRecordsParameters struct {

	// DNS zone ID (if not set, private zone is used).
	// +kubebuilder:validation:Optional
	DNSZoneID *string `json:"dnsZoneId,omitempty" tf:"dns_zone_id,omitempty"`

	// DNS record FQDN.
	// +kubebuilder:validation:Optional
	Fqdn *string `json:"fqdn" tf:"fqdn,omitempty"`

	// When set to true, also create a PTR DNS record.
	// +kubebuilder:validation:Optional
	Ptr *bool `json:"ptr,omitempty" tf:"ptr,omitempty"`

	// DNS record TTL (in seconds).
	// +kubebuilder:validation:Optional
	TTL *float64 `json:"ttl,omitempty" tf:"ttl,omitempty"`
}

type InstanceTemplateInitParameters struct {

	// The specifications for boot disks that will be attached to the instance. The structure is documented below.
	BootDisk []BootDiskInitParameters `json:"bootDisk,omitempty" tf:"boot_disk,omitempty"`

	// Container network configuration. The structure is documented below.
	ContainerNetwork []ContainerNetworkInitParameters `json:"containerNetwork,omitempty" tf:"container_network,omitempty"`

	// Container runtime configuration. The structure is documented below.
	ContainerRuntime []ContainerRuntimeInitParameters `json:"containerRuntime,omitempty" tf:"container_runtime,omitempty"`

	// GPU settings. The structure is documented below.
	GpuSettings []GpuSettingsInitParameters `json:"gpuSettings,omitempty" tf:"gpu_settings,omitempty"`

	// Labels that will be assigned to compute nodes (instances), created by the Node Group.
	// +mapType=granular
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// The set of metadata key:value pairs assigned to this instance template. This includes custom metadata and predefined keys. Note: key "user-data" won't be provided into instances. It reserved for internal activity in kubernetes_node_group resource.
	// +mapType=granular
	Metadata map[string]*string `json:"metadata,omitempty" tf:"metadata,omitempty"`

	// Boolean flag, enables NAT for node group compute instances.
	NAT *bool `json:"nat,omitempty" tf:"nat,omitempty"`

	// Name template of the instance. In order to be unique it must contain at least one of instance unique placeholders:
	// {instance.short_id}
	// {instance.index}
	// combination of {instance.zone_id} and {instance.index_in_zone}
	// Example: my-instance-{instance.index}
	// If not set, default is used: {instance_group.id}-{instance.short_id}
	// It may also contain another placeholders, see Compute Instance group metadata doc for full list.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Type of network acceleration. Values: standard, software_accelerated.
	NetworkAccelerationType *string `json:"networkAccelerationType,omitempty" tf:"network_acceleration_type,omitempty"`

	// An array with the network interfaces that will be attached to the instance. The structure is documented below.
	NetworkInterface []NetworkInterfaceInitParameters `json:"networkInterface,omitempty" tf:"network_interface,omitempty"`

	// The placement policy configuration. The structure is documented below.
	PlacementPolicy []PlacementPolicyInitParameters `json:"placementPolicy,omitempty" tf:"placement_policy,omitempty"`

	// The ID of the hardware platform configuration for the node group compute instances.
	PlatformID *string `json:"platformId,omitempty" tf:"platform_id,omitempty"`

	Resources []ResourcesInitParameters `json:"resources,omitempty" tf:"resources,omitempty"`

	// The scheduling policy for the instances in node group. The structure is documented below.
	SchedulingPolicy []SchedulingPolicyInitParameters `json:"schedulingPolicy,omitempty" tf:"scheduling_policy,omitempty"`
}

type InstanceTemplateObservation struct {

	// The specifications for boot disks that will be attached to the instance. The structure is documented below.
	BootDisk []BootDiskObservation `json:"bootDisk,omitempty" tf:"boot_disk,omitempty"`

	// Container network configuration. The structure is documented below.
	ContainerNetwork []ContainerNetworkObservation `json:"containerNetwork,omitempty" tf:"container_network,omitempty"`

	// Container runtime configuration. The structure is documented below.
	ContainerRuntime []ContainerRuntimeObservation `json:"containerRuntime,omitempty" tf:"container_runtime,omitempty"`

	// GPU settings. The structure is documented below.
	GpuSettings []GpuSettingsObservation `json:"gpuSettings,omitempty" tf:"gpu_settings,omitempty"`

	// Labels that will be assigned to compute nodes (instances), created by the Node Group.
	// +mapType=granular
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// The set of metadata key:value pairs assigned to this instance template. This includes custom metadata and predefined keys. Note: key "user-data" won't be provided into instances. It reserved for internal activity in kubernetes_node_group resource.
	// +mapType=granular
	Metadata map[string]*string `json:"metadata,omitempty" tf:"metadata,omitempty"`

	// Boolean flag, enables NAT for node group compute instances.
	NAT *bool `json:"nat,omitempty" tf:"nat,omitempty"`

	// Name template of the instance. In order to be unique it must contain at least one of instance unique placeholders:
	// {instance.short_id}
	// {instance.index}
	// combination of {instance.zone_id} and {instance.index_in_zone}
	// Example: my-instance-{instance.index}
	// If not set, default is used: {instance_group.id}-{instance.short_id}
	// It may also contain another placeholders, see Compute Instance group metadata doc for full list.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Type of network acceleration. Values: standard, software_accelerated.
	NetworkAccelerationType *string `json:"networkAccelerationType,omitempty" tf:"network_acceleration_type,omitempty"`

	// An array with the network interfaces that will be attached to the instance. The structure is documented below.
	NetworkInterface []NetworkInterfaceObservation `json:"networkInterface,omitempty" tf:"network_interface,omitempty"`

	// The placement policy configuration. The structure is documented below.
	PlacementPolicy []PlacementPolicyObservation `json:"placementPolicy,omitempty" tf:"placement_policy,omitempty"`

	// The ID of the hardware platform configuration for the node group compute instances.
	PlatformID *string `json:"platformId,omitempty" tf:"platform_id,omitempty"`

	Resources []ResourcesObservation `json:"resources,omitempty" tf:"resources,omitempty"`

	// The scheduling policy for the instances in node group. The structure is documented below.
	SchedulingPolicy []SchedulingPolicyObservation `json:"schedulingPolicy,omitempty" tf:"scheduling_policy,omitempty"`
}

type InstanceTemplateParameters struct {

	// The specifications for boot disks that will be attached to the instance. The structure is documented below.
	// +kubebuilder:validation:Optional
	BootDisk []BootDiskParameters `json:"bootDisk,omitempty" tf:"boot_disk,omitempty"`

	// Container network configuration. The structure is documented below.
	// +kubebuilder:validation:Optional
	ContainerNetwork []ContainerNetworkParameters `json:"containerNetwork,omitempty" tf:"container_network,omitempty"`

	// Container runtime configuration. The structure is documented below.
	// +kubebuilder:validation:Optional
	ContainerRuntime []ContainerRuntimeParameters `json:"containerRuntime,omitempty" tf:"container_runtime,omitempty"`

	// GPU settings. The structure is documented below.
	// +kubebuilder:validation:Optional
	GpuSettings []GpuSettingsParameters `json:"gpuSettings,omitempty" tf:"gpu_settings,omitempty"`

	// Labels that will be assigned to compute nodes (instances), created by the Node Group.
	// +kubebuilder:validation:Optional
	// +mapType=granular
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// The set of metadata key:value pairs assigned to this instance template. This includes custom metadata and predefined keys. Note: key "user-data" won't be provided into instances. It reserved for internal activity in kubernetes_node_group resource.
	// +kubebuilder:validation:Optional
	// +mapType=granular
	Metadata map[string]*string `json:"metadata,omitempty" tf:"metadata,omitempty"`

	// Boolean flag, enables NAT for node group compute instances.
	// +kubebuilder:validation:Optional
	NAT *bool `json:"nat,omitempty" tf:"nat,omitempty"`

	// Name template of the instance. In order to be unique it must contain at least one of instance unique placeholders:
	// {instance.short_id}
	// {instance.index}
	// combination of {instance.zone_id} and {instance.index_in_zone}
	// Example: my-instance-{instance.index}
	// If not set, default is used: {instance_group.id}-{instance.short_id}
	// It may also contain another placeholders, see Compute Instance group metadata doc for full list.
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Type of network acceleration. Values: standard, software_accelerated.
	// +kubebuilder:validation:Optional
	NetworkAccelerationType *string `json:"networkAccelerationType,omitempty" tf:"network_acceleration_type,omitempty"`

	// An array with the network interfaces that will be attached to the instance. The structure is documented below.
	// +kubebuilder:validation:Optional
	NetworkInterface []NetworkInterfaceParameters `json:"networkInterface,omitempty" tf:"network_interface,omitempty"`

	// The placement policy configuration. The structure is documented below.
	// +kubebuilder:validation:Optional
	PlacementPolicy []PlacementPolicyParameters `json:"placementPolicy,omitempty" tf:"placement_policy,omitempty"`

	// The ID of the hardware platform configuration for the node group compute instances.
	// +kubebuilder:validation:Optional
	PlatformID *string `json:"platformId,omitempty" tf:"platform_id,omitempty"`

	// +kubebuilder:validation:Optional
	Resources []ResourcesParameters `json:"resources,omitempty" tf:"resources,omitempty"`

	// The scheduling policy for the instances in node group. The structure is documented below.
	// +kubebuilder:validation:Optional
	SchedulingPolicy []SchedulingPolicyParameters `json:"schedulingPolicy,omitempty" tf:"scheduling_policy,omitempty"`
}

type MaintenancePolicyMaintenanceWindowInitParameters struct {
	Day *string `json:"day,omitempty" tf:"day,omitempty"`

	Duration *string `json:"duration,omitempty" tf:"duration,omitempty"`

	StartTime *string `json:"startTime,omitempty" tf:"start_time,omitempty"`
}

type MaintenancePolicyMaintenanceWindowObservation struct {
	Day *string `json:"day,omitempty" tf:"day,omitempty"`

	Duration *string `json:"duration,omitempty" tf:"duration,omitempty"`

	StartTime *string `json:"startTime,omitempty" tf:"start_time,omitempty"`
}

type MaintenancePolicyMaintenanceWindowParameters struct {

	// +kubebuilder:validation:Optional
	Day *string `json:"day,omitempty" tf:"day,omitempty"`

	// +kubebuilder:validation:Optional
	Duration *string `json:"duration" tf:"duration,omitempty"`

	// +kubebuilder:validation:Optional
	StartTime *string `json:"startTime" tf:"start_time,omitempty"`
}

type NetworkInterfaceInitParameters struct {

	// Allocate an IPv4 address for the interface. The default value is true.
	IPv4 *bool `json:"ipv4,omitempty" tf:"ipv4,omitempty"`

	// List of configurations for creating ipv4 DNS records. The structure is documented below.
	IPv4DNSRecords []IPv4DNSRecordsInitParameters `json:"ipv4DnsRecords,omitempty" tf:"ipv4_dns_records,omitempty"`

	// If true, allocate an IPv6 address for the interface. The address will be automatically assigned from the specified subnet.
	IPv6 *bool `json:"ipv6,omitempty" tf:"ipv6,omitempty"`

	// List of configurations for creating ipv6 DNS records. The structure is documented below.
	IPv6DNSRecords []IPv6DNSRecordsInitParameters `json:"ipv6DnsRecords,omitempty" tf:"ipv6_dns_records,omitempty"`

	// A public address that can be used to access the internet over NAT.
	NAT *bool `json:"nat,omitempty" tf:"nat,omitempty"`

	// Security group ids for network interface.
	// +crossplane:generate:reference:type=github.com/yandex-cloud/crossplane-provider-yc/apis/vpc/v1alpha1.SecurityGroup
	// +listType=set
	SecurityGroupIds []*string `json:"securityGroupIds,omitempty" tf:"security_group_ids,omitempty"`

	// References to SecurityGroup in vpc to populate securityGroupIds.
	// +kubebuilder:validation:Optional
	SecurityGroupIdsRefs []v1.Reference `json:"securityGroupIdsRefs,omitempty" tf:"-"`

	// Selector for a list of SecurityGroup in vpc to populate securityGroupIds.
	// +kubebuilder:validation:Optional
	SecurityGroupIdsSelector *v1.Selector `json:"securityGroupIdsSelector,omitempty" tf:"-"`

	// The IDs of the subnets.
	// +crossplane:generate:reference:type=github.com/yandex-cloud/crossplane-provider-yc/apis/vpc/v1alpha1.Subnet
	// +listType=set
	SubnetIds []*string `json:"subnetIds,omitempty" tf:"subnet_ids,omitempty"`

	// References to Subnet in vpc to populate subnetIds.
	// +kubebuilder:validation:Optional
	SubnetIdsRefs []v1.Reference `json:"subnetIdsRefs,omitempty" tf:"-"`

	// Selector for a list of Subnet in vpc to populate subnetIds.
	// +kubebuilder:validation:Optional
	SubnetIdsSelector *v1.Selector `json:"subnetIdsSelector,omitempty" tf:"-"`
}

type NetworkInterfaceObservation struct {

	// Allocate an IPv4 address for the interface. The default value is true.
	IPv4 *bool `json:"ipv4,omitempty" tf:"ipv4,omitempty"`

	// List of configurations for creating ipv4 DNS records. The structure is documented below.
	IPv4DNSRecords []IPv4DNSRecordsObservation `json:"ipv4DnsRecords,omitempty" tf:"ipv4_dns_records,omitempty"`

	// If true, allocate an IPv6 address for the interface. The address will be automatically assigned from the specified subnet.
	IPv6 *bool `json:"ipv6,omitempty" tf:"ipv6,omitempty"`

	// List of configurations for creating ipv6 DNS records. The structure is documented below.
	IPv6DNSRecords []IPv6DNSRecordsObservation `json:"ipv6DnsRecords,omitempty" tf:"ipv6_dns_records,omitempty"`

	// A public address that can be used to access the internet over NAT.
	NAT *bool `json:"nat,omitempty" tf:"nat,omitempty"`

	// Security group ids for network interface.
	// +listType=set
	SecurityGroupIds []*string `json:"securityGroupIds,omitempty" tf:"security_group_ids,omitempty"`

	// The IDs of the subnets.
	// +listType=set
	SubnetIds []*string `json:"subnetIds,omitempty" tf:"subnet_ids,omitempty"`
}

type NetworkInterfaceParameters struct {

	// Allocate an IPv4 address for the interface. The default value is true.
	// +kubebuilder:validation:Optional
	IPv4 *bool `json:"ipv4,omitempty" tf:"ipv4,omitempty"`

	// List of configurations for creating ipv4 DNS records. The structure is documented below.
	// +kubebuilder:validation:Optional
	IPv4DNSRecords []IPv4DNSRecordsParameters `json:"ipv4DnsRecords,omitempty" tf:"ipv4_dns_records,omitempty"`

	// If true, allocate an IPv6 address for the interface. The address will be automatically assigned from the specified subnet.
	// +kubebuilder:validation:Optional
	IPv6 *bool `json:"ipv6,omitempty" tf:"ipv6,omitempty"`

	// List of configurations for creating ipv6 DNS records. The structure is documented below.
	// +kubebuilder:validation:Optional
	IPv6DNSRecords []IPv6DNSRecordsParameters `json:"ipv6DnsRecords,omitempty" tf:"ipv6_dns_records,omitempty"`

	// A public address that can be used to access the internet over NAT.
	// +kubebuilder:validation:Optional
	NAT *bool `json:"nat,omitempty" tf:"nat,omitempty"`

	// Security group ids for network interface.
	// +crossplane:generate:reference:type=github.com/yandex-cloud/crossplane-provider-yc/apis/vpc/v1alpha1.SecurityGroup
	// +kubebuilder:validation:Optional
	// +listType=set
	SecurityGroupIds []*string `json:"securityGroupIds,omitempty" tf:"security_group_ids,omitempty"`

	// References to SecurityGroup in vpc to populate securityGroupIds.
	// +kubebuilder:validation:Optional
	SecurityGroupIdsRefs []v1.Reference `json:"securityGroupIdsRefs,omitempty" tf:"-"`

	// Selector for a list of SecurityGroup in vpc to populate securityGroupIds.
	// +kubebuilder:validation:Optional
	SecurityGroupIdsSelector *v1.Selector `json:"securityGroupIdsSelector,omitempty" tf:"-"`

	// The IDs of the subnets.
	// +crossplane:generate:reference:type=github.com/yandex-cloud/crossplane-provider-yc/apis/vpc/v1alpha1.Subnet
	// +kubebuilder:validation:Optional
	// +listType=set
	SubnetIds []*string `json:"subnetIds,omitempty" tf:"subnet_ids,omitempty"`

	// References to Subnet in vpc to populate subnetIds.
	// +kubebuilder:validation:Optional
	SubnetIdsRefs []v1.Reference `json:"subnetIdsRefs,omitempty" tf:"-"`

	// Selector for a list of Subnet in vpc to populate subnetIds.
	// +kubebuilder:validation:Optional
	SubnetIdsSelector *v1.Selector `json:"subnetIdsSelector,omitempty" tf:"-"`
}

type NodeGroupInitParameters struct {

	// This argument specify subnets (zones), that will be used by node group compute instances. The structure is documented below.
	AllocationPolicy []AllocationPolicyInitParameters `json:"allocationPolicy,omitempty" tf:"allocation_policy,omitempty"`

	// A list of allowed unsafe sysctl parameters for this node group. For more details see documentation.
	AllowedUnsafeSysctls []*string `json:"allowedUnsafeSysctls,omitempty" tf:"allowed_unsafe_sysctls,omitempty"`

	// The ID of the Kubernetes cluster that this node group belongs to.
	// +crossplane:generate:reference:type=Cluster
	ClusterID *string `json:"clusterId,omitempty" tf:"cluster_id,omitempty"`

	// Reference to a Cluster to populate clusterId.
	// +kubebuilder:validation:Optional
	ClusterIDRef *v1.Reference `json:"clusterIdRef,omitempty" tf:"-"`

	// Selector for a Cluster to populate clusterId.
	// +kubebuilder:validation:Optional
	ClusterIDSelector *v1.Selector `json:"clusterIdSelector,omitempty" tf:"-"`

	// Deploy policy of the node group. The structure is documented below.
	DeployPolicy []DeployPolicyInitParameters `json:"deployPolicy,omitempty" tf:"deploy_policy,omitempty"`

	// A description of the Kubernetes node group.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// Template used to create compute instances in this Kubernetes node group. The structure is documented below.
	InstanceTemplate []InstanceTemplateInitParameters `json:"instanceTemplate,omitempty" tf:"instance_template,omitempty"`

	// A set of key/value label pairs assigned to the Kubernetes node group.
	// +mapType=granular
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// (Computed) Maintenance policy for this Kubernetes node group. If policy is omitted, automatic revision upgrades are enabled and could happen at any time. Revision upgrades are performed only within the same minor version, e.g. 1.13. Minor version upgrades (e.g. 1.13->1.14) should be performed manually. The structure is documented below.
	MaintenancePolicy []NodeGroupMaintenancePolicyInitParameters `json:"maintenancePolicy,omitempty" tf:"maintenance_policy,omitempty"`

	// Name of a specific Kubernetes node group.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// A set of key/value label pairs, that are assigned to all the nodes of this Kubernetes node group.
	// +mapType=granular
	NodeLabels map[string]*string `json:"nodeLabels,omitempty" tf:"node_labels,omitempty"`

	// A list of Kubernetes taints, that are applied to all the nodes of this Kubernetes node group.
	NodeTaints []*string `json:"nodeTaints,omitempty" tf:"node_taints,omitempty"`

	// Scale policy of the node group. The structure is documented below.
	ScalePolicy []ScalePolicyInitParameters `json:"scalePolicy,omitempty" tf:"scale_policy,omitempty"`

	// Version of Kubernetes that will be used for Kubernetes node group.
	Version *string `json:"version,omitempty" tf:"version,omitempty"`
}

type NodeGroupMaintenancePolicyInitParameters struct {

	// Boolean flag that specifies if node group can be repaired automatically. When omitted, default value is TRUE.
	AutoRepair *bool `json:"autoRepair,omitempty" tf:"auto_repair,omitempty"`

	// Boolean flag that specifies if node group can be upgraded automatically. When omitted, default value is TRUE.
	AutoUpgrade *bool `json:"autoUpgrade,omitempty" tf:"auto_upgrade,omitempty"`

	// (Computed) Set of day intervals, when maintenance is allowed for this node group. When omitted, it defaults to any time.
	MaintenanceWindow []MaintenancePolicyMaintenanceWindowInitParameters `json:"maintenanceWindow,omitempty" tf:"maintenance_window,omitempty"`
}

type NodeGroupMaintenancePolicyObservation struct {

	// Boolean flag that specifies if node group can be repaired automatically. When omitted, default value is TRUE.
	AutoRepair *bool `json:"autoRepair,omitempty" tf:"auto_repair,omitempty"`

	// Boolean flag that specifies if node group can be upgraded automatically. When omitted, default value is TRUE.
	AutoUpgrade *bool `json:"autoUpgrade,omitempty" tf:"auto_upgrade,omitempty"`

	// (Computed) Set of day intervals, when maintenance is allowed for this node group. When omitted, it defaults to any time.
	MaintenanceWindow []MaintenancePolicyMaintenanceWindowObservation `json:"maintenanceWindow,omitempty" tf:"maintenance_window,omitempty"`
}

type NodeGroupMaintenancePolicyParameters struct {

	// Boolean flag that specifies if node group can be repaired automatically. When omitted, default value is TRUE.
	// +kubebuilder:validation:Optional
	AutoRepair *bool `json:"autoRepair" tf:"auto_repair,omitempty"`

	// Boolean flag that specifies if node group can be upgraded automatically. When omitted, default value is TRUE.
	// +kubebuilder:validation:Optional
	AutoUpgrade *bool `json:"autoUpgrade" tf:"auto_upgrade,omitempty"`

	// (Computed) Set of day intervals, when maintenance is allowed for this node group. When omitted, it defaults to any time.
	// +kubebuilder:validation:Optional
	MaintenanceWindow []MaintenancePolicyMaintenanceWindowParameters `json:"maintenanceWindow,omitempty" tf:"maintenance_window,omitempty"`
}

type NodeGroupObservation struct {

	// This argument specify subnets (zones), that will be used by node group compute instances. The structure is documented below.
	AllocationPolicy []AllocationPolicyObservation `json:"allocationPolicy,omitempty" tf:"allocation_policy,omitempty"`

	// A list of allowed unsafe sysctl parameters for this node group. For more details see documentation.
	AllowedUnsafeSysctls []*string `json:"allowedUnsafeSysctls,omitempty" tf:"allowed_unsafe_sysctls,omitempty"`

	// The ID of the Kubernetes cluster that this node group belongs to.
	ClusterID *string `json:"clusterId,omitempty" tf:"cluster_id,omitempty"`

	// (Computed) The Kubernetes node group creation timestamp.
	CreatedAt *string `json:"createdAt,omitempty" tf:"created_at,omitempty"`

	// Deploy policy of the node group. The structure is documented below.
	DeployPolicy []DeployPolicyObservation `json:"deployPolicy,omitempty" tf:"deploy_policy,omitempty"`

	// A description of the Kubernetes node group.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// (Computed) ID of instance group that is used to manage this Kubernetes node group.
	InstanceGroupID *string `json:"instanceGroupId,omitempty" tf:"instance_group_id,omitempty"`

	// Template used to create compute instances in this Kubernetes node group. The structure is documented below.
	InstanceTemplate []InstanceTemplateObservation `json:"instanceTemplate,omitempty" tf:"instance_template,omitempty"`

	// A set of key/value label pairs assigned to the Kubernetes node group.
	// +mapType=granular
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// (Computed) Maintenance policy for this Kubernetes node group. If policy is omitted, automatic revision upgrades are enabled and could happen at any time. Revision upgrades are performed only within the same minor version, e.g. 1.13. Minor version upgrades (e.g. 1.13->1.14) should be performed manually. The structure is documented below.
	MaintenancePolicy []NodeGroupMaintenancePolicyObservation `json:"maintenancePolicy,omitempty" tf:"maintenance_policy,omitempty"`

	// Name of a specific Kubernetes node group.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// A set of key/value label pairs, that are assigned to all the nodes of this Kubernetes node group.
	// +mapType=granular
	NodeLabels map[string]*string `json:"nodeLabels,omitempty" tf:"node_labels,omitempty"`

	// A list of Kubernetes taints, that are applied to all the nodes of this Kubernetes node group.
	NodeTaints []*string `json:"nodeTaints,omitempty" tf:"node_taints,omitempty"`

	// Scale policy of the node group. The structure is documented below.
	ScalePolicy []ScalePolicyObservation `json:"scalePolicy,omitempty" tf:"scale_policy,omitempty"`

	// (Computed) Status of the Kubernetes node group.
	Status *string `json:"status,omitempty" tf:"status,omitempty"`

	// Version of Kubernetes that will be used for Kubernetes node group.
	Version *string `json:"version,omitempty" tf:"version,omitempty"`

	// (Computed) Information about Kubernetes node group version. The structure is documented below.
	VersionInfo []NodeGroupVersionInfoObservation `json:"versionInfo,omitempty" tf:"version_info,omitempty"`
}

type NodeGroupParameters struct {

	// This argument specify subnets (zones), that will be used by node group compute instances. The structure is documented below.
	// +kubebuilder:validation:Optional
	AllocationPolicy []AllocationPolicyParameters `json:"allocationPolicy,omitempty" tf:"allocation_policy,omitempty"`

	// A list of allowed unsafe sysctl parameters for this node group. For more details see documentation.
	// +kubebuilder:validation:Optional
	AllowedUnsafeSysctls []*string `json:"allowedUnsafeSysctls,omitempty" tf:"allowed_unsafe_sysctls,omitempty"`

	// The ID of the Kubernetes cluster that this node group belongs to.
	// +crossplane:generate:reference:type=Cluster
	// +kubebuilder:validation:Optional
	ClusterID *string `json:"clusterId,omitempty" tf:"cluster_id,omitempty"`

	// Reference to a Cluster to populate clusterId.
	// +kubebuilder:validation:Optional
	ClusterIDRef *v1.Reference `json:"clusterIdRef,omitempty" tf:"-"`

	// Selector for a Cluster to populate clusterId.
	// +kubebuilder:validation:Optional
	ClusterIDSelector *v1.Selector `json:"clusterIdSelector,omitempty" tf:"-"`

	// Deploy policy of the node group. The structure is documented below.
	// +kubebuilder:validation:Optional
	DeployPolicy []DeployPolicyParameters `json:"deployPolicy,omitempty" tf:"deploy_policy,omitempty"`

	// A description of the Kubernetes node group.
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// Template used to create compute instances in this Kubernetes node group. The structure is documented below.
	// +kubebuilder:validation:Optional
	InstanceTemplate []InstanceTemplateParameters `json:"instanceTemplate,omitempty" tf:"instance_template,omitempty"`

	// A set of key/value label pairs assigned to the Kubernetes node group.
	// +kubebuilder:validation:Optional
	// +mapType=granular
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// (Computed) Maintenance policy for this Kubernetes node group. If policy is omitted, automatic revision upgrades are enabled and could happen at any time. Revision upgrades are performed only within the same minor version, e.g. 1.13. Minor version upgrades (e.g. 1.13->1.14) should be performed manually. The structure is documented below.
	// +kubebuilder:validation:Optional
	MaintenancePolicy []NodeGroupMaintenancePolicyParameters `json:"maintenancePolicy,omitempty" tf:"maintenance_policy,omitempty"`

	// Name of a specific Kubernetes node group.
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// A set of key/value label pairs, that are assigned to all the nodes of this Kubernetes node group.
	// +kubebuilder:validation:Optional
	// +mapType=granular
	NodeLabels map[string]*string `json:"nodeLabels,omitempty" tf:"node_labels,omitempty"`

	// A list of Kubernetes taints, that are applied to all the nodes of this Kubernetes node group.
	// +kubebuilder:validation:Optional
	NodeTaints []*string `json:"nodeTaints,omitempty" tf:"node_taints,omitempty"`

	// Scale policy of the node group. The structure is documented below.
	// +kubebuilder:validation:Optional
	ScalePolicy []ScalePolicyParameters `json:"scalePolicy,omitempty" tf:"scale_policy,omitempty"`

	// Version of Kubernetes that will be used for Kubernetes node group.
	// +kubebuilder:validation:Optional
	Version *string `json:"version,omitempty" tf:"version,omitempty"`
}

type NodeGroupVersionInfoInitParameters struct {
}

type NodeGroupVersionInfoObservation struct {

	// Current Kubernetes version, major.minor (e.g. 1.15).
	CurrentVersion *string `json:"currentVersion,omitempty" tf:"current_version,omitempty"`

	// True/false flag. Newer revisions may include Kubernetes patches (e.g 1.15.1 -> 1.15.2) as well as some internal component updates - new features or bug fixes in yandex-specific components either on the master or nodes.
	NewRevisionAvailable *bool `json:"newRevisionAvailable,omitempty" tf:"new_revision_available,omitempty"`

	// Human readable description of the changes to be applied when updating to the latest revision. Empty if new_revision_available is false.
	NewRevisionSummary *string `json:"newRevisionSummary,omitempty" tf:"new_revision_summary,omitempty"`

	// True/false flag. The current version is on the deprecation schedule, component (master or node group) should be upgraded.
	VersionDeprecated *bool `json:"versionDeprecated,omitempty" tf:"version_deprecated,omitempty"`
}

type NodeGroupVersionInfoParameters struct {
}

type PlacementPolicyInitParameters struct {

	// Specifies the id of the Placement Group to assign to the instances.
	PlacementGroupID *string `json:"placementGroupId,omitempty" tf:"placement_group_id,omitempty"`
}

type PlacementPolicyObservation struct {

	// Specifies the id of the Placement Group to assign to the instances.
	PlacementGroupID *string `json:"placementGroupId,omitempty" tf:"placement_group_id,omitempty"`
}

type PlacementPolicyParameters struct {

	// Specifies the id of the Placement Group to assign to the instances.
	// +kubebuilder:validation:Optional
	PlacementGroupID *string `json:"placementGroupId" tf:"placement_group_id,omitempty"`
}

type ResourcesInitParameters struct {

	// Baseline core performance as a percent.
	CoreFraction *float64 `json:"coreFraction,omitempty" tf:"core_fraction,omitempty"`

	// Number of CPU cores allocated to the instance.
	Cores *float64 `json:"cores,omitempty" tf:"cores,omitempty"`

	// Number of GPU cores allocated to the instance.
	Gpus *float64 `json:"gpus,omitempty" tf:"gpus,omitempty"`

	// The memory size allocated to the instance.
	Memory *float64 `json:"memory,omitempty" tf:"memory,omitempty"`
}

type ResourcesObservation struct {

	// Baseline core performance as a percent.
	CoreFraction *float64 `json:"coreFraction,omitempty" tf:"core_fraction,omitempty"`

	// Number of CPU cores allocated to the instance.
	Cores *float64 `json:"cores,omitempty" tf:"cores,omitempty"`

	// Number of GPU cores allocated to the instance.
	Gpus *float64 `json:"gpus,omitempty" tf:"gpus,omitempty"`

	// The memory size allocated to the instance.
	Memory *float64 `json:"memory,omitempty" tf:"memory,omitempty"`
}

type ResourcesParameters struct {

	// Baseline core performance as a percent.
	// +kubebuilder:validation:Optional
	CoreFraction *float64 `json:"coreFraction,omitempty" tf:"core_fraction,omitempty"`

	// Number of CPU cores allocated to the instance.
	// +kubebuilder:validation:Optional
	Cores *float64 `json:"cores,omitempty" tf:"cores,omitempty"`

	// Number of GPU cores allocated to the instance.
	// +kubebuilder:validation:Optional
	Gpus *float64 `json:"gpus,omitempty" tf:"gpus,omitempty"`

	// The memory size allocated to the instance.
	// +kubebuilder:validation:Optional
	Memory *float64 `json:"memory,omitempty" tf:"memory,omitempty"`
}

type ScalePolicyInitParameters struct {

	// Scale policy for an autoscaled node group. The structure is documented below.
	AutoScale []AutoScaleInitParameters `json:"autoScale,omitempty" tf:"auto_scale,omitempty"`

	// Scale policy for a fixed scale node group. The structure is documented below.
	FixedScale []FixedScaleInitParameters `json:"fixedScale,omitempty" tf:"fixed_scale,omitempty"`
}

type ScalePolicyObservation struct {

	// Scale policy for an autoscaled node group. The structure is documented below.
	AutoScale []AutoScaleObservation `json:"autoScale,omitempty" tf:"auto_scale,omitempty"`

	// Scale policy for a fixed scale node group. The structure is documented below.
	FixedScale []FixedScaleObservation `json:"fixedScale,omitempty" tf:"fixed_scale,omitempty"`
}

type ScalePolicyParameters struct {

	// Scale policy for an autoscaled node group. The structure is documented below.
	// +kubebuilder:validation:Optional
	AutoScale []AutoScaleParameters `json:"autoScale,omitempty" tf:"auto_scale,omitempty"`

	// Scale policy for a fixed scale node group. The structure is documented below.
	// +kubebuilder:validation:Optional
	FixedScale []FixedScaleParameters `json:"fixedScale,omitempty" tf:"fixed_scale,omitempty"`
}

type SchedulingPolicyInitParameters struct {

	// Specifies if the instance is preemptible. Defaults to false.
	Preemptible *bool `json:"preemptible,omitempty" tf:"preemptible,omitempty"`
}

type SchedulingPolicyObservation struct {

	// Specifies if the instance is preemptible. Defaults to false.
	Preemptible *bool `json:"preemptible,omitempty" tf:"preemptible,omitempty"`
}

type SchedulingPolicyParameters struct {

	// Specifies if the instance is preemptible. Defaults to false.
	// +kubebuilder:validation:Optional
	Preemptible *bool `json:"preemptible,omitempty" tf:"preemptible,omitempty"`
}

// NodeGroupSpec defines the desired state of NodeGroup
type NodeGroupSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     NodeGroupParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider NodeGroupInitParameters `json:"initProvider,omitempty"`
}

// NodeGroupStatus defines the observed state of NodeGroup.
type NodeGroupStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        NodeGroupObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// NodeGroup is the Schema for the NodeGroups API. Allows management of Yandex Kubernetes Node Group. For more information, see
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,yandex-cloud}
type NodeGroup struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.instanceTemplate) || (has(self.initProvider) && has(self.initProvider.instanceTemplate))",message="spec.forProvider.instanceTemplate is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.scalePolicy) || (has(self.initProvider) && has(self.initProvider.scalePolicy))",message="spec.forProvider.scalePolicy is a required parameter"
	Spec   NodeGroupSpec   `json:"spec"`
	Status NodeGroupStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// NodeGroupList contains a list of NodeGroups
type NodeGroupList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []NodeGroup `json:"items"`
}

// Repository type metadata.
var (
	NodeGroup_Kind             = "NodeGroup"
	NodeGroup_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: NodeGroup_Kind}.String()
	NodeGroup_KindAPIVersion   = NodeGroup_Kind + "." + CRDGroupVersion.String()
	NodeGroup_GroupVersionKind = CRDGroupVersion.WithKind(NodeGroup_Kind)
)

func init() {
	SchemeBuilder.Register(&NodeGroup{}, &NodeGroupList{})
}
